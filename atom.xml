<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凛冬将至</title>
  
  <subtitle>从简单的例子开始</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangdongdong122.github.io/"/>
  <updated>2022-02-25T07:45:08.964Z</updated>
  <id>http://wangdongdong122.github.io/</id>
  
  <author>
    <name>Dongdong Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2022/02/24/2_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E8%B0%83%E7%A0%94/"/>
    <id>http://wangdongdong122.github.io/2022/02/24/2_算法相关/表示学习调研/</id>
    <published>2022-02-24T07:17:15.243Z</published>
    <updated>2022-02-25T07:45:08.964Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><p>representation learning；data representation; Deep learning, representation learning, feature learning, unsupervised learning, Boltzmann Machine, autoencoder, neural nets</p><h1 id="粗读文献笔记"><a href="#粗读文献笔记" class="headerlink" title="粗读文献笔记"></a>粗读文献笔记</h1><h2 id="Bengio，2014，Representation-Learning-A-Review-and-New-Perspectives"><a href="#Bengio，2014，Representation-Learning-A-Review-and-New-Perspectives" class="headerlink" title="Bengio，2014，Representation Learning: A Review and New Perspectives"></a>Bengio，2014，Representation Learning: A Review and New Perspectives</h2><p><strong>Index Terms</strong>:Deep learning, representation learning, feature learning, unsupervised learning, Boltzmann Machine, autoencoder, neural nets,underlying explanatory factors</p><ul><li>机器学习的成功依赖于数据的表征（data representation），我们假设这是因为数据的表征或多或少的揭示了数据的内在结构。当然可以采用专家经验设计表征方式，但AI的目的在于依照通用的先验（generic priors）设计表征，并通过数据实例化这个表征。</li><li>“ This paper reviews recent work in the area of unsupervised feature learning and deep learning, covering advances in <strong>probabilistic models, auto-encoders, manifold learning, and deep networks.</strong> “<ul><li>本文聚焦与<strong>无监督学习</strong>，实现的方式包括以上三种方式。auto-encoders是基于信息重建的算法， manifold learning是基于拓扑学的算法</li></ul></li><li>这个工作有助于理解一个长期没有确定答案的问题：什么样的数据表征是一个好的表征？数据表征的优化目标是什么？<ul><li><strong>好的特征能够解耦数据中的关键潜在影响变量，这些变量最好是通用的（例如通用的语言模型、图像模型）。特征提取的过程就是冗余信息删减聚合的过程</strong>。如果不能通用，那退一步特征最好能提取针对下游任务有区分性的潜在因子，因子和任务目标之间最好有简单关系（如线性关系）</li></ul></li><li>“In order to expand the scope and ease of applicability of machine learning, it would be highly desirable to make learning algorithms <strong>less dependent on feature engineering</strong>, so that novel applications could be constructed faster, and more importantly, to <strong>make progress towards Artificial Intelligence</strong> (AI). An AI must fundamentally <em>understand the world around us</em>, and we argue that this can only be achieved if it can learn to identify and disentangle the underlying explanatory factors hidden in the observed milieu of <strong>low-level sensory data</strong>.” P1<ul><li>借助专家经验的特征工程能一定程度描述数据的内在结构，但真正的AI应该是解耦低等级的感官数据中的影响因子，从而了解这个世界的</li></ul></li><li>“In the case of probabilistic models, a good representation is often one that captures the posterior distribution of the <strong>underlying explanatory factors</strong> for the observed input.” P1<ul><li>对于概率模型，一个好的表征能够提取观察到的输入数据中的潜在影响因子。</li></ul></li><li>AI中的表示学习中的先验：<ul><li>平滑性（smoothness): x ≈ y generally implies f(x) ≈ f(y)</li><li>解耦（ Multiple explanatory factors）</li><li>层次化的组织方式（A hierarchical organization of explanatory factors）：越抽象的特征处于越高层</li><li>半监督（semi-supervised learning）:有一些解释X分布的因子也能解释Y的分布，基于这个假设，对于P(X)有用的表征对P(Y|X)也有用。所以note2vec的embeding才可以用于下游任务。但这个假设并不强，也就是用在下游任务不一定效果好</li><li>通用性（Shared factors across tasks）：能在不同的任务中共享一些因子</li><li>自然的聚集性（Natural clustering）</li></ul></li></ul><h2 id="Chen-2018-A-Tutorial-on-Network-Embeddings"><a href="#Chen-2018-A-Tutorial-on-Network-Embeddings" class="headerlink" title="Chen,2018,A Tutorial on Network Embeddings"></a>Chen,2018,A Tutorial on Network Embeddings</h2><p>Chen, H.; Perozzi, B.; Al-Rfou, R.; Skiena, S. A Tutorial on Network Embeddings. <em>arXiv:1808.02590 [cs]</em> <strong>2018</strong>.</p><ul><li><p>模型分类：unsupervised NE(以deepwalk为代表的无监督方法);  attributed NE(网络结构信息+节点和边的属性学习节点表征); Heterogeneous NE(从有多类节点或边的网络中学习表征)</p></li><li><p>NE的应用</p><ul><li><p>知识图谱（Knowledge Representation）：GenVector(2015), PDF2Vec(2016)</p></li><li><p>推荐（recommender system）</p><p>Chih-Ming Chen, Po-Chuan Chien, Yu-Ching Lin, Ming-Feng Tsai, and Yi-Hsuan Yang. Ex- ploiting latent social listening representations for music recommendations. In Proc Ninth ACM Int. Conf. Recommender Syst. Poster, 2015</p><p>Chih-Ming Chen, Ming-Feng Tsai, Yu-Ching Lin, and Yi-Hsuan Yang. Query-based music recommendations via preference embedding. In Proceedings of the 10th ACM Conference on Recommender Systems, pages 79–82. ACM, 2016.</p></li><li><p>NLP: PLE(2016), CANE(2017),</p><p>Hanyin Fang, Fei Wu, Zhou Zhao, Xinyu Duan, Yueting Zhuang, and Martin Ester. Community-based question answering via heterogeneous social network learning. In Thirtieth AAAI Conference on Artificial Intelligence, 2016.</p><p>Zhou Zhao, Qifan Yang, Deng Cai, Xiaofei He, and Yueting Zhuang. Expert finding for community-based question answering via ranking metric network learning. In IJCAI, pages 3000–3006, 2016.</p></li><li><p>社会关系（social network analysis）</p><p>Bryan Perozzi and Steven Skiena. Exact age prediction in social networks. In Proceedings of the 24th International Conference on World Wide Web, pages 91–92. ACM, 2015.</p><p>Cheng Yang, Maosong Sun, Wayne Xin Zhao, Zhiyuan Liu, and Edward Y Chang. A neural network approach to joint modeling social networks and mobile trajectories. arXiv preprint arXiv:1606.08154, 2016.</p></li></ul></li></ul><h1 id="精读文献笔记"><a href="#精读文献笔记" class="headerlink" title="精读文献笔记"></a>精读文献笔记</h1><h1 id="杂七杂八的comment"><a href="#杂七杂八的comment" class="headerlink" title="杂七杂八的comment"></a>杂七杂八的comment</h1><ul><li>无监督学习侧重于学习数据的内在关系、结构，比如clustering、grouping、density estimation, or anomaly detection等等，而自监督是根据数据集本身生成标签</li><li>表示学习领域的会议：ICML（ International Conference on Learning Representations）</li></ul><h1 id="文献总结"><a href="#文献总结" class="headerlink" title="文献总结"></a>文献总结</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]Bengio, Y.; Courville, A.; Vincent, P. Representation Learning: A Review and New Perspectives. <em>arXiv:1206.5538 [cs]</em> <strong>2014</strong>.【done】</p><p>[2] <a href="https://www.cxyzjd.com/article/weixin_42137700/106039656">图灵奖得主Bengio和LeCun称自监督学习可使AI达到人类智力水平</a>  【done】</p><p>[3] <a href="https://cloud.tencent.com/developer/article/1523877">图灵奖得主LeCun力推无监督学习：要重视基于能量的学习方法</a> 【done】</p><p><strong>[4] Weston, J.; Bengio, S.; Usunier, N. Large Scale Image Annotation: Learning to Rank with Joint Word-Image Embeddings. <em>Machine learning</em> 2010, <em>81</em> (1), 21–35.</strong> </p><p><strong>[5] Srivastava, N., &amp; Salakhutdinov, R. R. (2012). Multimodal learning with deep boltzmann machines. <em>Advances in neural information processing systems</em>, <em>25</em>.</strong></p><p>[6] Chen, H.; Perozzi, B.; Al-Rfou, R.; Skiena, S. A Tutorial on Network Embeddings. <em>arXiv:1808.02590 [cs]</em> <strong>2018</strong>. </p><p>[7]   Bryan Perozzi, Rami Al-Rfou, and Steven Skiena. Deepwalk: Online learning of social repre- sentations. In Proceedings of the 20th ACM SIGKDD international conference on Knowledge discovery and data mining, pages 701–710. ACM, 2014.</p><p>[8] Sami Abu-El-Haija, Bryan Perozzi, Rami Al-Rfou, and Alex Alemi. Watch your step: Learning graph embeddings through attention. arXiv preprint arXiv:1710.09599, 2017.</p><p>[9]  Xiaofei Sun, Jiang Guo, Xiao Ding, and Ting Liu. A general framework for content-enhanced network representation learning. arXiv preprint arXiv:1610.02906, 2016.【图的节点中有文本信息作为arttibute】</p><p>[][12][10]  Jifan Chen, Qi Zhang, and Xuanjing Huang. Incorporate group information to enhance network embedding. In Proceedings of the 25th ACM International on Conference on Information and Knowledge Management, pages 1901–1904. ACM, 2016.  【图中的节点有标签信息】</p><p>[11]  Chih-Ming Chen, Po-Chuan Chien, Yu-Ching Lin, Ming-Feng Tsai, and Yi-Hsuan Yang. Ex- ploiting latent social listening representations for music recommendations. In Proc Ninth ACM Int. Conf. Recommender Syst. Poster, 2015. 【NE在推荐中的应用】</p><p>[12]  Chih-Ming Chen, Ming-Feng Tsai, Yu-Ching Lin, and Yi-Hsuan Yang. Query-based music recommendations via preference embedding. In Proceedings of the 10th ACM Conference on Recommender Systems, pages 79–82. ACM, 2016.【NE在推荐中的应用】</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;关键词&quot;&gt;&lt;a href=&quot;#关键词&quot; class=&quot;headerlink&quot; title=&quot;关键词&quot;&gt;&lt;/a&gt;关键词&lt;/h1&gt;&lt;p&gt;representation learning；data representation; Deep lea
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2022/02/24/6_%E9%AB%98%E6%95%88tips/marginnote/"/>
    <id>http://wangdongdong122.github.io/2022/02/24/6_高效tips/marginnote/</id>
    <published>2022-02-24T05:00:57.919Z</published>
    <updated>2022-02-24T07:16:23.906Z</updated>
    
    <content type="html"><![CDATA[<p>导出word的大纲，用word打开，完美！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;导出word的大纲，用word打开，完美！&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2022/02/24/6_%E9%AB%98%E6%95%88tips/Zotero%E9%AB%98%E6%95%88%E7%AE%A1%E7%90%86%E6%96%87%E7%8C%AE/"/>
    <id>http://wangdongdong122.github.io/2022/02/24/6_高效tips/Zotero高效管理文献/</id>
    <published>2022-02-24T04:15:48.533Z</published>
    <updated>2022-02-25T04:04:40.268Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>现在 Zotero 有两种主流的同步方式</p><ul><li>WebDAV 方式</li><li>Zotfile+Onedriver 方式</li></ul><p>两种同步方式源于对文件管理的不同：</p><p>第一种方式：如果直接把论文文件拖入 Zotero 中，它会在数据文件夹自动拷贝一份并建立无意义的文件夹。而 WebDAV 方式就是直接同步数据文件夹。</p><p>第二种方式：由于第一种文件存储方式的原因，拷贝一份浪费空间，也不便查找。因此 Zotfile+Onedriver 同步方式是个人（强迫症）推荐的。Zotfile 用来管理文件的存储路径而 onedriver 则用来同步文件本身。</p><p>两者选择一种即可，如何选择呢？</p><p>如果你完全使用 Zotero 管理论文不在意本地文件夹，那么 WebDAV 方式同步论文就很方便，同时还可以支持移动端预览。如果你忽略文件夹的问题，你会发现这种方式省心省力。</p><p>如果你还想使用本地文件夹管理，zotero 仅仅作为写论文时导入方便那么 Zotfile+Onedrive 的方式最合适（本人也习惯使用这种方式）</p><h2 id="WebDAV-方式"><a href="#WebDAV-方式" class="headerlink" title="WebDAV 方式"></a>WebDAV 方式</h2><p>选用坚果云进行同步配置</p><ul><li>申请坚果云账号 www.jianguoyun.com</li><li>在个人网盘页面右上角账户名找到“帐户信息”-“安全选项”</li><li>在第三方应用管理中添加应用，应用名称随意</li></ul><p>zotero 客户端</p><ul><li>编辑-首选项-同步</li><li>数据同步登录 zotero 账号即可</li><li>文件同步中选择 WebDAV</li><li>URL：使用刚刚坚果云给的服务器地址 dav.jianguoyun.com/dav</li><li>用户名：使用坚果云账号</li><li>密码：使用刚刚坚果云给的的应用密码</li></ul><h2 id="ZotFile-OneDriver"><a href="#ZotFile-OneDriver" class="headerlink" title="ZotFile+OneDriver"></a>ZotFile+OneDriver</h2><p>上文<strong>配置路径</strong>中提到由于 Zotero 下载的文件或者直接通过拖动导入的文件会随机建立文件夹管理。ZotFile 可以转换成正常文件夹。</p><p>下载地址：<a href="http://zotfile.com/">http://zotfile.com/</a></p><p>在“工具”-“插件”中进行安装</p><h3 id="配置路径"><a href="#配置路径" class="headerlink" title="配置路径"></a>配置路径</h3><p>现存的论文文件可以直接通过拖动到 zotero 中，但是 zotero 会拷贝一份论文文件到数据存储路径并且存储文件夹命名是随机字符。不方便本地管理。</p><p>因此推荐使用导入文件链接的形式导入论文。在此之前</p><ul><li>在设置界面选择“高级”-“文件和文件夹”</li><li>链接附件的根目录设定为你论文存储的最最最根目录，本人使用的是 onedrive 文件夹“E:\下载\OneDrive”。</li><li>设定为相对路径（方便同步）</li></ul><p>设定完成之后就可以通过链接导入。</p><p>如果你在另一台电脑（PC-B）上也是用 onedrive，那么论文文件就可以同步，同时由于我们使用的相对路径，只要在另一台电脑（PC-B）上 zotero 设定“链接附件的根目录”也为这台电脑（PC-B）的 onedrive 根路径，那么 zotero 中也可以直接双击打开附件。</p><h3 id="分类同步配置"><a href="#分类同步配置" class="headerlink" title="分类同步配置"></a>分类同步配置</h3><ul><li><strong>“工具”-“zotfile preference”</strong>打开设置界面</li><li>General Setting 中第一个路径看作你将使用 zotero 下载文件或者拖动文件时的缓存路径</li><li>第二个路径就是你常用的论文文件存储的根路径。（“E:\下载\OneDrive”）</li><li>配置完成后可以测试随意拖动一个文件到 zetero 的分类条目中，zotero 会私自建立乱码文件夹。然后右键条目 Manage attachments-rename attachments 。Zotfile 会自动在刚才设定的根目录根据你的分类建立文件夹并且讲论文文件放置到该目录下并在条目中设定文件链接。</li><li>这样就保持了你文件夹存储方式和 zotero 分类标签的同步</li><li>即使你在 zotero 移动你的论文分类标签，只需要重新执行 rename attachments 就可以再次整理本地文件夹</li><li>你也可以在 Renaming Rules 设定重命名的格式</li></ul><h3 id="几点注意"><a href="#几点注意" class="headerlink" title="几点注意"></a>几点注意</h3><ul><li>如果你选用 WebDAV 方式进行同步，那么如果想在移动端（iPad,手机）查看那么使用 <strong>PaperShip</strong>可以直接同步附件文件你可以理解成移动端的 Zotero</li><li>如果你使用 ZotFile+ 同步盘的方式，如果想在移动端阅读那么可以直接下载你同步盘的客户端，或者使用 zotero 的 Table 功能，移动端 PDF Expert 同步查看</li></ul><h1 id="协同"><a href="#协同" class="headerlink" title="协同"></a>协同</h1><h2 id="与-Word-协同"><a href="#与-Word-协同" class="headerlink" title="与 Word 协同"></a>与 Word 协同</h2><p>使用 word 书写论文配合 zotero 可以方便管理引用</p><ul><li>首先在 zotero 设置界面“引用”-“文字处理软件”安装 word 插件。</li><li>在 word 的 zotero 插件选项卡中，在你想插入的文章位置选择 Add/Edit Citation，选择需要的论文样式，如果没有可以在线搜索。选择要引用的论文就可以了。</li><li>之后在文章末尾，点击 Add/Edit Bibliography 插入参考文献具体内容。</li></ul><h2 id="与-GoogleScholar-协同"><a href="#与-GoogleScholar-协同" class="headerlink" title="与 GoogleScholar 协同"></a>与 GoogleScholar 协同</h2><p>有时候我们需要找一些参考文献，但是我们不需要下载文件内容只是知道引用格式即可。前提已经安装好 Zotero chrome 插件。</p><ul><li>在 Google Scholar 设置界面，找到“参考书目管理软件”选择显示导入 EndNotes(必须)，点击保存。</li><li>我们随便搜索论文，在每个条目下面有个导入 Endnote 按钮，点击会弹出对话框就可以使用 zotero 保存这篇文章的引用了。</li><li>同时你也可以点击 chrome 中的 zotero 插件图标多选保存，如果你在 zotero 设置了保存条目时自动附加 PDF 文档（常规-文字处理），他也会帮你把文件下载下来。</li></ul><h2 id="与-Tablet-协同"><a href="#与-Tablet-协同" class="headerlink" title="与 Tablet 协同"></a>与 Tablet 协同</h2><p>此方法是适用于 ZotFile+ 同步盘文件管理方式。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxNzgyMDg0MQ==&amp;mid=2650457410&amp;idx=1&amp;sn=1198b535f1624ff63ff2f544c11e801c&amp;chksm=83d1d884b4a65192a238fd3fc2b0c4241b8768c2fc4e6ab927b8b669d99dcdd185278a83b3ee&amp;scene=158#rd">https://mp.weixin.qq.com/s?__biz=MzAxNzgyMDg0MQ==&amp;mid=2650457410&amp;idx=1&amp;sn=1198b535f1624ff63ff2f544c11e801c&amp;chksm=83d1d884b4a65192a238fd3fc2b0c4241b8768c2fc4e6ab927b8b669d99dcdd185278a83b3ee&amp;scene=158#rd</a></p><h2 id="与Latex协同"><a href="#与Latex协同" class="headerlink" title="与Latex协同"></a>与Latex协同</h2><p>有时候我们用word写完论文需要转为latex格式，其中引用部分很头疼。可以使用下面的工具直接从word中提取引用为bibtex格式，也可以选择在zotero选中引用论文，然后你可以将选中论文拖动到一个单独的分类下面，之后就可以用zotero自带的导出功能生成bibtex文件</p><p><a href="https://rintze.zelle.me/ref-extractor/">https://rintze.zelle.me/ref-extractor/</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://zhuanlan.zhihu.com/p/104848524">https://zhuanlan.zhihu.com/p/104848524</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;同步&quot;&gt;&lt;a href=&quot;#同步&quot; class=&quot;headerlink&quot; title=&quot;同步&quot;&gt;&lt;/a&gt;同步&lt;/h1&gt;&lt;p&gt;现在 Zotero 有两种主流的同步方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WebDAV 方式&lt;/li&gt;
&lt;li&gt;Zotf
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/12/09/2_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E6%9D%8E%E5%AE%8F%E6%AF%85%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://wangdongdong122.github.io/2021/12/09/2_算法相关/李宏毅强化学习笔记/</id>
    <published>2021-12-09T11:52:36.883Z</published>
    <updated>2021-12-17T06:37:22.781Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="PART1"><a href="#PART1" class="headerlink" title="PART1"></a>PART1</h1><p><strong>什么是强化学习</strong></p><p>强化学习决策过程包括4个环节：agent观察环境（observation）—-agent做出动作（action）——动作会引起环境的变化 —- agent得到奖励（reward）—-agent再次观察环境（observation）。强化学习就是通过学习实现agent的决策序列收益（reward）最大。</p><p><strong>强化学习的分类</strong></p><p>policy based, grade based, model based。 这三种方式其实是不同的reward方式</p><h1 id="PART-2"><a href="#PART-2" class="headerlink" title="PART 2"></a>PART 2</h1><h1 id="PART-3"><a href="#PART-3" class="headerlink" title="PART 3"></a>PART 3</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;PART1&quot;&gt;&lt;a href=&quot;#PART1&quot; class=&quot;headerlink&quot; title=&quot;PART1&quot;&gt;&lt;/a&gt;PART1&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;什么是强化学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;强化学习决策过程包括4个环
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/09/28/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/tensroflow%E5%90%84%E7%A7%8D%E6%A8%A1%E5%9E%8B%E4%BF%9D%E5%AD%98%E5%92%8C%E5%8A%A0%E8%BD%BD/"/>
    <id>http://wangdongdong122.github.io/2021/09/28/0_代码相关/tensroflow各种模型保存和加载/</id>
    <published>2021-09-28T02:44:23.148Z</published>
    <updated>2021-09-29T02:33:17.130Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/128546377">https://zhuanlan.zhihu.com/p/128546377</a></p><p>[TOC]</p><h1 id="Tensorflow笔记：模型保存、加载和Fine-tune"><a href="#Tensorflow笔记：模型保存、加载和Fine-tune" class="headerlink" title="Tensorflow笔记：模型保存、加载和Fine-tune"></a>Tensorflow笔记：模型保存、加载和Fine-tune</h1><p><a href="https://www.zhihu.com/people/chong-yu-4-73"><img src="pics/tensroflow各种模型保存和加载/v2-da8a1fcd82fbe5f7206ac58cee088681_xs.jpg" alt="锟斤拷"></a></p><p><a href="https://www.zhihu.com/people/chong-yu-4-73">锟斤拷</a></p><p>50 人赞同了该文章</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>尝试过迁移学习的同学们都知道，Tensorflow的模型保存加载有不同格式，使用方法也不一样，新手会觉得乱七八糟，所以本文做一个梳理。从模型的保存到加载，再到使用，力求理清这个流程。</p><h2 id="1-保存"><a href="#1-保存" class="headerlink" title="1. 保存"></a>1. 保存</h2><p>Tensorflow的保存分为三种：1. checkpoint模式；2. pb模式；3. saved_model模式。</p><h3 id="1-1-先假设有这么个模型"><a href="#1-1-先假设有这么个模型" class="headerlink" title="1.1 先假设有这么个模型"></a>1.1 先假设有这么个模型</h3><p>首先假定我们已经有了这样一个简单的线性回归网络结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">size = 10</span><br><span class="line"># 构建input</span><br><span class="line">X = tf.placeholder(name=&quot;input&quot;, shape=[None, size], dtype=tf.float32)</span><br><span class="line">y = tf.placeholder(name=&quot;label&quot;, shape=[None, 1], dtype=tf.float32)</span><br><span class="line"># 网络结构</span><br><span class="line">beta = tf.get_variable(name=&quot;beta&quot;, shape=[size, 1], initializer=tf.glorot_normal_initializer())</span><br><span class="line">bias = tf.get_variable(name=&quot;bias&quot;, shape=[1], initializer=tf.glorot_normal_initializer())</span><br><span class="line">pred = tf.add(tf.matmul(X, beta), bias, name=&quot;output&quot;)</span><br><span class="line"># 构建损失</span><br><span class="line">loss = tf.losses.mean_squared_error(y, pred)</span><br><span class="line"># 构建train_op</span><br><span class="line">train_op = tf.train.AdamOptimizer(learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8).minimize(loss)</span><br></pre></td></tr></table></figure><p>我们来简单初始化，然后跑一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 假设这是一个batch_size=8的batch</span><br><span class="line">feed_X = np.ones((8,size)).astype(np.float32)</span><br><span class="line">feed_y = np.ones((8,1)).astype(np.float32)</span><br><span class="line"># 先看一下pred，在训练一个step，在看一下pred是否有变化</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    print(sess.run(pred, feed_dict=&#123;X:feed_X&#125;))</span><br><span class="line">    sess.run(train_op, feed_dict=&#123;X:feed_X, y:feed_y&#125;)</span><br><span class="line">    print(sess.run(pred, feed_dict=&#123;X:feed_X&#125;))</span><br></pre></td></tr></table></figure><p>可以看到初始化的输出y值，以及训练1个step之后的模型输出发生了变化。</p><h3 id="1-2-checkpoint模式"><a href="#1-2-checkpoint模式" class="headerlink" title="1.2 checkpoint模式"></a>1.2 checkpoint模式</h3><p>checkpoint模式将网络和变量数据分开保存，保存好的模型长这个样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|--checkpoint_dir</span><br><span class="line">|    |--checkpoint</span><br><span class="line">|    |--test-model-550.meta</span><br><span class="line">|    |--test-model-550.data-00000-of-00001</span><br><span class="line">|    |--test-model-550.index</span><br></pre></td></tr></table></figure><p>checkpoint_dir就是保存时候指定的路径，路径下会生成4个文件。其中.meta文件（其实就是pb格式文件）用来保存模型结构，.data和.index文件用来保存模型中的各种变量，而checkpoint文件里面记录了最新的checkpoint文件以及其它checkpoint文件列表，在inference时可以通过修改这个文件，指定使用哪个model。那么要如何保存呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 只有sess中有变量的值，所以保存模型的操作只能在sess内</span><br><span class="line">checkpoint_dir = &quot;./model_ckpt/&quot;</span><br><span class="line">saver = tf.train.Saver(max_to_keep=1)    # saver 不需要在sess内</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    saver.save(sess, checkpoint_dir + &quot;test-model&quot;,global_step=i, write_meta_graph=True)</span><br></pre></td></tr></table></figure><p>实际就两步。执行之后就可以在checkpoint_dir下面看到前面提到的4个文件了。（这里的max_to_keep是指本次训练在checkpoint_dir这个路径下最多保存多少个模型文件，新模型会覆盖旧模型以节省空间）。</p><h3 id="1-3-pb模式"><a href="#1-3-pb模式" class="headerlink" title="1.3 pb模式"></a>1.3 pb模式</h3><p>pb模式保存的模型，只有在目标路径pb_dir = “./model_pb/“下孤孤单单的一个文件”test-model.pb”，这也是它相比于其他几种方式的优势，简单明了。假设还是前面的网络结构，如果想保存成pb模式该怎么做呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 只有sess中有变量的值，所以保存模型的操作只能在sess内</span><br><span class="line">pb_dir = &quot;./model_pb/&quot;</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    graph_def = tf.get_default_graph().as_graph_def()</span><br><span class="line">    # 这里是指定要冻结并保存到pb模型中的变量</span><br><span class="line">    var_list = [&quot;input&quot;, &quot;label&quot;, &quot;beta&quot;, &quot;bias&quot;, &quot;output&quot;]   # 如果有name_scope，要写全名，如:&quot;name_scope/beta&quot; </span><br><span class="line">    constant_graph = tf.graph_util.convert_variables_to_constants(sess, graph_def, var_list)</span><br><span class="line">    with tf.gfile.FastGFile(pb_dir + &quot;test-model.pb&quot;, mode=&#x27;wb&#x27;) as f:</span><br><span class="line">        f.write(constant_graph.SerializeToString())</span><br></pre></td></tr></table></figure><p>其实pb模式本质上就是把变量先冻结成常数，然后保存到图结构中。这样就可以直接加载图结构和“参数”了。</p><h3 id="1-4-saved-model模式"><a href="#1-4-saved-model模式" class="headerlink" title="1.4 saved_model模式"></a>1.4 saved_model模式</h3><p>虽然saved_model也支持模型加载，并进行迁移学习。可是不得不说<strong>saved_model几乎就是为了部署而生的</strong>，因为依靠tf.Serving部署模型时要求模型格式必须是saved_model格式。除此以外saved_model还有另外一个优点就是可以跨语言读取，所以本文也介绍一下这种模式的保存于加载。<strong>本文样例的保存在参数设置上会考虑到方便部署</strong>。保存好的saved_model结构长这个样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|--saved_model_dir</span><br><span class="line">|    |--1</span><br><span class="line">|        |--saved_model.pb</span><br><span class="line">|        |--variables</span><br><span class="line">|            |--variables.data-00000-of-00001</span><br><span class="line">|            |--variables.index</span><br></pre></td></tr></table></figure><p>保存时需要将保存路径精确到”saved_model_dir/1/ “，会在下面生成一个pb文件，以及一个variables文件夹。其中“1”文件夹是表示版本的文件夹，应该是一个整数。人为设定这个“版本文件夹”的原因是，在模型部署的时候需要将模型位置精确到saved_model_dir，tf.Serving会在saved_model_dir下搜索版本号最大的路径下的模型进行服务。模型保存的方法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 只有sess中有变量的值，所以保存模型的操作只能在sess内</span><br><span class="line">version = &quot;1/&quot;</span><br><span class="line">saved_model_dir = &quot;./saved_model/test-model-dir/&quot;</span><br><span class="line">builder = tf.saved_model.builder.SavedModelBuilder(saved_model_dir + version)</span><br><span class="line"></span><br><span class="line"># 构建 signature</span><br><span class="line">signature = tf.saved_model.signature_def_utils.build_signature_def(</span><br><span class="line">        # 获取输入输出的信息（shape,dtype等），在部署服务后请求带来的数据会喂到inputs中，服务吐的结果会以outputs的形式返回</span><br><span class="line">        inputs=&#123;&quot;input&quot;: tf.saved_model.utils.build_tensor_info(X)&#125;,          # 获取输入tensor的信息，这个字典可以有多个key-value对</span><br><span class="line">        outputs=&#123;&quot;output&quot;: tf.saved_model.utils.build_tensor_info(pred)&#125;,     # 获取输出tensor的信息，这个字典可以有多个key-value对</span><br><span class="line">        method_name=tf.saved_model.signature_constants.PREDICT_METHOD_NAME    # 就是&#x27;tensorflow/serving/predict&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 保存到 saved_model</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    builder.add_meta_graph_and_variables(sess, </span><br><span class="line">        tags=[tf.saved_model.tag_constants.SERVING],         # 如果用来部署，就这样写。否则可以写其他，如[&quot;test-model&quot;]</span><br><span class="line">        signature_def_map=&#123;&quot;serving_default&quot;: signature&#125;,    # 如果用来部署，字典的key必须是&quot;serving_default&quot;。否则可以写其他</span><br><span class="line">    )</span><br><span class="line">    builder.save()</span><br></pre></td></tr></table></figure><p>因为涉及到部署，比较复杂，这里不得不说明一下。</p><p>在保存之前需要构建一个signature，用来构造signature的build_signature_def函数有三个参数：inputs、outputs、method_name。其中inputs和outputs分别用来获取输入输出向量的信息，在部署服务后来的数据会喂到inputs中，服务吐的结果会以outputs的形式返回；而method_name如果用来部署模型的话需要设置为”tensorflow/serving/predict”, “tensorflow/serving/classify”, “tensorflow/serving/regress” 中的一个。如果不是用来服务，就可以写一个其他的。</p><p>在保存的时候，除了刚刚构建的signature，还需要提供一个tags 参数，如果用来部署的话需要填[tf.saved_model.tag_constants.SERVING]，否则可以填其他。另外如果用来部署模型的话，signature_def_map的key必须是”serving_default”。</p><h2 id="2-加载"><a href="#2-加载" class="headerlink" title="2. 加载"></a>2. 加载</h2><p>下面说如何加载，checkpoint和pb两种模式的加载方法也不一样。下面分别说</p><h3 id="2-1-checkpoint加载（略烦）"><a href="#2-1-checkpoint加载（略烦）" class="headerlink" title="2.1 checkpoint加载（略烦）"></a>2.1 checkpoint加载（略烦）</h3><p>checkpoint模式的网络结构和变量是分来保存的，加载的时候也需要分别加载。而网络结构部分你有两种选择：1. 加载.meta文件中的结构， 2. 手动重新写一遍原样结构。</p><p>我们先说后一个，如果你不光有模型文件，还有源码，可以把源码构建模型那部分复制过来，然后只加载变量就好，这是手动重新搭建网络结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">size = 10</span><br><span class="line"># 构建input</span><br><span class="line">X = tf.placeholder(name=&quot;input&quot;, shape=[None, size], dtype=tf.float32)</span><br><span class="line">y = tf.placeholder(name=&quot;label&quot;, shape=[None, 1], dtype=tf.float32)</span><br><span class="line"># 网络结构</span><br><span class="line">beta = tf.get_variable(name=&quot;beta&quot;, shape=[size, 1], initializer=tf.glorot_normal_initializer())</span><br><span class="line">bias = tf.get_variable(name=&quot;bias&quot;, shape=[1], initializer=tf.glorot_normal_initializer())</span><br><span class="line">pred = tf.sigmoid(tf.matmul(X, beta) + bias, name=&quot;output&quot;)</span><br></pre></td></tr></table></figure><p>然后加载变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 假设这是一个batch_size=8的batch</span><br><span class="line">feed_X = np.ones((8,size)).astype(np.float32)</span><br><span class="line">feed_y = np.ones((8,1)).astype(np.float32)</span><br><span class="line"># 用加载出来的参数，跑一下pred</span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    saver.restore(sess, tf.train.latest_checkpoint(&#x27;./model_ckpt/&#x27;))    # 加载模型中的变量</span><br><span class="line">    # sess.run(tf.global_variables_initializer())    # 重新初始化一下参数</span><br><span class="line">    print(sess.run(pred, feed_dict=&#123;X:feed_X&#125;))</span><br></pre></td></tr></table></figure><p>所以手动构建网络结构后，只需要saver.restore一下，就可以加载模型中的参数。</p><p>另外，如果将上面的sess.run(tf.global_variables_initializer())注释掉，那每次运行的结果都一样，可见此时模型中的变量确实是加载进来的变量。如果取消注释这一句，每次跑出来的结果都不同，因为加载进来的变量又被初始化函数覆盖了，所以每次都不一样。这也说明了：<strong>通过checkpoint这种模式加载进来的变量，依然是变量，而且是trainable=True的</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(tf.trainable_variables())</span><br></pre></td></tr></table></figure><p>结果为：[<tf.Variable 'beta:0' shape=(10, 1) dtype=float32_ref>, <tf.Variable 'bias:0' shape=(1,) dtype=float32_ref>]</p><p>那如果我懒，活着没有源码，无法手动构建网络呢？就需要从.meta文件里导入网络结构了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 不手动构建，从文件中加载网络结构</span><br><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line">size = 10</span><br><span class="line"># 加载网络</span><br><span class="line">saver=tf.train.import_meta_graph(&#x27;./model_ckpt/test-model-0.meta&#x27;)</span><br></pre></td></tr></table></figure><p>什么？这就完了？网络结构在哪呢？先别急，这种方法就是这样，网络结构已经加载进来了，那怎么用呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 假设这是一个batch</span><br><span class="line">feed_X = np.ones((8,size)).astype(np.float32)</span><br><span class="line">feed_y = np.ones((8,1)).astype(np.float32)</span><br><span class="line"># 下面我们来跑一下 pred</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    saver.restore(sess, tf.train.latest_checkpoint(&#x27;./model_ckpt/&#x27;))  # 加载模型变量</span><br><span class="line">    graph = tf.get_default_graph()</span><br><span class="line">    X = graph.get_tensor_by_name(&quot;input:0&quot;)        # 根据tensor名字获取tensor变量</span><br><span class="line">    pred = graph.get_tensor_by_name(&quot;output:0&quot;)    # 根据tensor名字获取tensor变量</span><br><span class="line">    # sess.run(tf.global_variables_initializer())  # 是否重新初始化变量</span><br><span class="line">    print(sess.run(pred, feed_dict=&#123;X:feed_X&#125;))</span><br></pre></td></tr></table></figure><p>其实前面把网络结构加载进来之后，如果需要对某tensor进行操作的话（run、feed、concat等等）需要通过tensor的name获取成变量。同样通过sess.run(tf.global_variables_initializer())可以看出，加载进来的变量，还是变量。</p><p>总结一下：手动构建网络结构的话，缺点是麻烦！优点是你想用什么变量直接用就行；而通过.meta文件来加载网络结构，优点是省事，缺点是如果想用某个变量，必须通过name获取变量。</p><h3 id="2-2-pb模式加载"><a href="#2-2-pb模式加载" class="headerlink" title="2.2 pb模式加载"></a>2.2 pb模式加载</h3><p>相比之下，pb模式的加载旧没那么复杂，因为他的网络结构和数据是存在一起的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># 直接从pb获取tensor</span><br><span class="line">pb_dir = &quot;./model_pb/&quot;</span><br><span class="line">with tf.gfile.FastGFile(pb_dir + &quot;test-model.pb&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    graph_def = tf.GraphDef()</span><br><span class="line">    graph_def.ParseFromString(f.read())    # 从pb文件中导入信息</span><br><span class="line">    # 从网络中通过tensor的name获取为变量</span><br><span class="line">    X, pred = tf.import_graph_def(graph_def, return_elements=[&quot;input:0&quot;, &quot;output:0&quot;])</span><br></pre></td></tr></table></figure><p>现在我们就已经有了X和pred，下面来跑一个pred吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 假设这是一个batch</span><br><span class="line">feed_X = np.ones((8,size)).astype(np.float32)</span><br><span class="line">feed_y = np.ones((8,1)).astype(np.float32)</span><br><span class="line"># 跑一下 pred</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    # sess.run(tf.global_variables_initializer())</span><br><span class="line">    print(sess.run(pred, feed_dict=&#123;X:feed_X&#125;))</span><br></pre></td></tr></table></figure><p>就这么简单！从pb中获取进来的“变量”就可以直接用。为什么我要给变量两个字打上引号呢？因为在pb模型里保存的其实是常量了，取消注释sess.run(tf.global_variables_initializer())后，多次运行的结果还是一样的。此时的“beta:0”和”bias:0”已经不再是variable，而是constant。<strong>这带来一个好处：读取模型中的tensor可以在Session外进行。相比之下checkpoint只能在Session内读取模型，对Fine-tune来说就比较麻烦。</strong></p><h3 id="2-3-saved-model模式加载"><a href="#2-3-saved-model模式加载" class="headerlink" title="2.3 saved_model模式加载"></a>2.3 saved_model模式加载</h3><p>前两种加载方法想要获取tensor，要么需要手动搭建网络，要么需要知道tensor的name，如果用模型和训模型的不是同一个人，那在没有源码的情况下，就不方便获取每个tensor的name。好在saved_model可以通过前面提到的signature_def_map的方法获取tensor。先看一下直接通过tensor的name获取变量的加载方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 假设这是一个batch</span><br><span class="line">size = 10</span><br><span class="line">feed_X = np.ones((8,size)).astype(np.float32)</span><br><span class="line">feed_y = np.ones((8,1)).astype(np.float32)</span><br><span class="line"></span><br><span class="line">saved_model_dir = &quot;./saved_model/1/&quot;</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    # tf.saved_model.tag_constants.SERVING == &quot;serve&quot;，这里load时的tags需要和保存时的tags一致</span><br><span class="line">    meta_graph_def = tf.saved_model.loader.load(sess, tags=[&quot;serve&quot;], export_dir=saved_model_dir)</span><br><span class="line">    graph = tf.get_default_graph()</span><br><span class="line">    X = graph.get_tensor_by_name(&quot;input:0&quot;)</span><br><span class="line">    pred = graph.get_tensor_by_name(&quot;output:0&quot;)</span><br><span class="line">    # sess.run(tf.global_variables_initializer())</span><br><span class="line">    print(sess.run(pred, feed_dict=&#123;X:feed_X&#125;))</span><br></pre></td></tr></table></figure><p>这里和checkpoint的加载过程很相似，先一个load过程，然后get_tensor_by_name。这需要我们事先知道tensor的name。如果有了signature的信息就不一样了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 假设这是一个batch</span><br><span class="line">size = 10</span><br><span class="line">feed_X = np.ones((8,size)).astype(np.float32)</span><br><span class="line">feed_y = np.ones((8,1)).astype(np.float32)</span><br><span class="line"></span><br><span class="line">saved_model_dir = &quot;./saved_model/1/&quot;</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    # tf.saved_model.tag_constants.SERVING == &quot;serve&quot;，这里load时的tags需要和保存时的tags一致</span><br><span class="line">    meta_graph_def = tf.saved_model.loader.load(sess, tags=[&quot;serve&quot;], export_dir=saved_model_dir)</span><br><span class="line">    signature = meta_graph_def.signature_def</span><br><span class="line">    # print(signature)    # signature 内包含了保存模型时，signature_def_map 的信息</span><br><span class="line">    X = signature[&quot;serving_default&quot;].inputs[&quot;input&quot;].name</span><br><span class="line">    pred = signature[&quot;serving_default&quot;].outputs[&quot;output&quot;].name</span><br><span class="line">    print(sess.run(pred, feed_dict=&#123;X:feed_X&#125;))</span><br></pre></td></tr></table></figure><p>这时即使我们没有源码，也可以通过print(signature)获知关于tensor的信息，如上就展示了没有源码时，通过signature获取tensor的name，并获取tensor的过程。这里输出的signature长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># signature长什么样</span><br><span class="line">print(signature)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">INFO:tensorflow:Restoring parameters from ./saved_model/1/variables/variables</span><br><span class="line">&#123;&#x27;serving_default&#x27;: inputs &#123;</span><br><span class="line">  key: &quot;input&quot;</span><br><span class="line">  value &#123;</span><br><span class="line">    name: &quot;input:0&quot;</span><br><span class="line">    dtype: DT_FLOAT</span><br><span class="line">    tensor_shape &#123;</span><br><span class="line">      dim &#123;</span><br><span class="line">        size: -1</span><br><span class="line">      &#125;</span><br><span class="line">      dim &#123;</span><br><span class="line">        size: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">outputs &#123;</span><br><span class="line">  key: &quot;output&quot;</span><br><span class="line">  value &#123;</span><br><span class="line">    name: &quot;output:0&quot;</span><br><span class="line">    dtype: DT_FLOAT</span><br><span class="line">    tensor_shape &#123;</span><br><span class="line">      dim &#123;</span><br><span class="line">        size: -1</span><br><span class="line">      &#125;</span><br><span class="line">      dim &#123;</span><br><span class="line">        size: 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">method_name: &quot;tensorflow/serving/predict&quot;</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="3-Fine-tune"><a href="#3-Fine-tune" class="headerlink" title="3. Fine-tune"></a>3. Fine-tune</h2><p>最后不管保存还是加载模型，多数情况都是为了能够进行迁移学习。其实大部分无非就是将模型加载进来之后，使用某一个节点的值，作为我们后续模型的输入呗。比如我要用前面的模型结果作为特征通过一元罗辑回归去预测z，这样新的网络结构就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line"># 加载模型部分，直接从pb获取X和pred</span><br><span class="line">pb_dir = &quot;./model_pb/&quot;</span><br><span class="line">with tf.gfile.FastGFile(pb_dir + &quot;test-model.pb&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    graph_def = tf.GraphDef()</span><br><span class="line">    graph_def.ParseFromString(f.read())</span><br><span class="line">    X, pred = tf.import_graph_def(graph_def, return_elements=[&quot;input:0&quot;, &quot;output:0&quot;])</span><br><span class="line"></span><br><span class="line"># 下面是 Fine-tune 部分</span><br><span class="line"># 新的 label</span><br><span class="line">z = tf.placeholder(name=&quot;new_label&quot;, shape=[None, 1], dtype=tf.float32)</span><br><span class="line"># 新的参数</span><br><span class="line">new_beta = tf.get_variable(name=&quot;new_beta&quot;, shape=[1], initializer=tf.glorot_normal_initializer())</span><br><span class="line">new_bias = tf.get_variable(name=&quot;new_bias&quot;, shape=[1], initializer=tf.glorot_normal_initializer())</span><br><span class="line"># 一元罗辑回归，通过pred去预测z</span><br><span class="line">new_pred = tf.sigmoid(new_beta * pred + new_beta)    # 这种变量不写name的习惯是不好的哦</span><br><span class="line"></span><br><span class="line"># 下面是构建模型的损失函数以及train_op</span><br><span class="line"># log_loss</span><br><span class="line">new_loss = tf.reduce_mean(tf.losses.log_loss(predictions=new_pred, labels=z))</span><br><span class="line"># train_op</span><br><span class="line">train_op = tf.train.AdamOptimizer(learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8).minimize(new_loss)</span><br></pre></td></tr></table></figure><p>就是这样，把保存好的模型看作一个黑盒，喂进去X吐出来pred，然后我们直接用pred就好了。</p><p>但是这里存在一个问题，就是只能通过name获取节点。比如这里的new_pred就没有name，那我想要基于这个新模型再次进行Fine-tune的时候，就不能获取这个new_pred，就无法进行Fine-tune。所以大家还是要养成一个好习惯，多给变量起名字，尤其是placeholder！要是连placeholder都没名字，别人就没法用你的模型啦。如果保存的是saved_model，建议一定要设置signature。</p><p>下面来实验一下这个Fine-tune的模型吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 假设这是一个batch</span><br><span class="line">feed_X = np.ones((8,size)).astype(np.float32)</span><br><span class="line">feed_z = np.array([[1],[1],[0],[0],[1],[1],[0],[0]]).astype(np.float32)</span><br><span class="line"># 跑一下 new_pred 之后train一个step，在看看 new_pred 有没有改变</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    print(sess.run(new_pred, feed_dict=&#123;X:feed_X&#125;))</span><br><span class="line">    sess.run(train_op,  feed_dict=&#123;X:feed_X, z:feed_z&#125;)</span><br><span class="line">    print(sess.run(new_pred, feed_dict=&#123;X:feed_X&#125;))</span><br></pre></td></tr></table></figure><p>这里补充一下：<strong>通过pb模式导入进来的参数其实是constants，所以在Fine-tune的时候不会变化，而通过checkpoint模式导入进来的参数是variables，在后续Fine-tune的时候是会发生变化的</strong>。具体让不让他trainable就看你的实际需要了。</p><h2 id="4-其他补充"><a href="#4-其他补充" class="headerlink" title="4. 其他补充"></a>4. 其他补充</h2><p>在2.2中，加载pb模型的时候，并不需要把所有的tensor都获取到，只要“一头一尾”即可。因为头（”input:0”）是需要进行feed操作的，而尾（”output:0”）是需要输出，或者在迁移学习中要进行其他操作。至于中间哪些其他不需要进行操作的tensor，可以不获取。</p><p>因为只有pb模式在加载的时候，可以在Session外进行加载，方便Fine-tune。所以个人建议，如果要进行迁移学习，先将模型转化为pb模式。</p><p>其他的想起来在写</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/128546377&quot;&gt;https://zhuanlan.zhihu.com/p/128546377&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Tensorflow笔记：模型保存、加载
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/09/01/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/iterm%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    <id>http://wangdongdong122.github.io/2021/09/01/0_代码相关/iterm奇淫技巧/</id>
    <published>2021-09-01T03:41:23.076Z</published>
    <updated>2021-09-01T03:44:10.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-修改tag名称"><a href="#1-修改tag名称" class="headerlink" title="1.修改tag名称"></a>1.修改tag名称</h1><p>快捷键 ： command+i  ，修改session name。</p><p><img src="pics/iterm奇淫技巧/image-20210901114300463.png" alt="image-20210901114300463" style="zoom:25%;" /></p><p>右键-new tag 现在的tag就能显示自定义名称</p><p><img src="pics/iterm奇淫技巧/image-20210901114353748.png" alt="image-20210901114353748" style="zoom:25%;" /></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-修改tag名称&quot;&gt;&lt;a href=&quot;#1-修改tag名称&quot; class=&quot;headerlink&quot; title=&quot;1.修改tag名称&quot;&gt;&lt;/a&gt;1.修改tag名称&lt;/h1&gt;&lt;p&gt;快捷键 ： command+i  ，修改session name。&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hierarchical Attention Networks</title>
    <link href="http://wangdongdong122.github.io/2021/06/21/2_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/Awesome-Deep-Learning-Papers-for-Search-Recommendation-Advertising/"/>
    <id>http://wangdongdong122.github.io/2021/06/21/2_算法相关/Awesome-Deep-Learning-Papers-for-Search-Recommendation-Advertising/</id>
    <published>2021-06-21T01:26:17.000Z</published>
    <updated>2022-02-28T15:58:25.047Z</updated>
    
    <content type="html"><![CDATA[<p>Self-Attention谁先提出的，各文章里写的不一样，<a href="https://papers.nips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf">Attention Is All You Need</a>中说是<a href="https://arxiv.org/pdf/1606.01933.pdf">Jakob.2016</a>年提出的，<a href="https://arxiv.org/pdf/1904.02874.pdf">An Attentive Survey of Attention Models</a>中说是<a href="https://www.aclweb.org/anthology/N16-1174.pdf">Yang et al. 2016</a>，本篇介绍后者。</p><span id="more"></span><p>[TOC]</p><h1 id="Awesome-Deep-Learning-Papers-for-Search-Recommendation-Advertising"><a href="#Awesome-Deep-Learning-Papers-for-Search-Recommendation-Advertising" class="headerlink" title="Awesome-Deep-Learning-Papers-for-Search-Recommendation-Advertising"></a>Awesome-Deep-Learning-Papers-for-Search-Recommendation-Advertising</h1><p>阅读等级：精，粗，to粗</p><h2 id="0-New-Papers"><a href="#0-New-Papers" class="headerlink" title="0_New_Papers"></a>0_New_Papers</h2><h2 id="1-Embedding"><a href="#1-Embedding" class="headerlink" title="1_Embedding"></a>1_Embedding</h2><h2 id="2-Maching"><a href="#2-Maching" class="headerlink" title="2_Maching"></a>2_Maching</h2><h2 id="3-Ranking"><a href="#3-Ranking" class="headerlink" title="3_Ranking"></a>3_Ranking</h2><h3 id="【页面维度信息-负反馈】2022-Alibaba-WSDM-ZhifangFan-RACP-Modeling-Users’-Contextualized-Page-wise-Feedback-for-Click-Through-Rate-Prediction-in-E-commerce-Search"><a href="#【页面维度信息-负反馈】2022-Alibaba-WSDM-ZhifangFan-RACP-Modeling-Users’-Contextualized-Page-wise-Feedback-for-Click-Through-Rate-Prediction-in-E-commerce-Search" class="headerlink" title="【页面维度信息+负反馈】2022 (Alibaba) (WSDM)(ZhifangFan)[RACP]Modeling Users’ Contextualized Page-wise Feedback for Click-Through Rate Prediction in E-commerce Search"></a>【页面维度信息+负反馈】2022 (Alibaba) (WSDM)(ZhifangFan)[RACP]Modeling Users’ Contextualized Page-wise Feedback for Click-Through Rate Prediction in E-commerce Search</h3><ul><li>简介：建模用户的历史行为对个性化搜索和推荐都很重要，现有方法主要是对用户历史正反馈的建模（点击序列），忽略了产生反馈的上下文信息。本文通过加入历史<strong>页面维度的曝光和反馈</strong>做一位用户历史行为序列，提出了一种新的上下文感知的用户行为建模方式。通过捕捉页面内的信息和页面间的演化可以更详细的学习用户的偏好。 RACP(Recurrent Attention over Contextualized Page sequence)模型通过<strong>page-context aware attention</strong> 学习页面内的关系。<strong>recurrent attention</strong>学习页面间的关系</li><li>模型结构：</li></ul><p><img src="file:///Users/hetianqi/Documents/0_charging/hexo_init/source/_posts/notes_of_the_world/2_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/pics/Awesome-Deep-Learning-Papers-for-Search-Recommendation-Advertising/image-20220228121702691.png?lastModify=1646028941" alt="image-20220228121702691"></p><ul><li>quote<ul><li>“However, they treat users’ positive and negative feedback separately, and rep- resent users’ feedback as a clicked item sequence and a non-clicked item sequence, which cannot generate the mutual context between clicks and non-clicks and ignores other page context information in the page-sequence” 历史工作很少考虑负反馈，即便考虑也是和正反馈分开处理的，这忽略了<strong>正负反馈之间的相互作用</strong></li><li>页面信息的增益：1）<strong>正反馈是有噪音的</strong>，避免过拟合。一个用户点了一个品牌不一定是他就偏好这个品牌，有可能是整个页面都是这个品牌 2) 用户对item的行为受曝光的其他item影响</li><li>页面间的增益：搜索场景下用户的行为和意图是一个逐渐收敛的过程。例如：搜索—-曝光—-点击—-搜索—-曝光—-点击—-购买</li><li>“Recently, some pioneering work (<strong>DFN</strong> [33], <strong>DSTN</strong> [25]) high- light the importance of modeling both users’ positive and negative feedback for CTR prediction.” 一些负反馈的工作</li><li>item画像：item id,品类id,shop id,统计类（成单量等）</li><li>query画像：query id,字符串，分词，类别</li><li><strong>页内的attention聚合+页间兴趣回溯(GRU，由下一个page表征当前的query) + 页间兴趣融合(attention)</strong></li></ul></li></ul><h3 id="【长期行为-SimHash相似度】2021-Alibaba-ArXiv-ETA-End-to-End-User-Behavior-Retrieval-in-Click-Through-Rate-Prediction-Model"><a href="#【长期行为-SimHash相似度】2021-Alibaba-ArXiv-ETA-End-to-End-User-Behavior-Retrieval-in-Click-Through-Rate-Prediction-Model" class="headerlink" title="【长期行为+SimHash相似度】2021(Alibaba)(ArXiv)[ETA]End-to-End User Behavior Retrieval in Click-Through Rate Prediction Model"></a>【长期行为+SimHash相似度】2021(Alibaba)(ArXiv)[ETA]End-to-End User Behavior Retrieval in Click-Through Rate Prediction Model</h3><ul><li><p>简介：用户的长期行为对CTR预估很重要，但由于性能的约束，超长期用户行为通常是通过两段式训练进行处理的。第一阶段通过长期行为召回topK,第二阶段结合短期行为进行排序。两阶段由于优化目标不一致降低了长期用户行为带来的CTR增益。本文通过<strong>locality- sensitive hashing (LSH)</strong>方法提出端到端的ETA模型，使得满足训练和推理性能要求的前提下端到端训练的长期用户行为ctr模型。主要是通过<strong>SimHash</strong>的方法计算相似度，使得相似度的计算复杂度由O(L<em> B </em> d)变为O(L*B)，其中L是序列长度，B是candidate梳理，d是embedding维度</p></li><li><p>模型结构：</p><p><img src="pics/Awesome-Deep-Learning-Papers-for-Search-Recommendation-Advertising/image-20220228145221827.png" alt="image-20220228145221827" style="zoom:50%;" /></p></li></ul><h3 id="2021-Alibaba-CIKM-ZEUS-Self-Supervised-Learning-on-Users’-Spontaneous-Behaviors-for-Multi-Scenario-Ranking-in-E-commerce"><a href="#2021-Alibaba-CIKM-ZEUS-Self-Supervised-Learning-on-Users’-Spontaneous-Behaviors-for-Multi-Scenario-Ranking-in-E-commerce" class="headerlink" title="2021 (Alibaba) (CIKM) [ZEUS] Self-Supervised Learning on Users’ Spontaneous Behaviors for Multi-Scenario Ranking in E-commerce"></a>2021 (Alibaba) (CIKM) [ZEUS] Self-Supervised Learning on Users’ Spontaneous Behaviors for Multi-Scenario Ranking in E-commerce</h3><h3 id="2020-JD-WSDM-HUP-Hierarchical-User-Profiling-for-E-commerce-Recommender-Systems"><a href="#2020-JD-WSDM-HUP-Hierarchical-User-Profiling-for-E-commerce-Recommender-Systems" class="headerlink" title="2020 (JD) (WSDM) [HUP] Hierarchical User Profiling for E-commerce Recommender Systems"></a>2020 (JD) (WSDM) [HUP] Hierarchical User Profiling for E-commerce Recommender Systems</h3><h3 id="【加入负反馈-显反馈对隐反馈去噪】2021-Alibaba-ACM-DUMN-Denoising-User-aware-Memory-Network-for-Recommendation"><a href="#【加入负反馈-显反馈对隐反馈去噪】2021-Alibaba-ACM-DUMN-Denoising-User-aware-Memory-Network-for-Recommendation" class="headerlink" title="【加入负反馈+显反馈对隐反馈去噪】2021(Alibaba)(ACM)[DUMN]Denoising User-aware Memory Network for Recommendation"></a>【加入负反馈+显反馈对隐反馈去噪】2021(Alibaba)(ACM)[DUMN]Denoising User-aware Memory Network for Recommendation</h3><ul><li>简介：最近推荐领域非常多的工作聚焦在用户行为建模。用户的反馈包含显式和隐式的，大部分工作忽略了<strong>隐式反馈的噪音</strong>（用显示反馈对隐式反馈进行去噪），这会导致对于用户兴趣的有偏理解，本文1）通过正交映射( orthogonal mapping)对隐反馈进行去噪  2)基于内存的用户长期行为建模  3)短期行为和长期行为的融合。输入包括4个部分，<strong>显示反馈：喜欢，不喜欢 ；隐式反馈：点击，未点击</strong></li><li>外卖场景下的显示隐式反馈是什么？？？<img src="pics/Awesome-Deep-Learning-Papers-for-Search-Recommendation-Advertising/image-20220228150641871.png" alt="image-20220228150641871" style="zoom:50%;" /></li></ul><h2 id="4-Post-Ranking"><a href="#4-Post-Ranking" class="headerlink" title="4_Post_Ranking"></a>4_Post_Ranking</h2><h2 id="5-Multi-task"><a href="#5-Multi-task" class="headerlink" title="5_Multi-task"></a>5_Multi-task</h2><h2 id="6-Graph-Neural-Network"><a href="#6-Graph-Neural-Network" class="headerlink" title="6_Graph_Neural_Network"></a>6_Graph_Neural_Network</h2><h2 id="7-Transfer-Learning"><a href="#7-Transfer-Learning" class="headerlink" title="7_Transfer_Learning"></a>7_Transfer_Learning</h2><h2 id="8-Reignforcement-Learning"><a href="#8-Reignforcement-Learning" class="headerlink" title="8_Reignforcement_Learning"></a>8_Reignforcement_Learning</h2><h2 id="9-Self-Supervised-Learning"><a href="#9-Self-Supervised-Learning" class="headerlink" title="9_Self_Supervised_Learning"></a>9_Self_Supervised_Learning</h2><h2 id="10-Corporation"><a href="#10-Corporation" class="headerlink" title="10_Corporation"></a>10_Corporation</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>参考github awosome paper repository: <a href="https://github.com/guyulongcs/Awesome-Deep-Learning-Papers-for-Search-Recommendation-Advertising">Awesome-Deep-Learning-Papers-for-Search-Recommendation-Advertising</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Self-Attention谁先提出的，各文章里写的不一样，&lt;a href=&quot;https://papers.nips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf&quot;&gt;Attention Is All You Need&lt;/a&gt;中说是&lt;a href=&quot;https://arxiv.org/pdf/1606.01933.pdf&quot;&gt;Jakob.2016&lt;/a&gt;年提出的，&lt;a href=&quot;https://arxiv.org/pdf/1904.02874.pdf&quot;&gt;An Attentive Survey of Attention Models&lt;/a&gt;中说是&lt;a href=&quot;https://www.aclweb.org/anthology/N16-1174.pdf&quot;&gt;Yang et al. 2016&lt;/a&gt;，本篇介绍后者。&lt;/p&gt;
    
    </summary>
    
      <category term="论文学习" scheme="http://wangdongdong122.github.io/categories/%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://wangdongdong122.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Attention" scheme="http://wangdongdong122.github.io/tags/Attention/"/>
    
      <category term="Transformer" scheme="http://wangdongdong122.github.io/tags/Transformer/"/>
    
      <category term="机器学习" scheme="http://wangdongdong122.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="每日论文" scheme="http://wangdongdong122.github.io/tags/%E6%AF%8F%E6%97%A5%E8%AE%BA%E6%96%87/"/>
    
      <category term="经典算法" scheme="http://wangdongdong122.github.io/tags/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    
      <category term="NLP" scheme="http://wangdongdong122.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/06/16/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/%E5%88%9D%E8%AF%86Thrift/"/>
    <id>http://wangdongdong122.github.io/2021/06/16/0_代码相关/初识Thrift/</id>
    <published>2021-06-16T06:08:18.635Z</published>
    <updated>2021-06-16T11:19:05.263Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>RPC（远程服务调用）</p><ul><li>thrift框架是什么，Thrift是一套包含序列化功能和支持服务通信的RPC（远程服务调用）框架，也是一种微服务框架。其主要特点是可以跨语言使用，这也是这个框架最吸引人的地方。</li><li><p>IDL(Interface Definition Language)即接口定义语言，是CORBA规范的一部分，是跨平台开发的基础。IDL提供一套通用的数据类型，并以这些数据类型来定义更为复杂的数 据类型</p></li><li><p>pipline （以java为例）</p></li></ul><ol><li><p>help.thrift—-文件定义抽象service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace java tutorial</span><br><span class="line">namespace py tutorial</span><br><span class="line"></span><br><span class="line">typedef i32 int // We can use typedef to get pretty names for the types we are using</span><br><span class="line">service MultiplicationService</span><br><span class="line">&#123;</span><br><span class="line">        int multiply(1:int n1, 2:int n2),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译thrift文件得到service抽象类，类中定义了接口方法 public interface Iface</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift --gen java help.thrift  #生成MultiplicationService类，有虚方法 Iface</span><br></pre></td></tr></table></figure></li><li><p>自定义handler，实现（implements）service的interface（接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.thrift.TException;</span><br><span class="line"><span class="keyword">import</span> tutorial.MultiplicationService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiplicationHandler</span> <span class="keyword">implements</span> <span class="title">MultiplicationService</span>.<span class="title">Iface</span> </span>&#123; <span class="comment">//实现方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Multiply(&quot;</span> + n1 + <span class="string">&quot;,&quot;</span> + n2 + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> n1 * n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义server</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;RPC（远程服务调用）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;thrift框架是什么，Thrift是一套包含序列化功能和支持服务通信的RPC（远程服务调用）框架，也是一种微服务框架。其主要特点是可以跨语言使用，这也是这个框架最吸引人的地方。&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/06/15/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/anaconda+tensorflow%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://wangdongdong122.github.io/2021/06/15/0_代码相关/anaconda+tensorflow安装教程/</id>
    <published>2021-06-15T12:58:23.000Z</published>
    <updated>2021-10-29T07:12:20.068Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="安装pip-conda-tensorflow"><a href="#安装pip-conda-tensorflow" class="headerlink" title="安装pip,conda,tensorflow"></a>安装pip,conda,tensorflow</h1><ol><li><p>安装pip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip --version #check id exists</span><br><span class="line"></span><br><span class="line">sudo easy_install pip #安装pip</span><br></pre></td></tr></table></figure><p>pip —version错误：ImportError: No module named typing</p></li><li><p>官网下载并安装anaconda,安装时勾选添加环境变量【非常重要，不然后续会出错】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> anaconda path 如果忘记勾选了，要配置环境变量</span></span><br><span class="line">vim ~/.bash_proflw</span><br><span class="line">export PATH=$PATH:/Users/hetianqi/opt/anaconda3/bin/</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>cmd中确认conda安装正确</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda -V</span><br></pre></td></tr></table></figure></li><li><p>创建新的虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#windows 的tensorflow只支持python3以上，3.6稳定，3.7和3.8都不稳定</span></span><br><span class="line">conda create -n python3.6 python=3.6 </span><br><span class="line">conda info -e</span><br><span class="line">conda env list</span><br><span class="line">conda activate python3.6  </span><br></pre></td></tr></table></figure></li><li><p>安装tensorflow</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/tensorflow/">https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/tensorflow/</a> 清华镜像，可查询tensorflow版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip+清华镜像</span></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple tensorflow==2.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># pip+豆瓣镜像</span></span><br><span class="line">pip install -i https://pypi.douban.com/simple tensorflow==2.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># conda + </span></span><br><span class="line">conda install --channel https://conda.anaconda.org/anaconda tensorflow=2.0.0</span><br><span class="line"></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>在jupyterlab中使用tf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source activate 环境 #激活环境</span><br><span class="line">conda install ipykernel</span><br><span class="line">conda install ipython</span><br><span class="line">conda install jupyterlab</span><br><span class="line">ipython kernelspec install-self ––user</span><br><span class="line">python -m ipykernel install --user --name 环境名称 --display-name “环境名称” </span><br></pre></td></tr></table></figure></li></ol><ol><li><p>安装xgboost</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple XGBoost  <span class="comment">#win10</span></span><br><span class="line">conda install py-xgboost <span class="comment">#mac</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>安装torch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pip install torch===1.3.0 torchvision===0.4.1 -f https://download.pytorch.org/whl/torch_stable.html -i  https://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure></li></ol><h1 id="安装scala-pyspark"><a href="#安装scala-pyspark" class="headerlink" title="安装scala,pyspark"></a>安装scala,pyspark</h1><ol><li><p>安装brew</p><p>在网上搜了很多brew安装方式，包括使用官网的方式都安装报错<br>Failed to connect to raw.githubusercontent.com port 443: Connection refused</p><p>可使用一下源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>安装scala</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew search scala #查看可安装版本</span><br><span class="line">brew instal scala@2.12</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改~/.bash_profile</span></span><br><span class="line">export PATH=&quot;/usr/local/opt/scala@2.11/bin:$PATH</span><br><span class="line">scala -version #check是否安装成功</span><br></pre></td></tr></table></figure><p>报错： Error opening archive: Failed to open ‘/Users/hetianqi/Library/Caches/Homebrew/downloads/d1650a0762f1f057c43d5600d72a18d9aaa0c5da3cd172cac87ae9fcb6439bc0—openjdk-16.0.1.big_sur.bottle.tar.gz’</p><p>解决方法：export HOMEBREW_BOTTLE_DOMAIN=’’ </p><p>详细解释参考 <a href="https://zhuanlan.zhihu.com/p/383707713">https://zhuanlan.zhihu.com/p/383707713</a></p><blockquote><p>如果scala交互模式下方向键乱码，则在~/.bash_profile中添加</p><p>export TERM=xterm-color</p></blockquote></li><li><p>安装spark</p><p>a) 下载安装包 <a href="http://spark.apache.org/downloads.html">http://spark.apache.org/downloads.html</a></p></li></ol><p><img src="pics/anaconda+tensorflow安装教程/image-20211013142113102.png" alt="image-20211013142113102" style="zoom:50%;" /></p><p>​        b) 解压安装包，复制到路径 /usr/local/Cellar/</p><p>​        c) 修改~/.bash_profile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export SPARK_HOME=/usr/local/Cellar/spark/</span><br><span class="line">export PATH=$SPARK_HOME:$SPARK_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>​        d) check是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-shell</span><br></pre></td></tr></table></figure><p><img src="pics/anaconda+tensorflow安装教程/image-20211013142621551.png" alt="image-20211013142621551" style="zoom:50%;" /></p><ol><li>安装pyspark</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyspark</span><br></pre></td></tr></table></figure><ol><li><p>配置idea for scala and spark</p><p>Step1：建空maven项目</p><p>Step2:  建scala目录并mark as source</p><p>Step3: 下载scala插件：preference —&gt; pluging —&gt;scala</p><p>Step4: 增加框架支持：右击工程—&gt; add framework —&gt; scala</p><p>Step5: 添加apache jars: 右击工程 —&gt; open module settings —&gt; libraries —&gt; + java —&gt; browes —&gt; /usr/local/Cellar/spark/jars  (finder看不见这个文件夹可以 commmand + shift + G)</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;安装pip-conda-tensorflow&quot;&gt;&lt;a href=&quot;#安装pip-conda-tensorflow&quot; class=&quot;headerlink&quot; title=&quot;安装pip,conda,tensorflow&quot;&gt;&lt;/a&gt;安装pip,c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/04/30/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/python/"/>
    <id>http://wangdongdong122.github.io/2021/04/30/0_代码相关/python/</id>
    <published>2021-04-30T07:06:04.000Z</published>
    <updated>2021-09-29T03:32:40.582Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="快速安装python依赖包"><a href="#快速安装python依赖包" class="headerlink" title="快速安装python依赖包"></a>快速安装python依赖包</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># requirements.txt</span><br><span class="line">certifi==2020.4.5.1</span><br><span class="line">chardet==3.0.4</span><br><span class="line">idna==2.9</span><br><span class="line">lxml==4.5.1</span><br><span class="line">requests==2.23.0</span><br><span class="line">urllib3==1.25.9</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="importlib-动态导入包"><a href="#importlib-动态导入包" class="headerlink" title="importlib 动态导入包"></a>importlib 动态导入包</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入指定类或方法</span></span><br><span class="line"><span class="keyword">from</span> model_fn <span class="keyword">import</span> dmtTrainer</span><br><span class="line">module = importlib.import_module(FLAGS.model_fn)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dmtTrainer = module.dmtTrainer</span><br></pre></td></tr></table></figure><h1 id="argparse"><a href="#argparse" class="headerlink" title="argparse"></a>argparse</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1引入模块</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2建立解析对象</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3增加属性：给xx实例增加一个aa属性 # xx.add_argument(&quot;aa&quot;)</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;role&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;Role of this trainer in &#123;&#x27;local&#x27;, &quot;</span></span><br><span class="line">                             <span class="string">&quot;&#x27;leader&#x27;, &#x27;follower&#x27;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4属性给与args实例： 把parser中设置的所有&quot;add_argument&quot;给返回到args子类实例当中， 那么parser中增加的属性内容都会在args实例中，使用即可。</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">parser.parse_args()</span><br></pre></td></tr></table></figure><p>运行时使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py --role=&#x27;leader&#x27;</span><br></pre></td></tr></table></figure><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><p>类： 大驼峰<br>方法：小驼峰<br>变量：小写字母+下划线<br>常量：大写字母+下划线</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><blockquote><p>内部函数调用外部变量的行为叫做闭包</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">name</span>):</span> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">   <span class="keyword">return</span> func2()</span><br></pre></td></tr></table></figure><h1 id="dict排序"><a href="#dict排序" class="headerlink" title="dict排序"></a>dict排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;d1&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;d2&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;d4&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;d3&#x27;</span>:<span class="number">3</span>,&#125;</span><br><span class="line">res = <span class="built_in">sorted</span>(d.items(),key=<span class="keyword">lambda</span> d:d[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h1 id="python的u-r-b分别什么意思"><a href="#python的u-r-b分别什么意思" class="headerlink" title="python的u,r,b分别什么意思"></a>python的u,r,b分别什么意思</h1><p> u: 表示unicode字符串，默认模式，里边的特殊字符会被识别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(u&#x27;hi\thi\thi&#x27;)</span><br></pre></td></tr></table></figure><p>执行之后：<br><strong>hi hi hi</strong></p><p> b: 表示二进制字符串，括号内的内容原样输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(b&#x27;hi\thi\thi&#x27;)</span><br></pre></td></tr></table></figure><p>执行之后：<br><strong>b’hi\thi\thi’</strong></p><p> r：不转义字符串，要输出的内容原样输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(r&#x27;hi\thi\thi&#x27;)</span><br></pre></td></tr></table></figure><p>执行之后：<br><strong>hi\thi\thi</strong></p><h1 id="dic快速保存和读取"><a href="#dic快速保存和读取" class="headerlink" title="dic快速保存和读取"></a>dic快速保存和读取</h1><blockquote><pre><code>   #保存   dict_name = &#123;1:&#123;1:2,3:4&#125;,2:&#123;3:4,4:5&#125;&#125;   f = open(&#39;temp.txt&#39;,&#39;w&#39;)   f.write(str(dict_name))   f.close()   #读取   f = open(&#39;temp.txt&#39;,&#39;r&#39;)   a = f.read()   dict_name = eval(a)</code></pre></blockquote><h1 id="如果不存在则创建文件"><a href="#如果不存在则创建文件" class="headerlink" title="如果不存在则创建文件"></a>如果不存在则创建文件</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filename):</span><br><span class="line">    os.system(<span class="string">r&quot;touch &#123;&#125;&quot;</span>.<span class="built_in">format</span>(path))<span class="comment">#调用系统命令行来创建文件</span></span><br></pre></td></tr></table></figure><h1 id="获取当前路径"><a href="#获取当前路径" class="headerlink" title="获取当前路径"></a>获取当前路径</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.path.append(os.getcwd()) #添加当前文件夹路径</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span> (sys.argv[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(os.getcwd())</span><br></pre></td></tr></table></figure><h1 id="utf-8编码"><a href="#utf-8编码" class="headerlink" title="utf-8编码"></a>utf-8编码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> sys.getdefaultencoding() != <span class="string">&#x27;utf-8&#x27;</span>:</span><br><span class="line">    reload(sys)</span><br><span class="line">    sys.setdefaultencoding(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = pandas.read_table(filename,sep=<span class="string">&#x27;\t&#x27;</span>) <span class="comment">#dataframe</span></span><br><span class="line">data.to_csv(filename,sep=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data=np.loadtxt(filename,delimiter=<span class="string">&#x27;\t&#x27;</span>) <span class="comment">#narray</span></span><br><span class="line">np.save(filename,narray)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;r&#x27;</span>.encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f: <span class="comment">#list</span></span><br><span class="line">lines=f.readlines()</span><br></pre></td></tr></table></figure><h1 id="产生随机矩阵"><a href="#产生随机矩阵" class="headerlink" title="产生随机矩阵"></a>产生随机矩阵</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df=pd.DataFrame(np.random.randn(<span class="number">4</span>,<span class="number">4</span>),columns=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>])</span><br></pre></td></tr></table></figure><h1 id="提取年月日"><a href="#提取年月日" class="headerlink" title="提取年月日"></a>提取年月日</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">&#x27;2019-01-01 12:00:00&#x27;</span>,<span class="string">&#x27;2019-02-01 12:00:00&#x27;</span>]</span><br><span class="line">a.apply(<span class="keyword">lambda</span> x:x[<span class="number">0</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure><h1 id="百分位数"><a href="#百分位数" class="headerlink" title="百分位数"></a>百分位数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dataframe</span></span><br><span class="line">feat_res[<span class="string">&#x27;f_p75&#x27;</span>] = X[X[feat] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>][feat].quantile(<span class="number">0.75</span>)</span><br></pre></td></tr></table></figure><h1 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">time_start=time.time()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">time_end=time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;totally cost &#123;:.3f&#125; s&#x27;</span>.<span class="built_in">format</span>(time_end-time_start))</span><br></pre></td></tr></table></figure><h1 id="python调用shell"><a href="#python调用shell" class="headerlink" title="python调用shell"></a>python调用shell</h1><blockquote><p>os.system(command) </p></blockquote><p>  此函数会启动子进程，在子进程中执行command，并返回command命令执行完毕后的退出状态，如果command有执行内容，会在标准输出显示。这实际上是使用C标准库函数system()实现的。</p><p>​    缺点：这个函数在执行command命令时需要重新打开一个终端，并且无法保存command命令的执行结果。</p><blockquote><p>os.popen(command,mode)</p></blockquote><p>打开一个与command进程之间的管道。这个函数的返回值是一个文件对象，可以读或者写(由mode决定，mode默认是’r’)。如果mode为’r’，可以使用此函数的返回值调用read()来获取command命令的执行结果。</p><p>os.system(cmd)或os.popen(cmd)，前者返回值是脚本的退出状态码，后者的返回值是脚本执行过程中的输出内容。实际使用时视需求情况而选择。</p><h1 id="XGB-相关"><a href="#XGB-相关" class="headerlink" title="XGB 相关"></a>XGB 相关</h1><h2 id="xgboost-sklearn-XGBClassifier"><a href="#xgboost-sklearn-XGBClassifier" class="headerlink" title="xgboost.sklearn.XGBClassifier"></a>xgboost.sklearn.XGBClassifier</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xgboost.sklearn <span class="keyword">import</span> XGBClassifier</span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">watchlist = [(x_train, y_train), (x_test, y_test)]  <span class="comment"># [(test[res_train],y_test)]</span></span><br><span class="line">model = XGBClassifier(**params)</span><br><span class="line">model.fit(x_train, y_train, eval_set=watchlist)  </span><br><span class="line">    </span><br><span class="line"><span class="comment"># feature importance</span></span><br><span class="line">importance = model.get_booster().get_fscore()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型预测</span></span><br><span class="line"> y_test_pro = model.predict_proba(x_test)[:,<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 模型保存</span></span><br><span class="line"><span class="comment">#法一</span></span><br><span class="line">model.get_booster().dump_model(<span class="string">&#x27;xgb.dump&#x27;</span>) <span class="comment">#该方法储存的是raw text文件，不能用于load_model，用于直观解释模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#法二</span></span><br><span class="line">model.save_model(<span class="string">&#x27;xgb.dump&#x27;</span>) <span class="comment">#该同法一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#法三 推荐方法</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">pickle.dump(model, <span class="built_in">open</span>(<span class="string">&quot;pima.pickle.dat&quot;</span>, <span class="string">&quot;wb&quot;</span>)) <span class="comment">#该方法储存的是二进制文件，可以load_model</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#load model</span></span><br><span class="line"><span class="comment">#法一</span></span><br><span class="line">clf = XGBClassifier()</span><br><span class="line">booster = Booster()</span><br><span class="line">booster.load_model(<span class="string">&#x27;./model.xgb&#x27;</span>)</span><br><span class="line">clf._Booster = booster</span><br><span class="line"></span><br><span class="line"><span class="comment">#法二</span></span><br><span class="line">clf.predict(...)</span><br><span class="line">loaded_model = pickle.load(<span class="built_in">open</span>(<span class="string">&quot;pima.pickle.dat&quot;</span>, <span class="string">&quot;rb&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="哈哈"><a href="#哈哈" class="headerlink" title="哈哈"></a>哈哈</h2><h1 id="dataframe-转为-DMATRIX"><a href="#dataframe-转为-DMATRIX" class="headerlink" title="dataframe 转为 DMATRIX"></a>dataframe 转为 DMATRIX</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dtrain = xgb.DMatrix(df_train[col_feat], label=df_train[&#x27;y&#x27;])</span><br></pre></td></tr></table></figure><h1 id="获取叶子节点"><a href="#获取叶子节点" class="headerlink" title="获取叶子节点"></a>获取叶子节点</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loaded_model = pickle.load(<span class="built_in">open</span>(f_xgb_model+<span class="string">&#x27;.pickle&#x27;</span>, <span class="string">&quot;rb&quot;</span>))</span><br><span class="line">dtrain = xgb.DMatrix(df_train[col_feat], label=df_train[<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">y=loaded_model.get_booster().predict(dtrain,pred_leaf=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h1 id="装饰器-decorator"><a href="#装饰器-decorator" class="headerlink" title="装饰器(decorator)"></a>装饰器(decorator)</h1><p><a href="https://www.cnblogs.com/wolf-yasen/p/11240500.html">https://www.cnblogs.com/wolf-yasen/p/11240500.html</a></p><blockquote><p>本质上，decorator就是一个返回函数的高阶函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@c</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#相当于执行了  f = a(b(c(f)))</span></span><br><span class="line"><span class="comment">#调用f的时候，实际上调用的是a(b(c(f)))</span></span><br></pre></td></tr></table></figure><p>装饰器（decorator）可以给函数动态加上功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        start = time.clock()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;this is a order test, if you need not it, delete it&quot;</span>) <span class="comment"># 用于测试执行顺序,可以跟着走一遍</span></span><br><span class="line">        end = time.clock()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;start:&quot;</span>, start, <span class="string">&quot; end:&quot;</span>, end)</span><br><span class="line">        <span class="keyword">return</span> func <span class="comment"># 这种获得返回值的方法可能在多层修饰器的时候有矛盾,我先用!!!标记, 等理顺后再回来修改,如果我发布之后这里依然存在...说明我忘记了...</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;this is a test&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;this is a return value&quot;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#相当于执行了 foo = log(foo)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(foo())</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># this is a test wrapper, if you need not it, delete it</span></span><br><span class="line"><span class="comment"># this is a test</span></span><br><span class="line"><span class="comment"># start: 4.44444839506524e-07  end: 1.8222238419767486e-05</span></span><br><span class="line"><span class="comment"># this is a return value</span></span><br></pre></td></tr></table></figure><p><img src="/Users/hetianqi/Documents/charging/notes_of_the_world/python.assets/image-20200409175624696.png" alt="image-20200409175624696"></p><h2 id="property修饰器"><a href="#property修饰器" class="headerlink" title="@property修饰器"></a>@property修饰器</h2><p>把一个getter方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个setter方法变成属性赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>(<span class="params"><span class="built_in">object</span></span>):</span>  </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">width</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.W</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @width.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">width</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.W = value </span><br><span class="line">  <span class="comment"># 测试:</span></span><br><span class="line">s = Screen()</span><br><span class="line">s.width=<span class="number">10</span> </span><br><span class="line">s.width</span><br></pre></td></tr></table></figure><p>代码也可改为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>(<span class="params"><span class="built_in">object</span></span>):</span>  </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">width</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._width</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @width.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">width</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self._width = value </span><br><span class="line">  <span class="comment"># 测试:</span></span><br><span class="line">s = Screen()</span><br><span class="line">s.width=<span class="number">10</span> </span><br><span class="line">s.width</span><br></pre></td></tr></table></figure><h1 id="python变量中的下划线"><a href="#python变量中的下划线" class="headerlink" title="python变量中的下划线"></a>python变量中的下划线</h1><ul><li>xx: 公有变量</li><li>_x: 单前置下划线,私有化属性或方法，from somemodule import *禁止导入,类对象和子类可以访问</li><li>__xx：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)</li><li><strong>xx</strong>:双前后下划线,用户名字空间的魔法对象或属性。例如:<strong>init</strong> , __ 不要自己发明这样的名字</li><li>xx_:单后置下划线,用于避免与Python关键词的冲突</li></ul><h1 id="生成器（generator）"><a href="#生成器（generator）" class="headerlink" title="生成器（generator）"></a>生成器（generator）</h1><p>如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><blockquote><p>实例：生成斐波那契数列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;# 一般写法</span><br><span class="line">&gt;def fib1(max):</span><br><span class="line">n, a, b = 0,0,1</span><br><span class="line">while n&lt;max:</span><br><span class="line">print(b)</span><br><span class="line">    a,b = b,a+b</span><br><span class="line">    n+=1</span><br><span class="line">return &#x27;done&#x27;</span><br><span class="line">&gt;# 调用</span><br><span class="line">&gt;fib1(6)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment"># 生成器写法</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">def</span> <span class="title">fib2</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">   n, a, b = <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">   <span class="keyword">while</span> n&lt;<span class="built_in">max</span>:</span><br><span class="line">       <span class="keyword">yield</span> b</span><br><span class="line">       a,b = b,a+b</span><br><span class="line">       n+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">&gt;<span class="keyword">for</span> i <span class="keyword">in</span> fib2(<span class="number">6</span>):</span><br><span class="line">     <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure></blockquote><h1 id="迭代器（iterable）"><a href="#迭代器（iterable）" class="headerlink" title="迭代器（iterable）"></a>迭代器（iterable）</h1><p>我们已经知道，可以直接作用于<code>for</code>循环的数据类型有以下几种：</p><p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p><p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p><p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from collections.abc import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterable)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from collections.abc import Iterator</span><br><span class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p><p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isinstance(iter([]), Iterator)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p><p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p><p>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p><p>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for x in [1, 2, 3, 4, 5]:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>实际上完全等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 首先获得Iterator对象:</span><br><span class="line">it = iter([1, 2, 3, 4, 5])</span><br><span class="line"># 循环:</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        # 获得下一个值:</span><br><span class="line">        x = next(it)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        # 遇到StopIteration就退出循环</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;快速安装python依赖包&quot;&gt;&lt;a href=&quot;#快速安装python依赖包&quot; class=&quot;headerlink&quot; title=&quot;快速安装python依赖包&quot;&gt;&lt;/a&gt;快速安装python依赖包&lt;/h1&gt;&lt;figure class=&quot;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/04/30/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/xgboost%E5%8C%85/"/>
    <id>http://wangdongdong122.github.io/2021/04/30/0_代码相关/xgboost包/</id>
    <published>2021-04-30T07:00:52.000Z</published>
    <updated>2021-04-30T07:00:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="模型的保存与restore"><a href="#模型的保存与restore" class="headerlink" title="模型的保存与restore"></a>模型的保存与restore</h1><p>常用的模型文件有dump, pickle,model三种格式，其中dump文件是可读文件，pickle和model文件是二进制文件。model文件是xgb官方支持的文件，适合所有版本，pickle文件使用第三方pickle包进行序列化。</p><p>xgb接口有xgboost.Booster()和xgboost.sklearn.XGBClassifier两个接口，xgboost.Booster()只能使用DMatrix形式数据进行训练，dmatrix数据可通过csv,txt,libsvm,dataframe得到，见<a href="https://xgboost.readthedocs.io/en/latest/python/python_intro.html">https://xgboost.readthedocs.io/en/latest/python/python_intro.html</a></p><p>XGBClassifier可使用Grid Search 和并行处理</p><p><img src="./pics/xgboost包.assets/image-20201026101441254.png" alt="image-20201026101441254"></p><p>xgboost.sklearn.XGBClassifier可直接读dataframe数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xgboost.Booster()版本模型restore和预测</span></span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line">dtrain = xgb.DMatrix(x,label=df[<span class="string">&#x27;y_flag&#x27;</span>],feature_names=df.columns[<span class="number">2</span>:]) <span class="comment">#x: dataframe;feature_names可指定特征名，取决于训练时是否有特征名</span></span><br><span class="line">m1 = xgb.Booster(model_file=<span class="string">&#x27;test.model&#x27;</span>) </span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">m1 = xgb.Booster()</span><br><span class="line">m1.load_model(f_model)</span><br><span class="line">score = m1.predict(dtrain)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xgboost.sklearn.XGBClassifier版本restore和预测</span></span><br><span class="line">m2 = XGBClassifier()</span><br><span class="line">m2.load_model(f_model)  </span><br><span class="line">a = m2.predict_proba(x)[:,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="模型的训练与保存"><a href="#模型的训练与保存" class="headerlink" title="模型的训练与保存"></a>模型的训练与保存</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># XGBClassifier 版本</span></span><br><span class="line"><span class="keyword">from</span> xgboost.sklearn <span class="keyword">import</span> XGBClassifier</span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">model=XGBClassifier(params) <span class="comment">#params：dict,模型参数</span></span><br><span class="line">watchlist=[(x_train, y_train), (x_test, y_test)]</span><br><span class="line">model.fit(x,y, eval_set=watchlist)</span><br><span class="line"><span class="comment">#模型保存</span></span><br><span class="line">model.get_booster().dump_model(f_model + <span class="string">&#x27;.dump&#x27;</span>) <span class="comment">#可读文件</span></span><br><span class="line">model.get_booster().save_model(f_model + <span class="string">&#x27;.model&#x27;</span>) <span class="comment">#model二进制文件</span></span><br><span class="line">pickle.dump(model, <span class="built_in">open</span>(f_model + <span class="string">&#x27;.pickle.dat&#x27;</span>, <span class="string">&quot;wb&quot;</span>)) <span class="comment">#pickl二进制文件</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xgboost.Booster 版本</span></span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line">model = xgb.train(param, dtrain, num_round)  <span class="comment"># dtrain是训练数据集</span></span><br><span class="line">scores = bst.predict(dtrain)    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;模型的保存与restore&quot;&gt;&lt;a href=&quot;#模型的保存与restore&quot; class=&quot;headerlink&quot; title=&quot;模型的保存与restore&quot;&gt;&lt;/a&gt;模型的保存与restore&lt;/h1&gt;&lt;p&gt;常用的模型文件有dump,
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/04/30/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/XGB/"/>
    <id>http://wangdongdong122.github.io/2021/04/30/0_代码相关/XGB/</id>
    <published>2021-04-30T06:58:58.000Z</published>
    <updated>2021-04-30T06:58:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xgboost-sklearn-XGBClassifier"><a href="#xgboost-sklearn-XGBClassifier" class="headerlink" title="xgboost.sklearn.XGBClassifier"></a>xgboost.sklearn.XGBClassifier</h1><h2 id="f-score"><a href="#f-score" class="headerlink" title="f_score"></a>f_score</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xgboost.sklearn <span class="keyword">import</span> XGBClassifier</span><br><span class="line"></span><br><span class="line">model = XGBClassifier(**params)</span><br><span class="line">model.fit(x_train, y_train, eval_set=watchlist,  <span class="comment"># 训练模型</span></span><br><span class="line">          eval_metric=<span class="string">&quot;logloss&quot;</span>,</span><br><span class="line">          early_stopping_rounds=<span class="number">30</span>,</span><br><span class="line">          verbose=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># feature importance 方法一</span></span><br><span class="line">importance =model.get_booster().get_fscore()  <span class="comment">#返回字典</span></span><br></pre></td></tr></table></figure><p>结果（特征分叉次数）：</p><p><img src="./pics/XGB.assets/1565232108098.png" alt="1565232108098"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impo=model.feature_importances_ <span class="comment">#返回array</span></span><br></pre></td></tr></table></figure><p>结果（特征分叉次数占比）：</p><p><img src="./pics/XGB.assets/1565232794674.png" alt="1565232794674"></p><h1 id="xgboost"><a href="#xgboost" class="headerlink" title="xgboost"></a>xgboost</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line">xgb_model = xgb.train (params, dtrain, num_boost_round, evals=watchlist, early_stopping_rounds=early_stopping_rounds, verbose_eval=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># feature importance</span></span><br><span class="line">importance =xgb_model.get_fscore() <span class="comment">#返回字典</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="./pics/XGB.assets/1565232255682.png" alt="1565232255682"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xgboost-sklearn-XGBClassifier&quot;&gt;&lt;a href=&quot;#xgboost-sklearn-XGBClassifier&quot; class=&quot;headerlink&quot; title=&quot;xgboost.sklearn.XGBClassifier&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/04/21/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/%E4%BD%9C%E4%B8%9A%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E9%81%93%E6%A2%B3%E7%90%86/"/>
    <id>http://wangdongdong122.github.io/2021/04/21/0_代码相关/作业，进程，线程管道梳理/</id>
    <published>2021-04-21T07:28:46.000Z</published>
    <updated>2021-04-21T07:28:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>作业，进程，线程，管程，管道梳理</p><p>[TOC]</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>进程（process）：程序在一个数据集上的一次运行过程。是操作系统资源分配的基本单位。</p><p> 线程（thread）：是进程中的一个实体，是被操作系统独立调度和执行的基本单位。一个进程包含一个或多个线程。</p><blockquote><p>多线程间是共用内存空间的，但有的内存只能同时被一个线程访问，有的内存只能同时被有限个线程访问。所以每个内存会有一个锁，当超额的线程访问此内存时就需要排队。当一个线程长时间占用内存时就会导致“锁死”</p></blockquote><p><img src=".\pics\作业，进程，线程管道梳理.assets\image-20200331114405031.png" alt="image-20200331114405031"></p><h1 id="shell中多进程管理"><a href="#shell中多进程管理" class="headerlink" title="shell中多进程管理"></a>shell中多进程管理</h1><h1 id="python中多进程管理"><a href="#python中多进程管理" class="headerlink" title="python中多进程管理"></a>python中多进程管理</h1><ul><li>单进程：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前进程: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(os.getpid()))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结果: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span> ** <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前母进程: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        long_time_task()</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;用时&#123;&#125;秒&quot;</span>.<span class="built_in">format</span>((end-start)))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当前母进程: 14236</span><br><span class="line">当前进程: 14236</span><br><span class="line">结果: 1152921504606846976</span><br><span class="line">当前进程: 14236</span><br><span class="line">结果: 1152921504606846976</span><br><span class="line">用时4.01080060005188秒</span><br></pre></td></tr></table></figure><ul><li>多进程后：</li></ul><p>Process方法接收两个参数, 第一个是target，一般指向函数名，第二个时args，需要向函数传递的参数。对于创建的新进程，调用start()方法即可让其开始。我们可以使用os.getpid()打印出当前进程的名字。之所以我们使用join()方法就是为了让母进程阻塞，等待子进程都完成后才打印出总共耗时，否则输出时间只是母进程执行的时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程: &#123;&#125; - 任务&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(os.getpid(), i))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结果: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">8</span> ** <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前母进程: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    p1 = Process(target=long_time_task, args=(<span class="number">1</span>,))</span><br><span class="line">    p2 = Process(target=long_time_task, args=(<span class="number">2</span>,))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;等待所有子进程完成。&#x27;</span>)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;总共用时&#123;&#125;秒&quot;</span>.<span class="built_in">format</span>((end - start)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前母进程: 6920</span><br><span class="line">等待所有子进程完成。</span><br><span class="line">子进程: 17020 - 任务1</span><br><span class="line">子进程: 5904 - 任务2</span><br><span class="line">结果: 1152921504606846976</span><br><span class="line">结果: 1152921504606846976</span><br><span class="line">总共用时2.131091356277466秒</span><br></pre></td></tr></table></figure><h1 id="python调用shell的方法"><a href="#python调用shell的方法" class="headerlink" title="python调用shell的方法"></a>python调用shell的方法</h1><h2 id="os-system（cmd）"><a href="#os-system（cmd）" class="headerlink" title="os.system（cmd）"></a>os.system（cmd）</h2><p>返回值：shell运行指令后的状态码，int，0表示运行成功，256表示未找到。<strong>适用于shell不需要输出内容的场景</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">val = os.system(<span class="string">&#x27;ls -al&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;val&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="os-popen"><a href="#os-popen" class="headerlink" title="os.popen()"></a>os.popen()</h2><p>返回值：文件的形式返回shell指令运行后的结果，需要获取内容时可使用read()或readlines（）方法</p><h2 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h2><h2 id="subprocess"><a href="#subprocess" class="headerlink" title="subprocess"></a>subprocess</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作业，进程，线程，管程，管道梳理&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h1&gt;&lt;p&gt;进程（process）：程序在一个数据集上的一次运
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/04/21/2_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <id>http://wangdongdong122.github.io/2021/04/21/2_算法相关/机器学习基础/</id>
    <published>2021-04-21T07:22:00.000Z</published>
    <updated>2021-04-21T07:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Woe"><a href="#Woe" class="headerlink" title="Woe"></a>Woe</h1><p>WOE的全称是“weight of evidence”，即证据权重, WOE表示的含义即是”<strong>当前分组中响应客户占所有响应客户的比例”和”当前分组中没有响应的客户占所有没有响应客户的比例</strong>“的差异。先把分析变量进行分箱，每个分箱内的$w_{oe}$为</p><script type="math/tex; mode=display">woe_i=\frac{当前分组中响应客户占所有响应客户的比例}{当前分组中没有响应的客户占所有没有响应客户的比例}=ln\frac{P_{y_i}}{P_{n_i}}=ln\frac{y_1/y_2}{n_i/n_s}</script><script type="math/tex; mode=display">woe_i=\frac{sum(y_i)/sum(y_s)}{sum(1-y_i)/sum(1-y_s)}</script><p>该值绝对值越大说明变量区分能力越强</p><h1 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h1><p>IV衡量的是某一个变量的信息量，从公式来看的话，相当于是自变量WOE值的一个加权求和，其值的大小决定了自变量对于目标变量的影响程度</p><script type="math/tex; mode=display">IV_i=(P_{y_i}-P_{n_i})*woe_i</script><p>WOE 和 IV 都能表达某个分组对目标变量的预测能力。但实际中，我们通常选择 IV 而不是 WOE 的和来衡量变量预测的能力，这是为什么呢？首先，因为我们在衡量一个变量的预测能力时，我们所使用的指标值不应该是负数。从这意义上来说，IV 比 WOE 多乘以前面那个因子，就保证了它不会是负数；然后，乘以(Pyi−Pni)这个因子，体现出了变量当前分组中个体的数量占整体的比例，从而很好考虑了这个分组中样本占整体的比例，比例越低，这个分组对变量整体预测能力的贡献越低。相反，如果直接用 WOE 的绝对值加和，会因为该分组出现次数偏少的影响而得到一个很高的指标。</p><h1 id="AUC-amp-KS"><a href="#AUC-amp-KS" class="headerlink" title="AUC &amp; KS"></a>AUC &amp; KS</h1><h1 id="信息熵（information-entropy）"><a href="#信息熵（information-entropy）" class="headerlink" title="信息熵（information entropy）"></a>信息熵（information entropy）</h1><p>衡量样本纯度，熵越小越纯,样本D有K类样本，其信息熵为</p><script type="math/tex; mode=display">Ent(D)=-\sum_{k=1}^{K}p_klog_2p_k</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Woe&quot;&gt;&lt;a href=&quot;#Woe&quot; class=&quot;headerlink&quot; title=&quot;Woe&quot;&gt;&lt;/a&gt;Woe&lt;/h1&gt;&lt;p&gt;WOE的全称是“weight of evidence”，即证据权重, WOE表示的含义即是”&lt;strong
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/03/25/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/git%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/"/>
    <id>http://wangdongdong122.github.io/2021/03/25/0_代码相关/git基础操作笔记/</id>
    <published>2021-03-25T07:11:32.000Z</published>
    <updated>2022-01-16T07:21:39.088Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="merge时产生冲突"><a href="#merge时产生冲突" class="headerlink" title="merge时产生冲突"></a>merge时产生冲突</h1><p><img src="/Users/hetianqi/Documents/charging/notes_of_the_world/git基础操作笔记.assets/image-20210202171431394.png" alt="image-20210202171431394"></p><h1 id="git删除远程文件或者文件夹"><a href="#git删除远程文件或者文件夹" class="headerlink" title="git删除远程文件或者文件夹"></a>git删除远程文件或者文件夹</h1><p>git删除远程文件夹或文件的方法</p><p><a href="https://www.cnblogs.com/xusir/p/4111723.html">https://www.cnblogs.com/xusir/p/4111723.html</a></p><p>由于本地修改了文件夹大全名大小写的原因，同步到git上并不区分大小写，造成了一些文件同步不了，所以要先把git远程库上文件夹删除掉，然后再重新同步</p><p>如下，我把src里的全部移除，但是本地文件还保留。</p><p>git rm -r -n —cached  <em>/src/\</em>      //-n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。</p><p>git rm -r —cached  <em>/src/\</em>      //最终执行命令. </p><p>git commit -m”移除src目录下所有文件的版本控制”    //提交 </p><p>git push origin master   //提交到远程服务器</p><p>若用git status命令查看，则/src/目录下文件出现在结果列表里， 我们不希望这个目录下的文件出现，则在项目根目录下，和.git 同级目录下，新建一个.gitignore文件，</p><p>把.gitignore提交到远程服务器。 则/src目录就不会被提交了。</p><h1 id="git基础操作"><a href="#git基础操作" class="headerlink" title="git基础操作"></a>git基础操作</h1><p><img src="git基础操作笔记.assets\1541381811863.png" alt="1541381811863"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git init #在现有目录中初始化仓库</span><br><span class="line">git diff #查看已暂存和未暂存的修改</span><br><span class="line">git log #查看提交历史</span><br><span class="line">git reset HEAD [file] #取消暂存的文件</span><br><span class="line">git checkout --[file] #撤消对文件的修改</span><br><span class="line">git branch testing #建立分支</span><br><span class="line">git checkout testing #切换分支</span><br><span class="line">git merge #分支合并</span><br><span class="line">git remote #查看远程仓库名称</span><br><span class="line">git branch -r #查看远程分支的名称</span><br></pre></td></tr></table></figure><h2 id="crontab同步git仓库"><a href="#crontab同步git仓库" class="headerlink" title="crontab同步git仓库"></a>crontab同步git仓库</h2><p>添加远程仓库的时候使用https,并加入用户名、密码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin http://hetianqi:htq0625HTQ%24@git.jd.com/jd_git/monitors.git</span><br></pre></td></tr></table></figure></p><h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 忽略子目录</span><br><span class="line">**/log/*</span><br><span class="line"></span><br><span class="line"># 忽略*.o和*.a文件</span><br><span class="line">*.[oa] </span><br><span class="line"></span><br><span class="line"># 忽略*.b和*.B文件，my.b除外</span><br><span class="line">*.[bB]</span><br><span class="line">!my.b</span><br><span class="line"></span><br><span class="line"># 忽略dbg文件和dbg目录(只要)</span><br><span class="line">dbg</span><br><span class="line"></span><br><span class="line"># 只忽略dbg目录，不忽略dbg文件</span><br><span class="line">dbg/</span><br><span class="line"></span><br><span class="line"># 只忽略dbg文件，不忽略dbg目录</span><br><span class="line">dbg</span><br><span class="line">!dbg/</span><br><span class="line"></span><br><span class="line"># 只忽略当前目录下的dbg文件和目录，子目录的dbg不在忽略范围内</span><br><span class="line"></span><br><span class="line">/dbg</span><br><span class="line"></span><br><span class="line"># 以&#x27;#&#x27;开始的行，被视为注释.</span><br><span class="line"></span><br><span class="line"> * ？：代表任意的一个字符</span><br><span class="line">    * ＊：代表任意数目的字符</span><br><span class="line">    * &#123;!ab&#125;：必须不是此类型</span><br><span class="line">    * &#123;ab,bb,cx&#125;：代表ab,bb,cx中任一类型即可</span><br><span class="line">    * [abc]：代表a,b,c中任一字符即可</span><br><span class="line">    * [ ^abc]：代表必须不是a,b,c中任一字符</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mac配置全局gitignore</span></span><br><span class="line">git config --global core.excludesfile ~/.gitignore_global</span><br><span class="line"></span><br><span class="line">vim ~/.gitignore_global</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> Mac OS X System Files</span></span><br><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> emacs</span></span><br><span class="line">*~</span><br><span class="line"><span class="meta">[#</span><span class="bash">]*[<span class="comment">#]</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> Eclipse</span></span><br><span class="line">*.project</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> Logs and databases</span></span><br><span class="line">*.log</span><br><span class="line">*.dat</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> remove SVN</span></span><br><span class="line">.svn</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> Xcode</span></span><br><span class="line">.*.swp</span><br><span class="line">.clang_complete</span><br><span class="line">*.xcodeproj/project.xcworkspace/</span><br><span class="line">*.xcodeproj/xcuserdata/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> IDEA</span></span><br><span class="line">**/build/*</span><br><span class="line">.idea/*</span><br><span class="line">*.iml</span><br><span class="line">**/out/*</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> PYCHARM</span></span><br><span class="line">**/__pycache__/*</span><br><span class="line">**/.ipynb_checkpoints/*</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="fetch-和-pull的区别"><a href="#fetch-和-pull的区别" class="headerlink" title="fetch 和 pull的区别"></a>fetch 和 pull的区别</h2><p><a href="https://www.cnblogs.com/runnerjack/p/9342362.html">https://www.cnblogs.com/runnerjack/p/9342362.html</a><br>git fetch 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;远程主机名&gt; //这个命令将某个远程主机的更新全部取回本地</span></span><br><span class="line">如果只想取回特定分支的更新，可以指定分支名：</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;远程主机名&gt; &lt;分支名&gt; //注意之间有空格</span></span><br><span class="line">最常见的命令如取回origin 主机的master 分支：</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master</span></span><br><span class="line">取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息：</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p FETCH_HEAD</span></span><br><span class="line">前面提到，git pull 的过程可以理解为：</span><br><span class="line"></span><br><span class="line">git fetch origin master //从远程主机的master分支拉取最新内容 </span><br><span class="line">git merge FETCH_HEAD    //将拉取下来的最新内容合并到当前所在的分支中</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">即将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为：</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br><span class="line">如果远程分支是与当前分支合并，则冒号后面的部分可以省略：</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull origin next</span></span><br></pre></td></tr></table></figure></p><h2 id="按后缀添加文件"><a href="#按后缀添加文件" class="headerlink" title="按后缀添加文件"></a>按后缀添加文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">find . -name &#x27;*.py&#x27; -exec git add &#123;&#125; \;</span><br><span class="line">find . -name &#x27;*.sh&#x27; -exec git add &#123;&#125; \;</span><br><span class="line">find . -name &#x27;*.sql&#x27; -exec git add &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">find . -name &#x27;*.dump&#x27; -exec git add &#123;&#125; \;</span><br><span class="line">find . -name &#x27;*.ipynb&#x27; -exec git add &#123;&#125; \;</span><br><span class="line">find . -name &#x27;*.model&#x27; -exec git add &#123;&#125; \;</span><br><span class="line">find . -name &#x27;*.model&#x27; -exec git checkout &#123;&#125; </span><br><span class="line"></span><br><span class="line">find . -name &#x27;*.model&#x27; -exec git add &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find ./ -regex .*transform_5k/.*meta -exec git add &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find /notebook/rta_cvr_git/3_tfModels/application/MMOE/transform_5k/ -name &#x27;*&#x27; -exec git add &#123;&#125; \;</span><br></pre></td></tr></table></figure><h2 id="git切换关联的远程仓库"><a href="#git切换关联的远程仓库" class="headerlink" title="git切换关联的远程仓库"></a>git切换关联的远程仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 先删除关联</span><br><span class="line">git remote rm origin</span><br><span class="line">// 再关联新的地址</span><br><span class="line">git remote add origin XXXXXXXXXXXXX</span><br></pre></td></tr></table></figure><h2 id="删除某些已经存在的索引及文件"><a href="#删除某些已经存在的索引及文件" class="headerlink" title="删除某些已经存在的索引及文件"></a>删除某些已经存在的索引及文件</h2><p>原理：对所有文件的commit log进行重写，排除掉某些文件即可。<br>命令如下：</p><ol><li>删除远程和本地索引</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --tree-filter &#x27;rm -rf */.ipynb_checkpoints/*&#x27; HEAD</span><br></pre></td></tr></table></figure><p>当然，如果你还需要push到远端，就</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin master  --force #也可以是别的分支</span><br></pre></td></tr></table></figure><ol><li>删除远程文件：IDE里直接删除并commit</li><li>pull</li></ol><p>注意</p><p>1、其他分支也需要删除commit索引</p><h2 id="强制覆盖本地的代码"><a href="#强制覆盖本地的代码" class="headerlink" title="强制覆盖本地的代码"></a>强制覆盖本地的代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line"><span class="meta">#</span><span class="bash">然后，你有两个选择：</span></span><br><span class="line">git reset --hard origin/master</span><br><span class="line"><span class="meta">#</span><span class="bash">或者如果你在其他分支上：</span></span><br><span class="line">git reset --hard origin/&lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line">git pull</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">说明：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">git fetch从远程下载最新的，而不尝试合并或rebase任何东西。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">然后git reset将主分支重置为您刚刚获取的内容。 --hard选项更改工作树中的所有文件以匹配origin/master中的文件。</span></span><br></pre></td></tr></table></figure><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>  git push的一般形式为 git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt; ，例如 git push origin master：refs/for/master ，即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名， 第一个master是本地分支名，第二个master是远程分支名。</p><p><strong>Git push</strong></p><p>​        在使用git commit命令将修改从暂存区提交到本地版本库后，只剩下最后一步将本地版本库的分支推送到远程服务器上对应的分支了，如果不清楚版本库的构成，可以查看我的另一篇，git 仓库的基本结构。</p><p>​    git push的一般形式为 git push &lt;远程主机名&gt; &lt;本地分支名&gt;  &lt;远程分支名&gt; ，例如 git push origin master：refs/for/master ，即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名，</p><p>​    第一个master是本地分支名，第二个master是远程分支名。</p><p>​    <strong>1.1 git push origin master</strong></p><p>​        如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建</p><p>​     <strong>1.2</strong> <strong>git push origin ：refs/for/master</strong> </p><p>　　如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin —delete master</p><p>​    <strong>1.3</strong> <strong>git push origin</strong></p><p>　　 如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支 </p><p>　<strong>1.4 git push</strong></p><p>　　如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名</p><p>　<strong>1.5 git push 的其他命令</strong></p><p>　　这几个常见的用法已足以满足我们日常开发的使用了，还有几个扩展的用法，如下：</p><p>　　　　（1） git push -u origin master 如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用git push，</p><p>　　　　　　不带任何参数的git push，默认只推送当前分支，这叫做simple方式，还有一种matching方式，会推送所有有对应的远程分支的本地分支， Git 2.0之前默认使用matching，现在改为simple方式</p><p>　　　　　　如果想更改设置，可以使用git config命令。git config —global push.default matching OR git config —global push.default simple；可以使用git config -l 查看配置</p><p>　　　　（2） git push —all origin 当遇到这种情况就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要 -all 选项</p><p>　　　　（3） git push —force origin git push的时候需要本地先git pull更新到跟服务器版本一致，如果本地版本库比远程服务器上的低，那么一般会提示你git pull更新，如果一定要提交，那么可以使用这个命令。</p><p>　　　　（4） git push origin —tags //git push 的时候不会推送分支，如果一定要推送标签的话那么可以使用这个命令</p><h2 id="本地repository关联到远程"><a href="#本地repository关联到远程" class="headerlink" title="本地repository关联到远程"></a>本地repository关联到远程</h2><h3 id="1-打开在你的项目文件夹，输入下面的命令"><a href="#1-打开在你的项目文件夹，输入下面的命令" class="headerlink" title="1. 打开在你的项目文件夹，输入下面的命令"></a>1. 打开在你的项目文件夹，输入下面的命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><img src="git基础操作笔记.assets\643024-20161117105613529-1331892400.png" alt="img"></p><p> 输完上面的命令，文件夹中会出现一个.git文件夹，如下图所示，其他的的文件也会出现蓝色小问号的标志</p><p> <img src="git基础操作笔记.assets\643024-20161020175232498-1872971817.png" alt="img"></p><h3 id="2-添加所有文件"><a href="#2-添加所有文件" class="headerlink" title="2. 添加所有文件"></a>2. 添加所有文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>注意最后的点是有用的哦</p><p><img src="git基础操作笔记.assets\643024-20161117105642248-437211863.png" alt="img"></p><p> 输入完成后，文件夹如下所示</p><p><img src="git基础操作笔记.assets\643024-20161020175721045-34264600.png" alt="img"></p><h3 id="3-提交所有文件"><a href="#3-提交所有文件" class="headerlink" title="3. 提交所有文件"></a>3. 提交所有文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;这里是备注信息&quot; -a</span><br></pre></td></tr></table></figure><p><img src="git基础操作笔记.assets\643024-20161117105723982-456456864.png" alt="img"></p><p> 完成后，文件夹显示如下</p><p><img src="git基础操作笔记.assets\643024-20161020180119123-417194644.png" alt="img"></p><p>都会出现绿色的小对勾</p><h3 id="4-连接到远程仓库"><a href="#4-连接到远程仓库" class="headerlink" title="4. 连接到远程仓库"></a>4. 连接到远程仓库</h3><p>提前在你的github中新建一个仓库，操作如下</p><p><img src="git基础操作笔记.assets\643024-20161020180953357-871156867.png" alt="img"></p><p>建好后，取好项目名称，点击create repository按钮，完成仓库的建立</p><p><img src="git基础操作笔记.assets\643024-20161020180830388-1568291414.png" alt="img"></p><p><img src="git基础操作笔记.assets\643024-20161026120125703-263387261.png" alt="img"></p><p>点击红色框出的小按钮，复制链接 </p><h3 id="5-连接远程仓库"><a href="#5-连接远程仓库" class="headerlink" title="5. 连接远程仓库"></a>5. 连接远程仓库</h3><p>在本地的命令框中输入下面的命令，即连接到了名为poster的仓库上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/OliveKong/poster.git </span><br></pre></td></tr></table></figure><p> <img src="git基础操作笔记.assets\643024-20161117105800279-1083550297.png" alt="img"></p><h3 id="6-把本地项目推送到远程仓库"><a href="#6-把本地项目推送到远程仓库" class="headerlink" title="6.把本地项目推送到远程仓库"></a>6.把本地项目推送到远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master </span><br></pre></td></tr></table></figure><p><img src="git基础操作笔记.assets\643024-20161117105822107-1011418356.png" alt="img"></p><h2 id="git-ignore"><a href="#git-ignore" class="headerlink" title="git ignore"></a>git ignore</h2><p>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。</p><p>解决方法就是先把本地缓存删除（改变成未track状态），然后再提交:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;update .gitignore&#x27;</span><br></pre></td></tr></table></figure><h1 id="git-工作流程"><a href="#git-工作流程" class="headerlink" title="git 工作流程"></a>git 工作流程</h1><p><a href="https://blog.csdn.net/zyw0713/article/details/80083431">https://blog.csdn.net/zyw0713/article/details/80083431</a></p><h2 id="主master分支"><a href="#主master分支" class="headerlink" title="主master分支"></a>主master分支</h2><h2 id="开发分支develop"><a href="#开发分支develop" class="headerlink" title="开发分支develop"></a>开发分支develop</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Git创建Develop分支的命令</span></span><br><span class="line">git checkout -b develop master  <span class="comment">#相当于 创建新分支：git branch branchName 切换到新分支：git checkout branchName</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将Develop分支发布到Master分支的命令</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff develop</span><br></pre></td></tr></table></figure><p>—no-ff参数：默认情况下，Git执行”快进式合并”，会直接将Master分支指向Develop分支。强推。少用！！</p><h2 id="临时分支（功能feature，预发布release，fixbug）"><a href="#临时分支（功能feature，预发布release，fixbug）" class="headerlink" title="临时分支（功能feature，预发布release，fixbug）"></a>临时分支（功能feature，预发布release，fixbug）</h2><p>前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。</p><p>但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：</p><ul><li><p>功能分支 （feature）</p></li><li><p>预发布分支 (release)</p></li><li><p>修补bug分支 (fixbug)</p></li></ul><p>这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个功能分支</span></span><br><span class="line">git checkout -b feature-x develop</span><br><span class="line"><span class="comment">#合并到develop分支</span></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff feature-x</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除feature分支</span></span><br><span class="line">git branch -d feature-x</span><br></pre></td></tr></table></figure><h2 id="克隆其他分支"><a href="#克隆其他分支" class="headerlink" title="克隆其他分支"></a>克隆其他分支</h2><p>假设要clone dev分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> ........ <span class="comment">#把项目从远程clone到本地，默认clonemaster分支</span></span><br><span class="line">git pull origin dev:dev  <span class="comment">#把远程的dev分支拉到本地的dev分支。冒号前是远程分支名，冒号后是本地分支名</span></span><br></pre></td></tr></table></figure><h1 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h1><p>Added (新加入的需求)</p><p>　　Fixed： (修复bug )</p><p>　　Changed ：(完成的任务)</p><p>　　Updated： (完成的任务，或者由于第三方模块变化而做的变化)</p><p>　　Mod: 修改（Modify）</p><p>　　Add: a new module to have faster process, 表示新增（Add）</p><p>　　Rem: deprecate unused modules, 表示移除（Remove）</p><p>　　Ref: improved the implementation of module X, 表示重构（Refactory）</p><p>假如有 Issues 系统，其中可以包含 Issue 的 ID。比如：Issue #123456</p><h1 id="上传大文件失败"><a href="#上传大文件失败" class="headerlink" title="上传大文件失败"></a>上传大文件失败</h1><p>参考： <a href="https://blog.csdn.net/quiet_girl/article/details/79487966">https://blog.csdn.net/quiet_girl/article/details/79487966</a></p><p>git push 时，存在大文件会报错，即使删除大文件后，还会报错。主要是因为大文件存在没有被提交的commit记录里面。</p><p><strong>解决方案：删除有大文件的commit记录即可</strong></p><p>1、git status 查看未被传送到远程代码库的提交状态</p><p>2、git cherry -v 查看未被传送到远程代码库的提交描述和说明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cc@lcc MyDoc$ git cherry -v </span><br><span class="line">+ 0bd8c12c3b44c5d16ff6e9ce84d00230561b7f12 kafka console消费失败</span><br><span class="line">+ 0f535fa58f413913c2c5ce37b85bf0803ea88f0b kafka console消费失败</span><br><span class="line">+ 3342e8c5db5c8d4533a70c80cf2a480ef0dd94f8 kafka console消费失败</span><br><span class="line">+ de978a99704e1bec6d2e81fcfd24900e6be43d8e kafka console消费失败</span><br><span class="line">+ f96a7d270c8d6a253530309a9f485a8d2a84befe kafka console消费失败</span><br><span class="line">+ 8ebe1f4d47845ddf21e7f14c031e73ec4f786722 drui io</span><br><span class="line">+ f8e4b51169d00242fff77aae182097cecbbff95a drui io</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、git reset commit_id 撤销未被传送到远程代码库的提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里我选择第一个</span><br><span class="line">cc@lcc MyDoc$ git reset 0bd8c12c3b44c5d16ff6e9ce84d00230561b7f12</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>移除大文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lcc@lcc MyDoc$ git rm --cached *.pdf</span><br><span class="line"><span class="comment">#这里我直接移除所有的pdf文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#然后备份这些pdf文件 </span></span><br><span class="line">lcc@lcc MyDoc$ mv ./*/*.pdf ~/Downloads/</span><br></pre></td></tr></table></figure><h2 id="【git】全局配置和单个仓库的用户名邮箱配置"><a href="#【git】全局配置和单个仓库的用户名邮箱配置" class="headerlink" title="【git】全局配置和单个仓库的用户名邮箱配置"></a>【git】全局配置和单个仓库的用户名邮箱配置</h2><p>Git全局配置和单个仓库的用户名邮箱配置</p><p>学习git的时候, 大家刚开始使用之前都配置了一个全局的用户名和邮箱</p><p>$ git config —global user.name “github’s Name”</p><p>$ git config —global user.email “github@xx.com”</p><p>$ git config —list</p><p>如果你公司的项目是放在自建的gitlab上面, 如果你不进行配置用户名和邮箱的话, 则会使用全局的, 这个时候是错误的, 正确的做法是针对公司的项目, 在项目根目录下进行单独配置</p><p>$ git config user.name “gitlab’s Name”</p><p>$ git config user.email “gitlab@xx.com”</p><p>$ git config —list</p><p> git config —list查看当前配置, 在当前项目下面查看的配置是全局配置+当前项目的配置, 使用的时候会优先使用当前项目的配置</p><h1 id="问题集锦"><a href="#问题集锦" class="headerlink" title="问题集锦"></a>问题集锦</h1><h2 id="not-staged"><a href="#not-staged" class="headerlink" title="not staged"></a>not staged</h2><p>解决：如果已add .之后还是报这个问题，就是这几个目录下有git文件（这些git文件没有add）</p><h2 id="Please-commit-your-changes-or-stash-them-before-you-merge"><a href="#Please-commit-your-changes-or-stash-them-before-you-merge" class="headerlink" title="Please commit your changes or stash them before you merge."></a>Please commit your changes or stash them before you merge.</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h2 id="fatal-refusing-to-merge-unrelated-histories"><a href="#fatal-refusing-to-merge-unrelated-histories" class="headerlink" title="fatal: refusing to merge unrelated histories"></a>fatal: refusing to merge unrelated histories</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><h2 id="中文显示乱码"><a href="#中文显示乱码" class="headerlink" title="中文显示乱码"></a>中文显示乱码</h2><p><a href="https://blog.csdn.net/u012145252/article/details/81775362">https://blog.csdn.net/u012145252/article/details/81775362</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;merge时产生冲突&quot;&gt;&lt;a href=&quot;#merge时产生冲突&quot; class=&quot;headerlink&quot; title=&quot;merge时产生冲突&quot;&gt;&lt;/a&gt;merge时产生冲突&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/Users/hetianqi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/03/22/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/hive/"/>
    <id>http://wangdongdong122.github.io/2021/03/22/0_代码相关/hive/</id>
    <published>2021-03-22T08:52:42.000Z</published>
    <updated>2021-03-22T08:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_name</span><br><span class="line">(a string comment <span class="string">&#x27;a&#x27;</span>,b string comment <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="type">row</span> format delimited</span><br><span class="line">fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span></span><br><span class="line">stored <span class="keyword">as</span> textfile;</span><br></pre></td></tr></table></figure><h1 id="增加map数量"><a href="#增加map数量" class="headerlink" title="增加map数量"></a>增加map数量</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set mapred.max.split.size=10000000; -- 决定每个map处理的最大的文件大小，单位为B</span><br><span class="line">set mapred.min.split.size.per.node=10000000; -- 节点中可以处理的最小的文件大小</span><br><span class="line">set mapred.min.split.size.per.rack=10000000; -- 机架中可以处理的最小的文件大小</span><br><span class="line">set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;---实现map中的数据合并需要设置下面的参数，集群默认就是这个格式</span><br></pre></td></tr></table></figure><h1 id="查询log"><a href="#查询log" class="headerlink" title="查询log"></a>查询log</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn logs -applicationId=application_1556066424096_26253 | less</span><br></pre></td></tr></table></figure><h1 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#hivevar</span></span><br><span class="line">hive -d name=hetianqi -f temp.sql</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> name;</span><br><span class="line"><span class="comment">--set name=hetinaiq;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> name<span class="operator">=</span>$&#123;name&#125;</span><br></pre></td></tr></table></figure><h1 id="Hive中Create-table…-as-和-Create-table-…-like-的区别和使用注意"><a href="#Hive中Create-table…-as-和-Create-table-…-like-的区别和使用注意" class="headerlink" title="Hive中Create table… as 和 Create table … like 的区别和使用注意"></a>Hive中Create table… as 和 Create table … like 的区别和使用注意</h1><p><a href="https://blog.csdn.net/lzw2016/article/details/97811799">https://blog.csdn.net/lzw2016/article/details/97811799</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;建表&quot;&gt;&lt;a href=&quot;#建表&quot; class=&quot;headerlink&quot; title=&quot;建表&quot;&gt;&lt;/a&gt;建表&lt;/h1&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/01/26/2_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/embedding%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"/>
    <id>http://wangdongdong122.github.io/2021/01/26/2_算法相关/embedding相关笔记/</id>
    <published>2021-01-26T09:41:10.000Z</published>
    <updated>2021-01-26T09:41:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文献列表"><a href="#文献列表" class="headerlink" title="文献列表"></a>文献列表</h1><ul><li><p>graph embedding</p><p>Billion scale xommodity embedding for W-commerce recommedation in alibaba,KDD,2018</p></li></ul><ul><li>NLP</li></ul><p>A Fast and Simple Algorithm for Training Neural Probabilistic Language Models，2012<br>Learning word embeddings efficiently with noise-contrastive estimation,2013 NIPS</p><p>  [1] Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. Efficient estimation of word representations in vector space. <em>ICLR Workshop</em>, 2013<br>  [2] T. Mikolov, I. Sutskever, K. Chen, G. Corrado, and J. Dean. Distributed Representations of Words and Phrases and their Compositionality. NIPS 2013</p><h2 id="Noise-Contrastive-Estimation-NCE"><a href="#Noise-Contrastive-Estimation-NCE" class="headerlink" title="Noise Contrastive Estimation (NCE)"></a>Noise Contrastive Estimation (NCE)</h2><h1 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h1><h2 id="random-walk"><a href="#random-walk" class="headerlink" title="random walk"></a>random walk</h2><ol><li>无放回等概率抽样n_start个起点</li><li>所有indexer的0都表示未覆盖的品类</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文献列表&quot;&gt;&lt;a href=&quot;#文献列表&quot; class=&quot;headerlink&quot; title=&quot;文献列表&quot;&gt;&lt;/a&gt;文献列表&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;graph embedding&lt;/p&gt;
&lt;p&gt;Billion scale xommodity embedd
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/01/25/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/shell/"/>
    <id>http://wangdongdong122.github.io/2021/01/25/0_代码相关/shell/</id>
    <published>2021-01-25T10:56:32.000Z</published>
    <updated>2021-07-19T02:58:49.907Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="etc-profile、-etc-bashrc、-bash-profile、-bashrc"><a href="#etc-profile、-etc-bashrc、-bash-profile、-bashrc" class="headerlink" title="/etc/profile、/etc/bashrc、~/.bash_profile、~/.bashrc"></a>/etc/profile、/etc/bashrc、~/.bash_profile、~/.bashrc</h1><h2 id="etc-profile"><a href="#etc-profile" class="headerlink" title="/etc/profile"></a>/etc/profile</h2><p>此文件为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行。并从 /etc/profile.d 目录的配置文件中收集 shell 的设置。如果你有对 /etc/profile 有修改的话必须得 source 一下你的修改才会生效，此修改对每个用户都生效。</p><h2 id="etc-bashrc（ubuntu为-etc-bash-bashrc）"><a href="#etc-bashrc（ubuntu为-etc-bash-bashrc）" class="headerlink" title="/etc/bashrc（ubuntu为 /etc/bash.bashrc）"></a>/etc/bashrc（ubuntu为 /etc/bash.bashrc）</h2><p>为每一个运行 bash shell 的用户执行此文件。当 bash shell 被打开时，该文件被读取。如果你想对所有的使用 bash 的用户修改某个配置并在以后打开的 bash 都生效的话可以修改这个文件，修改这个文件不用重启，重新打开一个 bash 即可生效。<br>Ubuntu没有此文件，与之对应的是/ect/bash.bashrc。</p><h2 id="bash-profile（ubuntu为-profile）"><a href="#bash-profile（ubuntu为-profile）" class="headerlink" title="~/.bash_profile（ubuntu为 ~/.profile）"></a>~/.bash_profile（ubuntu为 ~/.profile）</h2><p>每个用户都可使用该文件输入专用于自己使用的 shell 信息，当用户登录时，该文件仅仅执行一次！默认情况下,它设置一些环境变量，执行用户的~/ .bashrc 文件。 此文件类似于 /etc/profile，也是需要需要 source 才会生效，/etc/profile 对所有用户生效，~/.bash_profile 只对当前用户生效。~/.profile(由Bourne Shell和Korn Shell使用)和.login(由C Shell使用)两个文件是.bash_profile的同义词，目的是为了兼容其它Shell。</p><h1 id="Linux的Shell种类"><a href="#Linux的Shell种类" class="headerlink" title="Linux的Shell种类"></a>Linux的Shell种类</h1><p>常见的有：</p><ul><li><p>Bourne Shell（/usr/bin/sh或/bin/sh）、<br>Bourne Again Shell（/bin/bash）、<br>C Shell（/usr/bin/csh）、<br>K Shell（/usr/bin/ksh）、<br>Shell for Root（/sbin/sh）等等。</p></li><li><p>不同的Shell语言的语法有所不同，所以不能交换使用。每种Shell都有其特色之处，基本上，掌握其中任何一种 就足够了。在本文中，我们关注的重点是Bash，也就是Bourne Again Shell，由于易用和免费，Bash在日常工作中被广泛使用；同时，Bash也是大多数Linux系统默认的Shell。</p></li><li>在一般情况下，人们并不区分 Bourne Shell和Bourne Again Shell，所以，在下面的文字中，我们可以看到#!/bin/sh，它同样也可以改为#!/bin/bash。(定义使用哪种sh解释器来解释脚本)</li></ul><h1 id="如果不存在则创建文件夹"><a href="#如果不存在则创建文件夹" class="headerlink" title="如果不存在则创建文件夹"></a>如果不存在则创建文件夹</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ ! -d &quot;$build_dir&quot; ]; then</span><br><span class="line">        mkdir $build_dir</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h1 id="df"><a href="#df" class="headerlink" title="df"></a>df</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df -hl 查看磁盘剩余空间</span><br><span class="line">df -h 查看每个根路径的分区大小</span><br></pre></td></tr></table></figure><h1 id="alias-外部传参"><a href="#alias-外部传参" class="headerlink" title="alias 外部传参"></a>alias 外部传参</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> <span class="built_in">cd</span>=<span class="string">&#x27;func() &#123; cd $1; ls;&#125;; func&#x27;</span> <span class="comment">#定义一个函数func（）&#123;......&#125;；func; &#123;&#125;中间是要alias的执行的命令，多个命令用；隔开，最后；结尾</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/notebook/download</span><br><span class="line"><span class="built_in">alias</span> dl=<span class="string">&#x27;func() &#123; cp $1 /notebook/download/; &#125;; func&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> push=<span class="string">&#x27;func() &#123; cd /notebook/download/; git add . ; git commit -m &quot;update&quot;; git push origin master; &#125;; func&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="du"><a href="#du" class="headerlink" title="du"></a>du</h1><h2 id="查看磁盘大小"><a href="#查看磁盘大小" class="headerlink" title="查看磁盘大小"></a>查看磁盘大小</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> du -s * | sort -nr  #查看大小并按大小排序</span><br><span class="line">du -h ftp #查看指定文件夹下所有文件大小（包括子文件夹）</span><br><span class="line">du -sh [目录名] 返回该目录的大小</span><br><span class="line">du -sm [文件夹] 返回该文件夹总M数</span><br></pre></td></tr></table></figure><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;hi&#x27; test.txt #显示包含hi的行</span><br></pre></td></tr></table></figure><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><h2 id="遍历符合条件的文件"><a href="#遍历符合条件的文件" class="headerlink" title="遍历符合条件的文件"></a>遍历符合条件的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for f in `find . -name &quot;正则匹配&quot; ` #.是路径   双引号和飘号要注意</span><br><span class="line">do</span><br><span class="line">echo $f</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="对于多个文件执行操作"><a href="#对于多个文件执行操作" class="headerlink" title="对于多个文件执行操作"></a>对于多个文件执行操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.sh&quot; | xargs wc -l</span><br></pre></td></tr></table></figure><h2 id="删除符合条件的多个文件"><a href="#删除符合条件的多个文件" class="headerlink" title="删除符合条件的多个文件"></a>删除符合条件的多个文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;$&#123;file_name&#125;_*&quot; | xargs rm -f</span><br></pre></td></tr></table></figure><h2 id="统计python文件总行数"><a href="#统计python文件总行数" class="headerlink" title="统计python文件总行数"></a>统计python文件总行数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.py&quot; | xargs wc -l &gt;&gt; temp.txt</span><br></pre></td></tr></table></figure><h1 id="shellcheck检查sh文件"><a href="#shellcheck检查sh文件" class="headerlink" title="shellcheck检查sh文件"></a>shellcheck检查sh文件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.sh&quot; | xargs shellcheck &gt;&gt; temp2.txt</span><br><span class="line">grep &#x27;In ./&#x27;</span><br></pre></td></tr></table></figure><h1 id="获取当前路径"><a href="#获取当前路径" class="headerlink" title="获取当前路径"></a>获取当前路径</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CUR_DIR=$(<span class="built_in">cd</span> $(dirname <span class="variable">$0</span>); <span class="built_in">pwd</span>) <span class="comment">#但是用source调用脚本时$0的值为&quot;-bash&quot;，词命令无法获取地址</span></span><br><span class="line">CUR_DIR=<span class="string">&quot;<span class="subst">$( cd <span class="string">&quot;<span class="subst">$( dirname <span class="string">&quot;<span class="variable">$&#123;BASH_SOURCE[0]&#125;</span>&quot;</span> )</span>&quot;</span> &amp;&amp; pwd )</span>&quot;</span></span><br></pre></td></tr></table></figure><h1 id="hive"><a href="#hive" class="headerlink" title="hive"></a>hive</h1><h2 id="获取hive表最新分区"><a href="#获取hive表最新分区" class="headerlink" title="获取hive表最新分区"></a>获取hive表最新分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newest_dt=$(hive -e <span class="string">&quot;show partitions cf_model.htq_hztz_xdtz_brs_s;&quot;</span>|tail -1)</span><br><span class="line">newest_dt=<span class="variable">$&#123;newest_dt:3&#125;</span></span><br></pre></td></tr></table></figure><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><h2 id="插入行"><a href="#插入行" class="headerlink" title="插入行"></a>插入行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;1i\要添加的内容&#x27;  yourfile</span><br></pre></td></tr></table></figure><h2 id="删除指定行"><a href="#删除指定行" class="headerlink" title="删除指定行"></a>删除指定行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i ‘1d’ filename</span><br></pre></td></tr></table></figure><h2 id="替换指定字符"><a href="#替换指定字符" class="headerlink" title="替换指定字符"></a>替换指定字符</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/foo/bar/g&#x27; myfile #-i会修改代码</span><br></pre></td></tr></table></figure><h2 id="查看指定行"><a href="#查看指定行" class="headerlink" title="查看指定行"></a>查看指定行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;5,10p&#x27; filename 这样你就可以只查看文件的第5行到第10行。</span><br></pre></td></tr></table></figure><h1 id="split"><a href="#split" class="headerlink" title="split"></a>split</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split -l 2000 urls.txt -d -a 2 url_</span><br><span class="line">解释一下：</span><br><span class="line">-l：按行分割，上面表示将urls.txt文件按2000行一个文件分割为多个文件</span><br><span class="line">-d：添加数字后缀，比如上图中的00，01，02</span><br><span class="line">-a 2：表示用两位数据来顺序命名</span><br><span class="line">url_：看上图就应该明白了，用来定义分割后的文件名前面的部分。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="conda管理环境"><a href="#conda管理环境" class="headerlink" title="conda管理环境"></a>conda管理环境</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda info -envs #列出所有环境</span><br><span class="line">source activate 环境名</span><br><span class="line">source deactivate #回到默认环境</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/cxk207017/article/details/89598139">https://blog.csdn.net/cxk207017/article/details/89598139</a></p><p>conda测试指南<br>在开始这个conda测试之前，你应该已经下载并安装好了Anaconda或者Miniconda<br>注意：在安装之后，你应该关闭并重新打开windows命令行。</p><p>一、Conda测试过程：<br>使用conda。首先我们将要确认你已经安装好了conda<br>配置环境。下一步我们将通过创建几个环境来展示conda的环境管理功能。使你更加轻松的了解关于环境的一切。我们将学习如何确认你在哪个环境中，以及如何做复制一个环境作为备份。<br>测试python。然后我们将检查哪一个版本的python可以被安装，以及安装另一个版本的python，还有在两个版本的python之间的切换。<br>检查包。我们将1)罗列出安装在我们电脑上的包，2)浏览可用的包，3)使用conda install命令来来安装以及移除一些包。对于一些不能使用conda安装的包，我们将4)在Anaconda.org网站上搜索。对于那些在其它位置的包，我们将5)使用pip命令来实现安装。我们还会安装一个可以免费试用30天的商业包IOPro<br>移除包、环境以及conda.我们将以学习删除你的包、环境以及conda来结束这次测试。<br>二、完整过程<br>提示：在任何时候你可以通过在命令后边跟上—help来获得该命令的完整文档。例如，你可以通过如下的命令来学习conda的update命令。</p><p>conda update —help<br>\1. 管理conda：<br>Conda既是一个包管理器又是一个环境管理器。你肯定知道包管理器，它可以帮你发现和查看包。但是如果当我们想要安装一个包，但是这个包只支持跟我们目前使用的python不同的版本时。你只需要几行命令，就可以搭建起一个可以运行另外python版本的环境。，这就是conda环境管理器的强大功能。<br>提示：无论你使用Linux、OS X或者Windows命令行工具，在你的命令行终端conda指令都是一样的，除非有特别说明。</p><p>检查conda已经被安装。<br>为了确保你已经在正确的位置安装好了conda，让我们来检查你是否已经成功安装好了Anaconda。在你的命令行终端窗口，输入如下代码：</p><p>conda —version<br>Conda会返回你安装Anaconda软件的版本。<br>提示：如果你看到了错误信息，检查你是否在安装过程中选择了仅为当前用户按安装，并且是否以同样的账户来操作。确保用同样的账户登录安装了之后重新打开命令行终端窗口。</p><p>升级当前版本的conda<br>接下来，让我们通过使用如下update命令来升级conda：</p><p>conda update conda<br>conda将会比较新旧版本并且告诉你哪一个版本的conda可以被安装。它也会通知你伴随这次升级其它包同时升级的情况。<br>如果新版本的conda可用，它会提示你输入y进行升级.</p><p>proceed ([y]/n)? y<br>conda更新到最新版后，我们将进入下一个主题。</p><h2 id="管理环境"><a href="#管理环境" class="headerlink" title="管理环境"></a>管理环境</h2><p>现在我们通过创建一些环境来展示conda的环境操作，然后移动它们。</p><h3 id="创建并激活一个环境"><a href="#创建并激活一个环境" class="headerlink" title="创建并激活一个环境"></a>创建并激活一个环境</h3><p>使用conda create命令，后边跟上你希望用来称呼它的任何名字：</p><blockquote><p>conda create —n py3 python=3</p><p>这条命令将会给biopython包创建一个新的环境，位置在/envs/snowflakes<br>小技巧：很多跟在—后边常用的命令选项，可以被略写为一个短线加命令首字母。所以—name选项和-n的作用是一样的。通过conda -h或conda –-help来看大量的缩写。</p></blockquote><h3 id="激活这个新环境"><a href="#激活这个新环境" class="headerlink" title="激活这个新环境"></a>激活这个新环境</h3><p>Linux，OS X: source activate snowflakes<br>Windows：activate snowflake`<br>小技巧：新的开发环境会被默认安装在你conda目录下的envs文件目录下。你可以指定一个其他的路径；去通过conda create -h了解更多信息吧。<br>小技巧：如果我们没有指定安装python的版本，donda会安装我们最初安装conda时所装的那个版本的python。</p><p>创建第二个环境<br>这次让我们来创建并命名一个新环境，然后安装另一个版本的python以及两个包 Astroid 和 Babel。</p><p>conda create -n bunnies python=3 Astroid Babel<br>这将创建第二个基于python3 ，包含Astroid 和 Babel 包，称为bunnies的新环境，在/envs/bunnies文件夹里。<br>小技巧：在此同时安装你想在这个环境中运行的包，<br>小提示：在你创建环境的同时安装好所有你想要的包，在后来依次安装可能会导致依赖性问题（貌似是，不太懂这个术语怎么翻）。<br>小技巧：你可以在conda create命令后边附加跟多的条件，键入conda create –h 查看更多细节。</p><p>列出所有的环境<br>现在让我们来检查一下截至目前你所安装的环境，使用conda environment info 命令来查看它:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p>你将会看到如下的环境列表：</p><p>conda environments:</p><p> snowflakes          * /home/username/miniconda/envs/snowflakes</p><p> bunnies               /home/username/miniconda/envs/bunnies</p><p> root                  /home/username/miniconda<br>确认当前环境<br>你现在处于哪个环境中呢？snowflakes还是bunnies？想要确定它，输入下面的代码：</p><p>conda info -envis<br>conda将会显示所有环境的列表，当前环境会显示在一个括号内。</p><p>(snowflakes)<br>注意：conda有时也会在目前活动的环境前边加上*号。</p><p>切换到另一个环境(activate/deactivate)<br>为了切换到另一个环境，键入下列命令以及所需环境的名字。</p><p>Linux，OS X: source activate snowflakes<br>Windows：activate snowflakes<br>如果要从你当前工作环境的路径切换到系统根目录时，键入：</p><p>Linux，OS X: source deactivate<br>Windows: deactivate<br>当该环境不再活动时，将不再被提前显示。</p><p>复制一个环境<br>通过克隆来复制一个环境。这儿将通过克隆snowfllakes来创建一个称为flowers的副本。</p><p>conda create -n flowers —clone snowflakes<br>通过conda info –-envs来检查环境<br>你现在应该可以看到一个环境列表：flowers, bunnies, and snowflakes.</p><p>删除一个环境<br>如果你不想要这个名为flowers的环境，就按照如下方法移除该环境：</p><p>conda remove -n flowers —all<br>为了确定这个名为flowers的环境已经被移除，输入以下命令：</p><p>conda info -e<br>flowers 已经不再在你的环境列表里了，所以我们知道它被删除了。</p><p>学习更多关于环境的知识<br>如果你想学习更多关于conda的命令，就在该命令后边跟上 -h</p><p>conda remove -h<br>\3. 管理Python<br>conda对Python的管理跟其他包的管理类似，所以可以很轻松地管理和升级多个安装。</p><p>检查python版本<br>首先让我们检查那个版本的python可以被安装：</p><p>conda search —full —name python<br>你可以使用conda search python来看到所有名字中含有“python”的包或者加上—full —name命令选项来列出完全与“python”匹配的包。</p><p>安装一个不同版本的python<br>现在我们假设你需要python3来编译程序，但是你不想覆盖掉你的python2.7来升级，你可以创建并激活一个名为snakes的环境，并通过下面的命令来安装最新版本的python3：</p><p>conda create -n snakes python=３<br>·Linux，OS X：source activate snakes<br>·Windows： activate snakes<br>小提示：给环境取一个很形象的名字，例如“Python3”是很明智的，但是并不有趣。</p><p>确定环境添加成功<br>为了确保snakes环境已经被安装了，键入如下命令：</p><p>conda info -e<br>conda会显示环境列表，当前活动的环境会被括号括起来（snakes）</p><p>检查新的环境中的python版本<br>确保snakes环境中运行的是python3：</p><p>python —version<br>使用不同版本的python<br>为了使用不同版本的python，你可以切换环境，通过简单的激活它就可以，让我们看看如何返回默认2.7</p><p>·Linux，OS X: source activate snowflakes<br>·Windows：activate snowflakes<br>检查python版本：<br>确保snowflakes环境中仍然在运行你安装conda时安装的那个版本的python。</p><p>python —version<br>注销该环境<br>当你完成了在snowflakes环境中的工作室，注销掉该环境并转换你的路径到先前的状态：</p><p>·Linux，OS X：source deactivate<br>·Windows：deactivate<br>\4. 管理包<br>现在让我们来演示包。我们已经安装了一些包（Astroid，Babel和一些特定版本的python），当我们创建一个新环境时。我们检查我们已经安装了那些包，检查哪些是可用的，寻找特定的包并安装它。接下来我们在Anconda.org仓库中查找并安装一些指定的包，用conda来完成更多pip可以实现的安装，并安装一个商业包。</p><p>查看该环境中包和其版本的列表：<br>使用这条命令来查看哪个版本的python或其他程序安装在了该环境中，或者确保某些包已经被安装了或被删除了。在你的终端窗口中输入：</p><blockquote><p>conda list<br>使用conda命令查看可用包的列表<br>一个可用conda安装的包的列表，按照Python版本分类，可以从这个地址获得：<br><a href="http://docs.continuum.io/anaconda/pkg-docs.html">http://docs.continuum.io/anaconda/pkg-docs.html</a></p></blockquote><p>查找一个包<br>首先让我们来检查我们需要的这个包是否可以通过conda来安装：</p><p>conda search beautifulsoup4<br>它展示了这个包，所以我们知道它是可用的。</p><p>安装一个新包<br>我们将在当前环境中安装这个Beautiful Soup包，使用conda命令如下；<br>conda install —name bunnies beautifulsoup4<br>提示：你必须告诉conda你要安装环境的名字（-n bunies）否则它将会被安装到当前环境中。<br>现在激活bunnies环境，并且用conda list来显示哪些程序被安装了。</p><p>·Linux，OS X：source activate bunnies<br>·Windows：activate bunnies<br>所有的平台：<br>conda list<br>从Anaconda.org安装一个包<br>如果一个包不能使用conda安装，我们接下来将在Anaconda.org网站查找。Anaconda.org向公开和私有包仓库提供包管理服务。Anaconda.org是一个连续分析产品。<br>提示：你在Anaconda.org下载东西的时候不强制要求注册。<br>为了从Anaconda.org下载到当前的环境中，我们需要通过指定Anaconda.org为一个特定通道，通过输入这个包的完整路径来实现。<br>在浏览器中，去 <a href="http://anaconda.org">http://anaconda.org</a> 网站。我们查找一个叫“bottleneck”的包，所以在左上角的叫“Search Anaconda Cloud”搜索框中输入“bottleneck”并点击search按钮。<br>Anaconda.org上会有超过一打的bottleneck包的版本可用，但是我们想要那个被下载最频繁的版本。所以你可以通过下载量来排序，通过点击Download栏。<br>点击包的名字来选择最常被下载的包。它会链接到Anaconda.org详情页显示下载的具体命令：</p><p>conda install —channel https：//conda .anaconda.ort/pandas bottleneck<br>检查被下载的包<br>conda list<br>通过pip命令来安装包<br>对于那些无法通过conda安装或者从Anaconda.org获得的包，我们通常可以用pip（“pip install packages”的简称）来安装包。<br>提示： pip只是一个包管理器，所以它不能为你管理环境。pip甚至不能升级python，因为它不像conda一样把python当做包来处理。但是它可以安装一些conda安装不了的包，和vice versa（此处不会翻译）。pip和conda都集成在Anaconda或miniconda里边。</p><p>我们激活我们想放置程序的环境，然后通过pip安装一个叫“See”的程序。</p><p>·Linux，OS X： source activate bunnies<br>·Windows：activate bunnies<br>所有平台：<br>pip install see<br>检查pip安装<br>检查See是否被安装：</p><p>conda list<br>安装商业包<br>安装商业包与你安装其他的包的过程异常。举个例子，让我们安装并删除一个更新的商业包的免费试用 IOPro，可以加速你的python处理速度：</p><p>conda install iopro<br>提示：除了学术使用，该版本在30天后试用期满</p><p>你现在可以安装以及检查你想用conda安装的任何包，无论使用conda命令、从Anaconda.org下载或者使用pip安装，无论开源软件还是商业包。</p><p>\5. 移除包、环境、或者conda<br>如果你愿意的话。让我们通过移除一个或多个试验包、环境以及conda来结束这次测试指导。</p><p>移除包<br>假设你决定不再使用商业包IOPro。你可以在bunnies环境中移除它。</p><p>conda remove -n bunnies iopro<br>确认包已经被移除<br>使用conda list命令来确认IOPro已经被移除了</p><p>conda list<br>移除环境<br>我们不再需要snakes环境了，所以输入以下命令：<br>conda remove -n snakes —all</p><p>确认环境被移除<br>为了确认snakes环境已经被移除了，输入以下命令：</p><p> conda info —envis<br>snakes不再显示在环境列表里了，所以我们知道它已经被删除了</p><p>删除conda<br>Linux，OS X：<br>移除Anaconda 或 Miniconda 安装文件夹<br>rm -rf ~/miniconda OR  rm -rf ~/anaconda<br>Windows：<br>去控制面板，点击“添加或删除程序”，选择“Python2.7（Anaconda）”或“Python2.7（Miniconda）”并点击删除程序。</p><h3 id="5K服务器环境安装实例"><a href="#5K服务器环境安装实例" class="headerlink" title="5K服务器环境安装实例"></a>5K服务器环境安装实例</h3><blockquote><p>conda create -n py3 python=3.6   #创建叫做py3的环境，python版本是3.6</p><p>conda info -e #查看所有环境<br># To activate this environment, use:<br># &gt; source activate py3<br># To deactivate an active environment, use:<br># &gt; source deactivate</p><p>activate py3 #激活相应环境</p><p>conda install numpy #安装包方式一</p><p>conda install scikit-learn</p><p>pip install numoy #安装包方式二</p></blockquote><h1 id="find-1"><a href="#find-1" class="headerlink" title="find"></a>find</h1><p>列出当前目录及子目录下所有文件和文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find .</span><br></pre></td></tr></table></figure><p>在<code>/home</code>目录下查找以.txt结尾的文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><p>同上，但忽略大小写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -iname &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><p>当前目录及子目录下查找所有以.txt和.pdf结尾的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; </span><br></pre></td></tr></table></figure><p>匹配文件路径或者文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /usr/ -path &quot;*local*&quot;</span><br></pre></td></tr></table></figure><p>基于正则表达式匹配文件路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure><p>同上，但忽略大小写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -iregex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure><ul><li>否定参数</li></ul><p>找出/home下不是以.txt结尾的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home ! -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><ul><li>根据文件类型进行搜索</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type 类型参数</span><br></pre></td></tr></table></figure><p>类型参数列表：</p><ul><li><strong>f</strong> 普通文件</li><li><strong>l</strong> 符号连接</li><li><strong>d</strong> 目录</li><li><strong>c</strong> 字符设备</li><li><strong>b</strong> 块设备</li><li><strong>s</strong> 套接字</li><li><p><strong>p</strong> Fifo</p></li><li><p>基于目录深度搜索</p></li></ul><p>向下最大深度限制为3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -maxdepth 3 -type f</span><br></pre></td></tr></table></figure><p>搜索出深度距离当前目录至少2个子目录的所有文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -mindepth 2 -type f</span><br></pre></td></tr></table></figure><ul><li>根据文件时间戳进行搜索</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f 时间戳</span><br></pre></td></tr></table></figure><p>UNIX/Linux文件系统每个文件都有三种时间戳：</p><ul><li><strong>访问时间</strong>（-atime/天，-amin/分钟）：用户最近一次访问时间。</li><li><strong>修改时间</strong>（-mtime/天，-mmin/分钟）：文件最后一次修改时间。</li><li><strong>变化时间</strong>（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。</li></ul><p>搜索最近七天内被访问过的所有文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -atime -7</span><br></pre></td></tr></table></figure><p>搜索恰好在七天前被访问过的所有文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -atime 7</span><br></pre></td></tr></table></figure><p>搜索超过七天内被访问过的所有文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -atime +7</span><br></pre></td></tr></table></figure><p>搜索访问时间超过10分钟的所有文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -amin +10</span><br></pre></td></tr></table></figure><p>找出比<a href="http://man.linuxde.net/file">file</a>.log修改时间更长的所有文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -newer file.log</span><br></pre></td></tr></table></figure><ul><li>根据文件大小进行匹配</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size 文件大小单元</span><br></pre></td></tr></table></figure><p>文件大小单元：</p><ul><li><strong>b</strong> —— 块（512字节）</li><li><strong>c</strong> —— 字节</li><li><strong>w</strong> —— 字（2字节）</li><li><strong>k</strong> —— 千字节</li><li><strong>M</strong> —— 兆字节</li><li><strong>G</strong> —— 吉字节</li></ul><p>搜索大于10KB的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size +10k</span><br></pre></td></tr></table></figure><p>搜索小于10KB的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size -10k</span><br></pre></td></tr></table></figure><p>搜索等于10KB的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size 10k</span><br></pre></td></tr></table></figure><ul><li>删除匹配文件</li></ul><p>删除当前目录下所有.txt文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -delete</span><br></pre></td></tr></table></figure><ul><li>根据文件权限/所有权进行匹配</li></ul><p>当前目录下搜索出权限为777的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -perm 777</span><br></pre></td></tr></table></figure><p>找出当前目录下权限不是644的<a href="http://man.linuxde.net/php">php</a>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.php&quot; ! -perm 644</span><br></pre></td></tr></table></figure><p>找出当前目录用户tom拥有的所有文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -user tom</span><br></pre></td></tr></table></figure><p>找出当前目录用户组sunk拥有的所有文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -group sunk</span><br></pre></td></tr></table></figure><ul><li>借助<code>-exec</code>选项与其他命令结合使用</li></ul><p>找出当前目录下所有root的文件，并把所有权更改为用户tom</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find .-type f -user root -exec chown tom &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>上例中，<strong>{}</strong> 用于与<strong>-exec</strong>选项结合使用来匹配所有文件，然后会被替换为相应的文件名。</p><p>找出自己家目录下所有的.txt文件并删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find $HOME/. -name &quot;*.txt&quot; -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>上例中，<strong>-ok</strong>和<strong>-exec</strong>行为一样，不过它会给出提示，是否执行相应的操作。</p><p>查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -exec cat &#123;&#125; \;&gt; all.txt</span><br></pre></td></tr></table></figure><p>将30天前的.log文件移动到old目录中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp &#123;&#125; old \;</span><br></pre></td></tr></table></figure><p>找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.txt&quot; -exec printf &quot;File: %s\n&quot; &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-exec ./text.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure><ul><li>搜索但跳出指定的目录</li></ul><p>查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -path &quot;./sk&quot; -prune -o -name &quot;*.txt&quot; -print</span><br></pre></td></tr></table></figure><ul><li>find其他技巧收集</li></ul><p>要列出所有长度为零的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -empty</span><br></pre></td></tr></table></figure><h1 id="amp-amp-和-amp-的区别"><a href="#amp-amp-和-amp-的区别" class="headerlink" title="&amp;&amp; 和&amp;的区别"></a>&amp;&amp; 和&amp;的区别</h1><p>a &amp; b 表示a和b同时运行<br>a &amp;&amp; b表示 a运行成功后再运行b</p><h1 id="sh-source-exct的区别"><a href="#sh-source-exct的区别" class="headerlink" title="sh,source,exct的区别"></a>sh,source,exct的区别</h1><p><a href="https://www.jianshu.com/p/dd7956aec097">https://www.jianshu.com/p/dd7956aec097</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;etc-profile、-etc-bashrc、-bash-profile、-bashrc&quot;&gt;&lt;a href=&quot;#etc-profile、-etc-bashrc、-bash-profile、-bashrc&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2021/01/22/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/tensorflow/"/>
    <id>http://wangdongdong122.github.io/2021/01/22/0_代码相关/tensorflow/</id>
    <published>2021-01-22T09:30:32.000Z</published>
    <updated>2022-01-19T07:51:07.582Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Tensorflow笔记"><a href="#Tensorflow笔记" class="headerlink" title="Tensorflow笔记"></a>Tensorflow笔记</h1><h1 id="name-scope-VS-variable-scope"><a href="#name-scope-VS-variable-scope" class="headerlink" title="name_scope VS variable_scope"></a>name_scope VS variable_scope</h1><p>参考知乎：<a href="https://zhuanlan.zhihu.com/p/52055580">https://zhuanlan.zhihu.com/p/52055580</a></p><p><strong>注意</strong>，tf.variable() 和tf.get_variable()有不同的创建变量的方式：<strong>tf.Variable() 每次都会新建变量</strong>。如果希望<strong>重用</strong>（<strong>共享</strong>）一些变量，就需要用到了<strong>get_variable()，它会去搜索变量名，有就直接用，没有再新建</strong>。此外，<strong>为了对不同位置或者范围的共享进行区分</strong>，就引入<strong>名字域</strong>。既然用到变量名了，就涉及到了名字域的概念。这就是为什么会有scope 的概念。name_scope 作用域操作，variable_scope 可以通过设置reuse 标志以及初始化方式来影响域下的变量，<strong>因为想要达到变量共享的效果, 就要在 tf.variable_scope()的作用域下使用 tf.get_variable() 这种方式产生和提取变量. 不像 tf.Variable() 每次都会产生新的变量, tf.get_variable() 如果遇到了已经存在名字的变量时, 它会单纯的提取这个同样名字的变量，如果不存在名字的变量再创建.</strong></p><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>建图(graph) — 打开对话(session) — 初始化变量 — sess.run()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模型保存</span></span><br><span class="line">saver=tf.train.Saver() </span><br><span class="line">sess=tf.Session()</span><br><span class="line">saver.save(sess,check_point_dir + <span class="string">&#x27;model.ckpt&#x27;</span>,global_step=i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型调用（只调用参数）</span></span><br><span class="line">saver=tf.train.Saver()</span><br><span class="line">sess=tf.Session()</span><br><span class="line">ckpt = tf.train.get_checkpoint_state(check_point_dir) <span class="comment">#获取最新的保存的模型地址</span></span><br><span class="line">saver.restore(sess,ckpt.model_saved_ckeckpoint_path)</span><br><span class="line"><span class="comment">#saver.restore(sess,&#x27;....ckpt&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#模型调用（参数和图）</span></span><br><span class="line">sess=tf.Session()</span><br><span class="line">ckpt =tf.train.latest_checkpoint(check_point_path)  <span class="comment">#获取最新的保存的模型地址</span></span><br><span class="line">saver =tf.train.import_meta_graph(ckpt+<span class="string">&#x27;.meta&#x27;</span>) <span class="comment">#载入结构图</span></span><br><span class="line"><span class="comment">#saver =tf.train.import_meta_graph(&#x27;........ckpt.meta&#x27;)</span></span><br><span class="line">saver.restore(sess,<span class="string">&#x27;....ckpt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#基本操作</span></span><br><span class="line">a=tf.placeholder(<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line">b=tf.placeholder(<span class="string">&#x27;float&#x27;</span>)<span class="comment">#定义变量</span></span><br><span class="line">y=tf.mul(a,b) <span class="comment">#构造op节点</span></span><br><span class="line"></span><br><span class="line">sess=tf.Session()<span class="comment">#建立对话</span></span><br><span class="line"><span class="built_in">print</span>（sess.run(y,feed_dic&#123;a:<span class="number">3</span>,b:<span class="number">3</span>&#125;)）<span class="comment">#运行节点并打印结果</span></span><br><span class="line">sess.close（）<span class="comment">#关闭会话</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#onehot</span></span><br><span class="line"><span class="comment">#tf.one_hot(indices, depth, on_value=None, off_value=None, CLASS=8</span></span><br><span class="line">label=tf.constant([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br><span class="line">CLASS=<span class="number">8</span></span><br><span class="line">b=tf.one_hot(label,CLASS，<span class="number">1</span>，<span class="number">0</span>)</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"><span class="built_in">print</span>(sess.run(b))</span><br></pre></td></tr></table></figure><p>checkpoint文件：用于告知某些TF函数，这是最新的检查点文件（可以用记事本打开看一下）</p><p>.data文件：（后面缀的那一串我也布吉岛是啥）这个文件保存的是图中所有变量的值，没有结构。</p><p>.index文件：可能是保存了一些必要的索引叭（这个文件不大清楚）。</p><p>.meta文件：保存了计算图的结构，但是不包含里面变量的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">　　<span class="comment">#搭建网络</span></span><br><span class="line">　　x=tf.placeholder(tf.float32,name=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">　　y=tf.placeholder(tf.float32,name=<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">　　b=tf.Variable(<span class="number">1.</span>,name=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">　　xy=tf.multiply(x,y)</span><br><span class="line">　　op=tf.add(xy,b,name=<span class="string">&#x27;op&#x27;</span>)</span><br><span class="line">　　sess.run(tf.global_variables_initializer())</span><br><span class="line">　　<span class="built_in">print</span>(sess.run(op,feed_dict=&#123;x:<span class="number">2</span>,y:<span class="number">3</span>&#125;))</span><br><span class="line"></span><br><span class="line">　　<span class="comment">#ckpt保存</span></span><br><span class="line">　　saver=tf.train.Saver()</span><br><span class="line">　　saver.save(sess,<span class="string">&#x27;D:/pycharm files/111/ckpt/model_ck&#x27;</span>)</span><br><span class="line"></span><br><span class="line">　　<span class="comment">#pb保存</span></span><br><span class="line">　　constant_graph=tf.graph_util.convert_variables_to_constants(sess,sess.graph_def,[<span class="string">&#x27;op&#x27;</span>])</span><br><span class="line">　　<span class="keyword">with</span> tf.gfile.FastGFile(<span class="string">&#x27;D:/pycharm files/111/pb/model.pb&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">　　f.write(constant_graph.SerializeToString())</span><br><span class="line"></span><br><span class="line">　　<span class="comment">#savedmodel文件保存</span></span><br><span class="line">　　builder=tf.saved_model.builder.SavedModelBuilder(<span class="string">&#x27;D:/pycharm files/111/savemodel&#x27;</span>)</span><br><span class="line">　　builder.add_meta_graph_and_variables(sess,[<span class="string">&#x27;cpu_server_1&#x27;</span>])</span><br><span class="line">　　builder.save()</span><br><span class="line"></span><br><span class="line">　　<span class="built_in">print</span>(<span class="string">&#x27;over&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">　　<span class="comment">#ckpt加载</span></span><br><span class="line">　　saver=tf.train.import_meta_graph(<span class="string">&#x27;D:/pycharm files/111/ckpt/model_ck.meta&#x27;</span>)</span><br><span class="line">　　saver.restore(sess,tf.train.latest_checkpoint(<span class="string">&#x27;D:/pycharm files/111/ckpt&#x27;</span>))</span><br><span class="line"></span><br><span class="line">　　<span class="comment">#pb加载</span></span><br><span class="line">　　<span class="keyword">with</span> tf.gfile.FastGFile(<span class="string">&#x27;D:/pycharm files/111/pb/model.pb&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">　　　　graph_def=tf.GraphDef()</span><br><span class="line">　　　　graph_def.ParseFromString(f.read())</span><br><span class="line">　　　　tf.import_graph_def(graph_def,name=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">　　<span class="comment">#savemodel加载</span></span><br><span class="line">　　tf.saved_model.loader.load(sess, [<span class="string">&#x27;cpu_server_1&#x27;</span>], <span class="string">&#x27;D:/pycharm files/111/savemodel&#x27;</span>)</span><br><span class="line"></span><br><span class="line">　　<span class="comment">#测试模型加载是否成功</span></span><br><span class="line">　　input_x = sess.graph.get_tensor_by_name(<span class="string">&#x27;x:0&#x27;</span>)</span><br><span class="line">　　input_y = sess.graph.get_tensor_by_name(<span class="string">&#x27;y:0&#x27;</span>)</span><br><span class="line">　　op = sess.graph.get_tensor_by_name(<span class="string">&#x27;op:0&#x27;</span>)</span><br><span class="line">　　ret = sess.run(op, feed_dict=&#123;input_x: <span class="number">5</span>, input_y: <span class="number">5</span>&#125;)</span><br><span class="line">　　<span class="built_in">print</span>(ret)</span><br></pre></td></tr></table></figure><h2 id="graph-amp-session"><a href="#graph-amp-session" class="headerlink" title="graph &amp; session"></a>graph &amp; session</h2><p><a href="https://www.cnblogs.com/hypnus-ly/p/8040951.html">https://www.cnblogs.com/hypnus-ly/p/8040951.html</a></p><ul><li><p>使用默认图和默认session</p><p>不用指定图或session</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tf.reset_default_graph()   <span class="comment">#清空默认图中所有节点</span></span><br><span class="line"><span class="keyword">with</span> tf.variable_scope(<span class="string">&#x27;&#x27;</span>):</span><br><span class="line">a = tf.constant(<span class="number">1</span>,name=<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">b = tf.constant(<span class="number">2</span>,name=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">c = a*b</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line"><span class="built_in">print</span>(sess.run(c))</span><br></pre></td></tr></table></figure></li><li><p>使用指定图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">g1=tf.Graph()</span><br><span class="line">with g1.as_default():</span><br><span class="line">    # 在计算图g1中定义变量&#x27;v&#x27;,并设置初始值为0。</span><br><span class="line">    v=tf.get_variable(&#x27;v&#x27;,initializer=tf.zeros_initializer()(shape = [1]))</span><br><span class="line">    </span><br><span class="line">g2=tf.Graph()</span><br><span class="line">with g2.as_default():</span><br><span class="line">    # 在计算图g2中定义变量&#x27;v&#x27;,并设置初始值微1。</span><br><span class="line">    v=tf.get_variable(&#x27;v&#x27;,initializer=tf.ones_initializer()(shape = [1]))</span><br><span class="line"></span><br><span class="line"># 在计算图g1中读取变量&#x27;v&#x27;的取值</span><br><span class="line">with tf.Session(graph=g1) as sess:</span><br><span class="line">    tf.global_variables_initializer().run()</span><br><span class="line">    with tf.variable_scope(&#x27;&#x27;,reuse=True):</span><br><span class="line">        # 在计算图g1中，变量&#x27;v&#x27;的取值应该为0，下一行代码会输出[0.]。</span><br><span class="line">        print(sess.run(tf.get_variable(&#x27;v&#x27;)))</span><br><span class="line"></span><br><span class="line"># 在计算图g2中读取变量&#x27;v&#x27;的取值</span><br><span class="line">with tf.Session(graph=g2) as sess:</span><br><span class="line">    tf.global_variables_initializer().run()</span><br><span class="line">    with tf.variable_scope(&#x27;&#x27;,reuse=True):</span><br><span class="line">        # 在计算图g2中，变量&#x27;v&#x27;的取值应该为1，下一行代码会输出[1.]。</span><br><span class="line">        print(sess.run(tf.get_variable(&#x27;v&#x27;)))</span><br></pre></td></tr></table></figure></li></ul><div class="table-container"><table><thead><tr><th>集合名称</th><th>集合内容</th><th>使用场景</th></tr></thead><tbody><tr><td>tf.GraphKeys.VARIABLES</td><td>所有变量</td><td>持久化tensorflow模型</td></tr><tr><td>tf.GraphKeys.TRAINABLE_VARIABLES</td><td>可学习的变量（一般指神经网络中的参数）</td><td>模型训练、生成模型可视化内容</td></tr><tr><td>tf.GraphKeys.SUMMARIES</td><td>日志生成相关的张量</td><td>tensorflow计算可视化</td></tr><tr><td>tf.GraphKeys.QUEUE_RUNNERS</td><td>处理输入的QueueRunner</td><td>输入处理</td></tr><tr><td>tf.GraphKeys.MOVING_AVERAGE_VARIABLES</td><td>所有计算了滑动平均值的变量</td><td>计算变量的滑动平均值</td></tr></tbody></table></div><h2 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g_list = tf.global_variables() <span class="comment">#获取素有变量（有的是tensor不是变量，不会获取）</span></span><br><span class="line">variable_names = [v.name <span class="keyword">for</span> v <span class="keyword">in</span> tf.trainable_variables()] <span class="comment">#获取所有可训练变量</span></span><br><span class="line">[<span class="built_in">print</span>(n.name) <span class="keyword">for</span> n <span class="keyword">in</span> tf.get_default_graph().as_graph_def().node] <span class="comment">#打印所有节点（tensor)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="tf-nn，tf-layers，-tf-contrib-异同"><a href="#tf-nn，tf-layers，-tf-contrib-异同" class="headerlink" title="tf.nn，tf.layers， tf.contrib 异同"></a>tf.nn，tf.layers， tf.contrib 异同</h2><p>我们在使用tensorflow时，会发现tf.nn，tf.layers， tf.contrib模块有很多功能是重复的，尤其是卷积操作，在使用的时候，我们可以根据需要现在不同的模块。但有些时候可以一起混用。</p><p>​        下面是对三个模块的简述：</p><p>​        （1）tf.nn ：提供神经网络相关操作的支持，包括卷积操作（conv）、池化操作（pooling）、归一化、loss、分类操作、embedding、RNN、Evaluation。</p><p>​        （2）tf.layers：主要提供的高层的神经网络，主要和卷积相关的，个人感觉是对tf.nn的进一步封装，tf.nn会更底层一些。</p><p>​        （3）tf.contrib：tf.contrib.layers提供够将计算图中的  网络层、正则化、摘要操作、是构建计算图的高级操作，但是tf.contrib包含不稳定和实验代码，有可能以后API会改变。</p><h2 id="load-pb-model"><a href="#load-pb-model" class="headerlink" title="load pb model"></a>load pb model</h2><p><a href="https://leimao.github.io/blog/Save-Load-Inference-From-TF-Frozen-Graph/">https://leimao.github.io/blog/Save-Load-Inference-From-TF-Frozen-Graph/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参考 https://stackoverflow.com/questions/50632258/how-to-restore-tensorflow-model-from-pb-file-in-python</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.platform <span class="keyword">import</span> gfile</span><br><span class="line">GRAPH_PB_PATH = <span class="string">&#x27;./frozen_model.pb&#x27;</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;load graph&quot;</span>)</span><br><span class="line">   <span class="keyword">with</span> gfile.FastGFile(GRAPH_PB_PATH,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">       graph_def = tf.GraphDef()</span><br><span class="line">   graph_def.ParseFromString(f.read())</span><br><span class="line">   sess.graph.as_default()</span><br><span class="line">   tf.import_graph_def(graph_def, name=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">   graph_nodes=[n <span class="keyword">for</span> n <span class="keyword">in</span> graph_def.node]</span><br><span class="line">   names = []</span><br><span class="line">   <span class="keyword">for</span> t <span class="keyword">in</span> graph_nodes:</span><br><span class="line">      names.append(t.name)</span><br><span class="line">   <span class="built_in">print</span>(names)</span><br></pre></td></tr></table></figure><p>如果报错：DecodeError: Error parsing message ,则修改为以下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.platform <span class="keyword">import</span> gfile</span><br><span class="line"><span class="keyword">from</span> tensorflow.core.protobuf <span class="keyword">import</span> saved_model_pb2</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.util <span class="keyword">import</span> compat</span><br><span class="line">graph_path = <span class="string">&#x27;./saved_model_ctcvr.pb&#x27;</span></span><br><span class="line"><span class="comment"># sess = tf.InteractiveSession(graph = self.graph)</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line"><span class="keyword">with</span> gfile.FastGFile(graph_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = compat.as_bytes(f.read())</span><br><span class="line">    sm = saved_model_pb2.SavedModel()</span><br><span class="line">    sm.ParseFromString(data)</span><br><span class="line">    graph_def = sm.meta_graphs[<span class="number">0</span>].graph_def</span><br><span class="line">sess.graph.as_default()</span><br><span class="line">graph = sess.graph</span><br><span class="line">tf.import_graph_def(graph_def,name=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Check out the input placeholders:&#x27;</span>)</span><br><span class="line">nodes = [n.name + <span class="string">&#x27; =&gt; &#x27;</span> +  n.op <span class="keyword">for</span> n <span class="keyword">in</span> graph_def.node <span class="keyword">if</span> n.op <span class="keyword">in</span> (<span class="string">&#x27;Placeholder&#x27;</span>)]</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">    <span class="built_in">print</span>(node)</span><br><span class="line">    </span><br><span class="line"> <span class="comment"># Get layer names</span></span><br><span class="line">layers = [op.name <span class="keyword">for</span> op <span class="keyword">in</span> graph.get_operations()]</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> layers:</span><br><span class="line">    <span class="built_in">print</span>(layer)</span><br><span class="line"></span><br><span class="line">output_tensor = graph.get_tensor_by_name(<span class="string">&quot;import/model/pctr:0&quot;</span>)</span><br><span class="line">output = sess.run(output_tensor, feed_dict = features_dic) <span class="comment">#但是貌似知识import了图，没有restore variable</span></span><br></pre></td></tr></table></figure><h1 id="tfrecord"><a href="#tfrecord" class="headerlink" title="tfrecord"></a>tfrecord</h1><ul><li>生成</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 借助于TFRecordWriter 才能将信息写入TFRecord 文件</span></span><br><span class="line">writer = tf.python_io.TFRecordWriter(output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建example对象</span></span><br><span class="line">example = tf.train.Example(features=tf.train.Features(feature=&#123;</span><br><span class="line">             <span class="string">&#x27;name&#x27;</span>: tf.train.Feature(bytes_list=tf.train.BytesList(value=[name])),</span><br><span class="line">             <span class="string">&#x27;shape&#x27;</span>: tf.train.Feature(int64_list=tf.train.Int64List(value=[shape[<span class="number">0</span>], shape[<span class="number">1</span>], shape[<span class="number">2</span>]])),</span><br><span class="line">             <span class="string">&#x27;data&#x27;</span>: tf.train.Feature(bytes_list=tf.train.BytesList(value=[image_data]))</span><br><span class="line">        &#125;</span><br><span class="line">        ))</span><br><span class="line"><span class="comment"># 将example序列化成string 类型，然后写入。</span></span><br><span class="line"> writer.write(example.SerializeToString())</span><br></pre></td></tr></table></figure><ul><li>解析</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 流式数据读取&amp;训练</span></span><br><span class="line"></span><br><span class="line">简介：起两个进程，一个数据读取进程源源不断的读多个文件到内存；一个计算进程从内存中读数并计算</span><br><span class="line"></span><br><span class="line"><span class="comment">## 流式读文件到内存</span></span><br><span class="line"></span><br><span class="line">为了方便管理，有**文件名队列**和**内存队列**</span><br><span class="line"></span><br><span class="line">- 文件名队列用tf.train.string_input_producer(文件名<span class="built_in">list</span>)函数产生文件名和结束标志的队列；可设置shuffle（决定小文件间有没有shuffle）和num_epoch（决定读多少次全部文件名<span class="built_in">list</span>）；</span><br><span class="line">- 读数据到内存队列用tf.WholeFileReader().read()读到内存队列</span><br><span class="line">- tf.train.start_queue_runners使整个线程开始运转</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20200422180419725</span>](/Users/hetianqi/Documents/charging/notes_of_the_world/tensorflow.assets/image-<span class="number">20200422180419725.</span>png)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 代码示例</span></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">file_name_list=[<span class="string">&#x27;a1.txt&#x27;</span>,<span class="string">&#x27;a2.txt&#x27;</span>,<span class="string">&#x27;a3.txt&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  <span class="comment"># 产生文件名队列</span></span><br><span class="line">  filename_queue = tf.train.string_input_producer(file_name_list,shuffle=<span class="literal">False</span>,num_epoch=<span class="number">5</span>)</span><br><span class="line">  <span class="comment"># reader从文件名队列中读数据。对应的方法是reader.read</span></span><br><span class="line">  reader = tf.WholeFileReader()</span><br><span class="line">  key , value = reader.read(filename_queue)</span><br><span class="line">  <span class="comment"># tf.train.string_input_producer定义了一个epoch变量，要对它进行初始化</span></span><br><span class="line">   tf.local_variables_initializer().run()</span><br><span class="line">   <span class="comment"># 使用start_queue_runners之后，才会开始填充队列</span></span><br><span class="line">   threads = tf.train.start_queue_runners(sess=sess)</span><br><span class="line">   i = <span class="number">0</span></span><br><span class="line">   <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment"># 内存队列检测到结束次数&gt;num_epochs时就会自动抛出一个异常（OutOfRange），从而停止读数</span></span><br><span class="line">       i += <span class="number">1</span> </span><br><span class="line">       <span class="comment"># 获取图片数据并保存</span></span><br><span class="line">       data = sess.run(value)</span><br></pre></td></tr></table></figure><h1 id="tensorboard"><a href="#tensorboard" class="headerlink" title="tensorboard"></a>tensorboard</h1><ol><li>cd到wirter文件夹的上层路径</li><li>执行以下命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir v0</span><br></pre></td></tr></table></figure><ol><li>打开<a href="http://localhost:6006/">http://localhost:6006/</a>  （terminal的路径不是这个的话依然打开这个路径。。。）</li></ol><h1 id="控制日志级别"><a href="#控制日志级别" class="headerlink" title="控制日志级别"></a>控制日志级别</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># logger = logging.getLogger(&quot;tensorflow&quot;)</span></span><br><span class="line"><span class="comment"># 貌似tensorflow的logger默认就有一个StreamHandler了</span></span><br><span class="line"><span class="comment"># 所以，首先判断len(logger.handlers)是否为1</span></span><br><span class="line"><span class="comment"># 如果为1的话， 说明只有默认的StreamHandler,</span></span><br><span class="line"><span class="comment"># 那么先清空handlers,然后再加入指定格式(formatter)的StreamHandler和FileHandler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_logger</span>():</span></span><br><span class="line">    logger = logging.getLogger(<span class="string">&quot;tensorflow&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(logger.handlers) == <span class="number">1</span>:</span><br><span class="line">        logger.handlers = []</span><br><span class="line">        logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">        formatter = logging.Formatter(</span><br><span class="line">            <span class="string">&quot;%(asctime)s - [%(filename)s:%(lineno)d] - %(name)s - %(levelname)s - %(message)s&quot;</span>)</span><br><span class="line">        ch = logging.StreamHandler(sys.stdout)</span><br><span class="line">        ch.setLevel(logging.DEBUG)</span><br><span class="line">        ch.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">        fh = logging.FileHandler(<span class="string">&#x27;tensorflow.log&#x27;</span>)</span><br><span class="line">        fh.setLevel(logging.DEBUG)</span><br><span class="line">        fh.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">        logger.addHandler(ch)</span><br><span class="line">        logger.addHandler(fh)</span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line">logger = set_logger()</span><br><span class="line">tf.logging.set_verbosity(tf.logging.INFO)</span><br></pre></td></tr></table></figure><p>日志等级：debug&lt;info&lt;warn&lt;error</p><h1 id="tf-identity-assign的区别"><a href="#tf-identity-assign的区别" class="headerlink" title="tf.identity,=,assign的区别"></a>tf.identity,=,assign的区别</h1><ul><li>tf.identity(变量引用)</li></ul><p>tf.identity在计算图内部创建了两个节点，send/recv节点，用来发送和接受两个变量，如果两个变量在不同的设备上，比如CPU和GPU，那么将会复制变量，如果在一个设备上，将会只是一个引用</p><ul><li><ul><li>引用变量：当遇到一个操作没有name这个参数的时候，可以用它来给该操作设置一个name，这样在模型测试阶段直接加载图模型，然后通过name来获取op</li><li>复制变量：不同设备(CPU\GPU)之间传递变量的值</li><li>作为一个虚拟节点来控制流程操作，一般配合tf.control_dependencies()使用</li></ul></li></ul><p><strong>Note：</strong>具体实例参考<a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/34877523/in-tensorflow-what-is-tf-identity-used-for">In TensorFlow, what is tf.identity used for?</a>中前三个回答</p><ul><li>=</li></ul><p>=只是拷贝内存，而y不会作为一个tensor在图中出现</p><p>如果希望y成为一个tensor出现在图中，=的右边必须是一个op，而遗憾的x是一个tensor，所以</p><p>需要利用tf.identity来告诉告诉编译器，y可以是一个和x一样的tensor。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">x = tf.Variable(<span class="number">1.0</span>)</span><br><span class="line">x_plus_1 = tf.assign_add(x, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">with</span> tf.control_dependencies([x_plus_1]):</span><br><span class="line">    y = x</span><br><span class="line">    <span class="comment">#y = tf.identity(x)</span></span><br><span class="line"></span><br><span class="line">init = tf.initialize_all_variables()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">    init.run()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;y=&#x27;</span>,y.<span class="built_in">eval</span>())</span><br><span class="line">        </span><br><span class="line"><span class="comment">#y= 1.0</span></span><br><span class="line"><span class="comment">#y= 1.0</span></span><br><span class="line"><span class="comment">#y= 1.0</span></span><br><span class="line"><span class="comment">#y= 1.0</span></span><br><span class="line"><span class="comment">#y= 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">x = tf.Variable(<span class="number">1.0</span>)</span><br><span class="line">x_plus_1 = tf.assign_add(x, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">with</span> tf.control_dependencies([x_plus_1]):</span><br><span class="line">    y = tf.identity(x)</span><br><span class="line"></span><br><span class="line">init = tf.initialize_all_variables()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">    init.run()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;y=&#x27;</span>,y.<span class="built_in">eval</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">#y= 2.0</span></span><br><span class="line"><span class="comment">#y= 3.0</span></span><br><span class="line"><span class="comment">#y= 4.0</span></span><br><span class="line"><span class="comment">#y= 5.0</span></span><br><span class="line"><span class="comment">#y= 6.0        </span></span><br></pre></td></tr></table></figure><h1 id="TensorFlow入门12-—-Checkpoints，保存和恢复Estimator创建的模型"><a href="#TensorFlow入门12-—-Checkpoints，保存和恢复Estimator创建的模型" class="headerlink" title="TensorFlow入门12 — Checkpoints，保存和恢复Estimator创建的模型"></a>TensorFlow入门12 — Checkpoints，保存和恢复Estimator创建的模型</h1><p>参考 <a href="https://www.jianshu.com/p/60c3b084fe44">https://www.jianshu.com/p/60c3b084fe44</a></p><p>模型训练好了后，下一步就是保存（Save）和恢复（restore）模型，TensorFlow提供两种模型格式（Model Format）</p><p>1，Checkpoints, 该格式依赖于创建模型的代码.</p><p>2，SavedModel, 该格式不依赖于创建模型的代码.</p><p>本文主要讨论检查点(Checkpoint).</p><p>如《<a href="https://www.jianshu.com/p/4e1d4bfd056d">从数据的角度理解TensorFlow鸢尾花分类程序6</a>》一文所述，在创建tf.estimator.DNNClassifier对象时，其构造函数<strong>init</strong>有一个参数：</p><p><strong>model_dir：</strong>保存模型参数的路径。（Directory to save model parameters, graph and etc. This can also be used to load checkpoints from the directory into a estimator to continue training a previously saved model.）</p><p>a.当没有指定的时候，Estimator 会将检查点文件写入由 Python 的 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.python.org%2F3%2Flibrary%2Ftempfile.html%23tempfile.mkdtemp">tempfile.mkdtemp</a>函数选择的临时目录中。用语句 print(tempfile.gettempdir())可以查出本机的临时目录</p><p><img src="https:////upload-images.jianshu.io/upload_images/10758717-617d15c988fca257.png?imageMogr2/auto-orient/strip|imageView2/2/w/704/format/webp" alt="img"></p><p>tempfile.gettempdir</p><p>b.当指定了目录的时候，例如：<em>model_dir = ‘models/iris’</em>，Estimator 会将检查点文件写入~/models/iris</p><p><img src="https:////upload-images.jianshu.io/upload_images/10758717-ede38dbd30efd3c9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1074/format/webp" alt="img"></p><p>有了保存检查点文件路径后，tf.estimator.DNNClassifier对象会在<strong>运行train方法的时候，写入检查点文件，</strong>如下图所示：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10758717-82fde1420900d6b5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p><p>train方法负责写入检查点文件</p><p><strong>那train方法以什么频率写入检查点文件呢？</strong></p><p>默认情况下，Estimator 按照以下时间安排将<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.google.com%2Fmachine-learning%2Fglossary%2F%23checkpoint">检查点</a>保存到 model_dir 中：</p><p>a.每 10 分钟（600 秒）写入一个检查点。</p><p>b.在 train 方法开始（第一次迭代）和完成（最后一次迭代）时写入一个检查点。</p><p>c.只在目录中保留 5 个最近写入的检查点。</p><p><strong>保存好检查点文件后，如何恢复模型呢？</strong></p><p>Estimator 将一个检查点保存到 model_dir 中后，每次调用 Estimator 的 train、eval 或 predict 方法时，都会发生下列情况：</p><p>a) Estimator 通过运行 model_fn() 构建模型<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdevelopers.google.com%2Fmachine-learning%2Fglossary%2F%23graph">图</a>。（要详细了解 model_fn()，请参阅<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.tensorflow.org%2Fget_started%2Fcustom_estimators">创建自定义 Estimator</a>。）</p><p>b) Estimator 根据最近写入的检查点中存储的数据来初始化新模型的权重。</p><p>换言之，如下图所示，一旦存在检查点，TensorFlow 就会在您每次调用 train()、evaluate() 或 predict() 时重建模型。</p><p><img src="https:////upload-images.jianshu.io/upload_images/10758717-d5376e32b383d1de.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p><p><strong>不当恢复</strong></p><p>通过检查点恢复模型的状态这一操作<strong>仅在模型和检查点兼容时可行</strong>。例如，假设训练了一个 tf.estimator.DNNClassifier，它包含 2 个隐藏层且每层都有 10 个节点；在训练之后（TensorFlow已在 models/iris 中创建检查点），将每个隐藏层中的神经元数量从 10 更改为 3，然后重新训练模型，由于检查点中的状态与 修改后tf.estimator.DNNClassifier 中描述的模型不兼容，因此重新训练失败并出现以下错误，如下图所示：</p><p><img src="https:////upload-images.jianshu.io/upload_images/10758717-66ba8e48437be765.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/976/format/webp" alt="img"></p><p>不当恢复</p><p><strong>解决不当恢复</strong></p><p>1，当模型参数一直在变化的时候，最简单的方式是，不要指定<em>model_dir，</em>这样TensorFlow不会启动Checkpoint模型恢复，方便你随时修改模型。</p><p>2，启动Checkpoint的情况下，用Git为每个 model-dir 所需的代码保存一个副本，即为每个模型版本创建一个单独的 git 分支。这种区分将有助于保证检查点的可恢复性。</p><p><strong>总结</strong>：检查点提供了一种简单的自动机制来保存和恢复由 Estimator 创建的模型。</p><h1 id="分布式训练"><a href="#分布式训练" class="headerlink" title="分布式训练"></a>分布式训练</h1><ul><li>ps: Parameter Sever, 参数服务器</li><li>chief: ps-worker架构中的主节点</li><li>worker: 正常训练节点</li><li>evaluator: 评估节点，不参与训练，只用来进行训练数据评估</li></ul><h1 id="记录timeline-tf-train-ProfilerHook"><a href="#记录timeline-tf-train-ProfilerHook" class="headerlink" title="记录timeline-tf.train.ProfilerHook"></a>记录timeline-tf.train.ProfilerHook</h1><p>通过ProfilerHook对tensor代码中的各个节点耗时情况进行分析</p><p><a href="https://zhuanlan.zhihu.com/p/147319531">https://zhuanlan.zhihu.com/p/147319531</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_and_eval</span>(<span class="params">model</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param model: 声明的estimator实例</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    :usage: 进行模型训练，并在指定步长的时候进行结果评估</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    timeline_hook = tf.train.ProfilerHook(save_steps=<span class="number">100</span>, output_dir=os.path.join(</span><br><span class="line">            os.getcwd(), <span class="string">&#x27;./timeline_track&#x27;</span></span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">    hook = tf.contrib.estimator.stop_if_no_increase_hook(</span><br><span class="line">        model,</span><br><span class="line">        metric_name=<span class="string">&#x27;ctcvr_cvr_auc_esmm&#x27;</span>,</span><br><span class="line">        max_steps_without_increase=configuration_params[<span class="string">&#x27;max_steps_without_increase&#x27;</span>],</span><br><span class="line">        <span class="comment"># maximum number of training steps with no decrease in the given metric.</span></span><br><span class="line">        min_steps=configuration_params[<span class="string">&#x27;min_steps&#x27;</span>],  <span class="comment"># stop is never requested if global step is less than this value</span></span><br><span class="line">        run_every_steps=configuration_params[<span class="string">&#x27;run_every_steps&#x27;</span>],</span><br><span class="line">        run_every_secs=<span class="literal">None</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    train_spec = tf.estimator.TrainSpec(</span><br><span class="line">        input_fn=<span class="keyword">lambda</span>: input_fn(os.path.join(os.getcwd(),</span><br><span class="line">                                               CONFIG_TRAIN[<span class="string">&#x27;train_data&#x27;</span>]),</span><br><span class="line">                                  <span class="string">&#x27;train&#x27;</span>, CONFIG_TRAIN[<span class="string">&#x27;batch_size&#x27;</span>]),</span><br><span class="line">        hooks=[hook, timeline_hook]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    eval_spec = tf.estimator.EvalSpec(</span><br><span class="line">        input_fn=<span class="keyword">lambda</span>: input_fn(os.path.join(os.getcwd(),</span><br><span class="line">                                               CONFIG_TRAIN[<span class="string">&#x27;test_data&#x27;</span>]),</span><br><span class="line">                                  <span class="string">&#x27;eval&#x27;</span>, <span class="number">128</span>),</span><br><span class="line">        steps=CONFIG.evalconfig[<span class="string">&#x27;steps&#x27;</span>],</span><br><span class="line">        throttle_secs=<span class="number">30</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    tf.estimator.train_and_evaluate(model, train_spec, eval_spec)</span><br></pre></td></tr></table></figure><p>timeline.json：每个保存步长输出的监控文件</p><ul><li><p>web展示</p><ol><li><p>在chrome中打开“chome://tracing”页面</p><p><img src="https://pic4.zhimg.com/80/v2-cfed5df9f0c6ae2d180e7b8c65ed233b_720w.jpg" alt="img"></p></li></ol></li></ul><ul><li><ul><li>点击“load”，将上一步中生成time-line.json文件导入，导入任意一个即可</li><li>输出结果如下：</li></ul></li></ul><p><img src="https://pic2.zhimg.com/80/v2-5dd2ee82f762b8fa9ef2a64e631f9cf1_720w.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Tensorflow笔记&quot;&gt;&lt;a href=&quot;#Tensorflow笔记&quot; class=&quot;headerlink&quot; title=&quot;Tensorflow笔记&quot;&gt;&lt;/a&gt;Tensorflow笔记&lt;/h1&gt;&lt;h1 id=&quot;name-scope-V
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wangdongdong122.github.io/2020/12/08/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/pandas%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://wangdongdong122.github.io/2020/12/08/0_代码相关/pandas常用命令/</id>
    <published>2020-12-08T01:29:22.000Z</published>
    <updated>2020-12-08T01:29:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="10-minutes-to-pandas"><a href="#10-minutes-to-pandas" class="headerlink" title="10 minutes to pandas"></a>10 minutes to pandas</h1><p>This is a short introduction to pandas, geared mainly for new users. You can see more complex recipes in the <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/cookbook.html#cookbook">Cookbook</a>.</p><p>Customarily, we import as follows:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import numpy as np</span><br><span class="line"></span><br><span class="line">In [2]: import pandas as pd</span><br></pre></td></tr></table></figure><h2 id="Object-creation"><a href="#Object-creation" class="headerlink" title="Object creation"></a>Object creation</h2><p>See the <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html#dsintro">Data Structure Intro section</a>.</p><p>Creating a <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas.Series"><code>Series</code></a> by passing a list of values, letting pandas create a default integer index:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [3]: s = pd.Series([1, 3, 5, np.nan, 6, 8])</span><br><span class="line"></span><br><span class="line">In [4]: s</span><br><span class="line">Out[4]: </span><br><span class="line">0    1.0</span><br><span class="line">1    3.0</span><br><span class="line">2    5.0</span><br><span class="line">3    NaN</span><br><span class="line">4    6.0</span><br><span class="line">5    8.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>Creating a <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>DataFrame</code></a> by passing a NumPy array, with a datetime index and labeled columns:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [5]: dates = pd.date_range(&#x27;20130101&#x27;, periods=6)</span><br><span class="line"></span><br><span class="line">In [6]: dates</span><br><span class="line">Out[6]: </span><br><span class="line">DatetimeIndex([&#x27;2013-01-01&#x27;, &#x27;2013-01-02&#x27;, &#x27;2013-01-03&#x27;, &#x27;2013-01-04&#x27;,</span><br><span class="line">               &#x27;2013-01-05&#x27;, &#x27;2013-01-06&#x27;],</span><br><span class="line">              dtype=&#x27;datetime64[ns]&#x27;, freq=&#x27;D&#x27;)</span><br><span class="line"></span><br><span class="line">In [7]: df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list(&#x27;ABCD&#x27;))</span><br><span class="line"></span><br><span class="line">In [8]: df</span><br><span class="line">Out[8]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232 -1.087401</span><br><span class="line">2013-01-06 -0.673690  0.113648 -1.478427  0.524988</span><br></pre></td></tr></table></figure><p>Creating a <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>DataFrame</code></a> by passing a dict of objects that can be converted to series-like.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [9]: df2 = pd.DataFrame(&#123;&#x27;A&#x27;: 1.,</span><br><span class="line">   ...:                     &#x27;B&#x27;: pd.Timestamp(&#x27;20130102&#x27;),</span><br><span class="line">   ...:                     &#x27;C&#x27;: pd.Series(1, index=list(range(4)), dtype=&#x27;float32&#x27;),</span><br><span class="line">   ...:                     &#x27;D&#x27;: np.array([3] * 4, dtype=&#x27;int32&#x27;),</span><br><span class="line">   ...:                     &#x27;E&#x27;: pd.Categorical([&quot;test&quot;, &quot;train&quot;, &quot;test&quot;, &quot;train&quot;]),</span><br><span class="line">   ...:                     &#x27;F&#x27;: &#x27;foo&#x27;&#125;)</span><br><span class="line">   ...: </span><br><span class="line"></span><br><span class="line">In [10]: df2</span><br><span class="line">Out[10]: </span><br><span class="line">     A          B    C  D      E    F</span><br><span class="line">0  1.0 2013-01-02  1.0  3   test  foo</span><br><span class="line">1  1.0 2013-01-02  1.0  3  train  foo</span><br><span class="line">2  1.0 2013-01-02  1.0  3   test  foo</span><br><span class="line">3  1.0 2013-01-02  1.0  3  train  foo</span><br></pre></td></tr></table></figure><p>The columns of the resulting <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>DataFrame</code></a> have different <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#basics-dtypes">dtypes</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [11]: df2.dtypes</span><br><span class="line">Out[11]: </span><br><span class="line">A           float64</span><br><span class="line">B    datetime64[ns]</span><br><span class="line">C           float32</span><br><span class="line">D             int32</span><br><span class="line">E          category</span><br><span class="line">F            object</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><p>If you’re using IPython, tab completion for column names (as well as public attributes) is automatically enabled. Here’s a subset of the attributes that will be completed:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [12]: df2.&lt;TAB&gt;  # noqa: E225, E999</span><br><span class="line">df2.A                  df2.bool</span><br><span class="line">df2.abs                df2.boxplot</span><br><span class="line">df2.add                df2.C</span><br><span class="line">df2.add_prefix         df2.clip</span><br><span class="line">df2.add_suffix         df2.columns</span><br><span class="line">df2.align              df2.copy</span><br><span class="line">df2.all                df2.count</span><br><span class="line">df2.any                df2.combine</span><br><span class="line">df2.append             df2.D</span><br><span class="line">df2.apply              df2.describe</span><br><span class="line">df2.applymap           df2.diff</span><br><span class="line">df2.B                  df2.duplicated</span><br></pre></td></tr></table></figure><p>As you can see, the columns <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code> are automatically tab completed. <code>E</code> and <code>F</code> are there as well; the rest of the attributes have been truncated for brevity.</p><h2 id="Viewing-data"><a href="#Viewing-data" class="headerlink" title="Viewing data"></a>Viewing data</h2><p>See the <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#basics">Basics section</a>.</p><p>Here is how to view the top and bottom rows of the frame:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [13]: df.head()</span><br><span class="line">Out[13]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232 -1.087401</span><br><span class="line"></span><br><span class="line">In [14]: df.tail(3)</span><br><span class="line">Out[14]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232 -1.087401</span><br><span class="line">2013-01-06 -0.673690  0.113648 -1.478427  0.524988</span><br></pre></td></tr></table></figure><p>Display the index, columns:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [15]: df.index</span><br><span class="line">Out[15]: </span><br><span class="line">DatetimeIndex([&#x27;2013-01-01&#x27;, &#x27;2013-01-02&#x27;, &#x27;2013-01-03&#x27;, &#x27;2013-01-04&#x27;,</span><br><span class="line">               &#x27;2013-01-05&#x27;, &#x27;2013-01-06&#x27;],</span><br><span class="line">              dtype=&#x27;datetime64[ns]&#x27;, freq=&#x27;D&#x27;)</span><br><span class="line"></span><br><span class="line">In [16]: df.columns</span><br><span class="line">Out[16]: Index([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;], dtype=&#x27;object&#x27;)</span><br></pre></td></tr></table></figure><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy"><code>DataFrame.to_numpy()</code></a> gives a NumPy representation of the underlying data. Note that this can be an expensive operation when your <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>DataFrame</code></a> has columns with different data types, which comes down to a fundamental difference between pandas and NumPy: <strong>NumPy arrays have one dtype for the entire array, while pandas DataFrames have one dtype per column</strong>. When you call <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy"><code>DataFrame.to_numpy()</code></a>, pandas will find the NumPy dtype that can hold <em>all</em> of the dtypes in the DataFrame. This may end up being <code>object</code>, which requires casting every value to a Python object.</p><p>For <code>df</code>, our <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>DataFrame</code></a> of all floating-point values, <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy"><code>DataFrame.to_numpy()</code></a> is fast and doesn’t require copying data.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [17]: df.to_numpy()</span><br><span class="line">Out[17]: </span><br><span class="line">array([[ 0.4691, -0.2829, -1.5091, -1.1356],</span><br><span class="line">       [ 1.2121, -0.1732,  0.1192, -1.0442],</span><br><span class="line">       [-0.8618, -2.1046, -0.4949,  1.0718],</span><br><span class="line">       [ 0.7216, -0.7068, -1.0396,  0.2719],</span><br><span class="line">       [-0.425 ,  0.567 ,  0.2762, -1.0874],</span><br><span class="line">       [-0.6737,  0.1136, -1.4784,  0.525 ]])</span><br></pre></td></tr></table></figure><p>For <code>df2</code>, the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>DataFrame</code></a> with multiple dtypes, <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy"><code>DataFrame.to_numpy()</code></a> is relatively expensive.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [18]: df2.to_numpy()</span><br><span class="line">Out[18]: </span><br><span class="line">array([[1.0, Timestamp(&#x27;2013-01-02 00:00:00&#x27;), 1.0, 3, &#x27;test&#x27;, &#x27;foo&#x27;],</span><br><span class="line">       [1.0, Timestamp(&#x27;2013-01-02 00:00:00&#x27;), 1.0, 3, &#x27;train&#x27;, &#x27;foo&#x27;],</span><br><span class="line">       [1.0, Timestamp(&#x27;2013-01-02 00:00:00&#x27;), 1.0, 3, &#x27;test&#x27;, &#x27;foo&#x27;],</span><br><span class="line">       [1.0, Timestamp(&#x27;2013-01-02 00:00:00&#x27;), 1.0, 3, &#x27;train&#x27;, &#x27;foo&#x27;]],</span><br><span class="line">      dtype=object)</span><br></pre></td></tr></table></figure><p>Note</p><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy"><code>DataFrame.to_numpy()</code></a> does <em>not</em> include the index or column labels in the output.</p><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe"><code>describe()</code></a> shows a quick statistic summary of your data:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [19]: df.describe()</span><br><span class="line">Out[19]: </span><br><span class="line">              A         B         C         D</span><br><span class="line">count  6.000000  6.000000  6.000000  6.000000</span><br><span class="line">mean   0.073711 -0.431125 -0.687758 -0.233103</span><br><span class="line">std    0.843157  0.922818  0.779887  0.973118</span><br><span class="line">min   -0.861849 -2.104569 -1.509059 -1.135632</span><br><span class="line">25%   -0.611510 -0.600794 -1.368714 -1.076610</span><br><span class="line">50%    0.022070 -0.228039 -0.767252 -0.386188</span><br><span class="line">75%    0.658444  0.041933 -0.034326  0.461706</span><br><span class="line">max    1.212112  0.567020  0.276232  1.071804</span><br></pre></td></tr></table></figure><p>Transposing your data:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [20]: df.T</span><br><span class="line">Out[20]: </span><br><span class="line">   2013-01-01  2013-01-02  2013-01-03  2013-01-04  2013-01-05  2013-01-06</span><br><span class="line">A    0.469112    1.212112   -0.861849    0.721555   -0.424972   -0.673690</span><br><span class="line">B   -0.282863   -0.173215   -2.104569   -0.706771    0.567020    0.113648</span><br><span class="line">C   -1.509059    0.119209   -0.494929   -1.039575    0.276232   -1.478427</span><br><span class="line">D   -1.135632   -1.044236    1.071804    0.271860   -1.087401    0.524988</span><br></pre></td></tr></table></figure><p>Sorting by an axis:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [21]: df.sort_index(axis=1, ascending=False)</span><br><span class="line">Out[21]: </span><br><span class="line">                   D         C         B         A</span><br><span class="line">2013-01-01 -1.135632 -1.509059 -0.282863  0.469112</span><br><span class="line">2013-01-02 -1.044236  0.119209 -0.173215  1.212112</span><br><span class="line">2013-01-03  1.071804 -0.494929 -2.104569 -0.861849</span><br><span class="line">2013-01-04  0.271860 -1.039575 -0.706771  0.721555</span><br><span class="line">2013-01-05 -1.087401  0.276232  0.567020 -0.424972</span><br><span class="line">2013-01-06  0.524988 -1.478427  0.113648 -0.673690</span><br></pre></td></tr></table></figure><p>Sorting by values:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [22]: df.sort_values(by=&#x27;B&#x27;)</span><br><span class="line">Out[22]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span><br><span class="line">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-06 -0.673690  0.113648 -1.478427  0.524988</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232 -1.087401</span><br></pre></td></tr></table></figure><h2 id="Selection"><a href="#Selection" class="headerlink" title="Selection"></a>Selection</h2><p>Note</p><p>While standard Python / Numpy expressions for selecting and setting are intuitive and come in handy for interactive work, for production code, we recommend the optimized pandas data access methods, <code>.at</code>, <code>.iat</code>, <code>.loc</code> and <code>.iloc</code>.</p><p>See the indexing documentation <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#indexing">Indexing and Selecting Data</a> and <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html#advanced">MultiIndex / Advanced Indexing</a>.</p><h3 id="Getting"><a href="#Getting" class="headerlink" title="Getting"></a>Getting</h3><p>Selecting a single column, which yields a <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas.Series"><code>Series</code></a>, equivalent to <code>df.A</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [23]: df[&#x27;A&#x27;]</span><br><span class="line">Out[23]: </span><br><span class="line">2013-01-01    0.469112</span><br><span class="line">2013-01-02    1.212112</span><br><span class="line">2013-01-03   -0.861849</span><br><span class="line">2013-01-04    0.721555</span><br><span class="line">2013-01-05   -0.424972</span><br><span class="line">2013-01-06   -0.673690</span><br><span class="line">Freq: D, Name: A, dtype: float64</span><br></pre></td></tr></table></figure><p>Selecting via <code>[]</code>, which slices the rows.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [24]: df[0:3]</span><br><span class="line">Out[24]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span><br><span class="line"></span><br><span class="line">In [25]: df[&#x27;20130102&#x27;:&#x27;20130104&#x27;]</span><br><span class="line">Out[25]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span><br></pre></td></tr></table></figure><h3 id="Selection-by-label"><a href="#Selection-by-label" class="headerlink" title="Selection by label"></a>Selection by label</h3><p>See more in <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#indexing-label">Selection by Label</a>.</p><p>For getting a cross section using a label:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [26]: df.loc[dates[0]]</span><br><span class="line">Out[26]: </span><br><span class="line">A    0.469112</span><br><span class="line">B   -0.282863</span><br><span class="line">C   -1.509059</span><br><span class="line">D   -1.135632</span><br><span class="line">Name: 2013-01-01 00:00:00, dtype: float64</span><br></pre></td></tr></table></figure><p>Selecting on a multi-axis by label:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [27]: df.loc[:, [&#x27;A&#x27;, &#x27;B&#x27;]]</span><br><span class="line">Out[27]: </span><br><span class="line">                   A         B</span><br><span class="line">2013-01-01  0.469112 -0.282863</span><br><span class="line">2013-01-02  1.212112 -0.173215</span><br><span class="line">2013-01-03 -0.861849 -2.104569</span><br><span class="line">2013-01-04  0.721555 -0.706771</span><br><span class="line">2013-01-05 -0.424972  0.567020</span><br><span class="line">2013-01-06 -0.673690  0.113648</span><br></pre></td></tr></table></figure><p>Showing label slicing, both endpoints are <em>included</em>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [28]: df.loc[&#x27;20130102&#x27;:&#x27;20130104&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;]]</span><br><span class="line">Out[28]: </span><br><span class="line">                   A         B</span><br><span class="line">2013-01-02  1.212112 -0.173215</span><br><span class="line">2013-01-03 -0.861849 -2.104569</span><br><span class="line">2013-01-04  0.721555 -0.706771</span><br></pre></td></tr></table></figure><p>Reduction in the dimensions of the returned object:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [29]: df.loc[&#x27;20130102&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;]]</span><br><span class="line">Out[29]: </span><br><span class="line">A    1.212112</span><br><span class="line">B   -0.173215</span><br><span class="line">Name: 2013-01-02 00:00:00, dtype: float64</span><br></pre></td></tr></table></figure><p>For getting a scalar value:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [30]: df.loc[dates[0], &#x27;A&#x27;]</span><br><span class="line">Out[30]: 0.4691122999071863</span><br></pre></td></tr></table></figure><p>For getting fast access to a scalar (equivalent to the prior method):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [31]: df.at[dates[0], &#x27;A&#x27;]</span><br><span class="line">Out[31]: 0.4691122999071863</span><br></pre></td></tr></table></figure><h3 id="Selection-by-position"><a href="#Selection-by-position" class="headerlink" title="Selection by position"></a>Selection by position</h3><p>See more in <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#indexing-integer">Selection by Position</a>.</p><p>Select via the position of the passed integers:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [32]: df.iloc[3]</span><br><span class="line">Out[32]: </span><br><span class="line">A    0.721555</span><br><span class="line">B   -0.706771</span><br><span class="line">C   -1.039575</span><br><span class="line">D    0.271860</span><br><span class="line">Name: 2013-01-04 00:00:00, dtype: float64</span><br></pre></td></tr></table></figure><p>By integer slices, acting similar to numpy/python:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [33]: df.iloc[3:5, 0:2]</span><br><span class="line">Out[33]: </span><br><span class="line">                   A         B</span><br><span class="line">2013-01-04  0.721555 -0.706771</span><br><span class="line">2013-01-05 -0.424972  0.567020</span><br></pre></td></tr></table></figure><p>By lists of integer position locations, similar to the numpy/python style:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [34]: df.iloc[[1, 2, 4], [0, 2]]</span><br><span class="line">Out[34]: </span><br><span class="line">                   A         C</span><br><span class="line">2013-01-02  1.212112  0.119209</span><br><span class="line">2013-01-03 -0.861849 -0.494929</span><br><span class="line">2013-01-05 -0.424972  0.276232</span><br></pre></td></tr></table></figure><p>For slicing rows explicitly:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [35]: df.iloc[1:3, :]</span><br><span class="line">Out[35]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804</span><br></pre></td></tr></table></figure><p>For slicing columns explicitly:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [36]: df.iloc[:, 1:3]</span><br><span class="line">Out[36]: </span><br><span class="line">                   B         C</span><br><span class="line">2013-01-01 -0.282863 -1.509059</span><br><span class="line">2013-01-02 -0.173215  0.119209</span><br><span class="line">2013-01-03 -2.104569 -0.494929</span><br><span class="line">2013-01-04 -0.706771 -1.039575</span><br><span class="line">2013-01-05  0.567020  0.276232</span><br><span class="line">2013-01-06  0.113648 -1.478427</span><br></pre></td></tr></table></figure><p>For getting a value explicitly:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [37]: df.iloc[1, 1]</span><br><span class="line">Out[37]: -0.17321464905330858</span><br></pre></td></tr></table></figure><p>For getting fast access to a scalar (equivalent to the prior method):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [38]: df.iat[1, 1]</span><br><span class="line">Out[38]: -0.17321464905330858</span><br></pre></td></tr></table></figure><h3 id="Boolean-indexing"><a href="#Boolean-indexing" class="headerlink" title="Boolean indexing"></a>Boolean indexing</h3><p>Using a single column’s values to select data.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [39]: df[df[&#x27;A&#x27;] &gt; 0]</span><br><span class="line">Out[39]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860</span><br></pre></td></tr></table></figure><p>Selecting values from a DataFrame where a boolean condition is met.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [40]: df[df &gt; 0]</span><br><span class="line">Out[40]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line">2013-01-01  0.469112       NaN       NaN       NaN</span><br><span class="line">2013-01-02  1.212112       NaN  0.119209       NaN</span><br><span class="line">2013-01-03       NaN       NaN       NaN  1.071804</span><br><span class="line">2013-01-04  0.721555       NaN       NaN  0.271860</span><br><span class="line">2013-01-05       NaN  0.567020  0.276232       NaN</span><br><span class="line">2013-01-06       NaN  0.113648       NaN  0.524988</span><br></pre></td></tr></table></figure><p>Using the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.isin.html#pandas.Series.isin"><code>isin()</code></a> method for filtering:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [41]: df2 = df.copy()</span><br><span class="line"></span><br><span class="line">In [42]: df2[&#x27;E&#x27;] = [&#x27;one&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;three&#x27;]</span><br><span class="line"></span><br><span class="line">In [43]: df2</span><br><span class="line">Out[43]: </span><br><span class="line">                   A         B         C         D      E</span><br><span class="line">2013-01-01  0.469112 -0.282863 -1.509059 -1.135632    one</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209 -1.044236    one</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804    two</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  0.271860  three</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232 -1.087401   four</span><br><span class="line">2013-01-06 -0.673690  0.113648 -1.478427  0.524988  three</span><br><span class="line"></span><br><span class="line">In [44]: df2[df2[&#x27;E&#x27;].isin([&#x27;two&#x27;, &#x27;four&#x27;])]</span><br><span class="line">Out[44]: </span><br><span class="line">                   A         B         C         D     E</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  1.071804   two</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232 -1.087401  four</span><br></pre></td></tr></table></figure><h3 id="Setting"><a href="#Setting" class="headerlink" title="Setting"></a>Setting</h3><p>Setting a new column automatically aligns the data by the indexes.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [45]: s1 = pd.Series([1, 2, 3, 4, 5, 6], index=pd.date_range(&#x27;20130102&#x27;, periods=6))</span><br><span class="line"></span><br><span class="line">In [46]: s1</span><br><span class="line">Out[46]: </span><br><span class="line">2013-01-02    1</span><br><span class="line">2013-01-03    2</span><br><span class="line">2013-01-04    3</span><br><span class="line">2013-01-05    4</span><br><span class="line">2013-01-06    5</span><br><span class="line">2013-01-07    6</span><br><span class="line">Freq: D, dtype: int64</span><br><span class="line"></span><br><span class="line">In [47]: df[&#x27;F&#x27;] = s1</span><br></pre></td></tr></table></figure><p>Setting values by label:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [48]: df.at[dates[0], &#x27;A&#x27;] = 0</span><br></pre></td></tr></table></figure><p>Setting values by position:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [49]: df.iat[0, 1] = 0</span><br></pre></td></tr></table></figure><p>Setting by assigning with a NumPy array:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [50]: df.loc[:, &#x27;D&#x27;] = np.array([5] * len(df))</span><br></pre></td></tr></table></figure><p>The result of the prior setting operations.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [51]: df</span><br><span class="line">Out[51]: </span><br><span class="line">                   A         B         C  D    F</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059  5  NaN</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209  5  1.0</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  5  3.0</span><br><span class="line">2013-01-05 -0.424972  0.567020  0.276232  5  4.0</span><br><span class="line">2013-01-06 -0.673690  0.113648 -1.478427  5  5.0</span><br></pre></td></tr></table></figure><p>A <code>where</code> operation with setting.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [52]: df2 = df.copy()</span><br><span class="line"></span><br><span class="line">In [53]: df2[df2 &gt; 0] = -df2</span><br><span class="line"></span><br><span class="line">In [54]: df2</span><br><span class="line">Out[54]: </span><br><span class="line">                   A         B         C  D    F</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059 -5  NaN</span><br><span class="line">2013-01-02 -1.212112 -0.173215 -0.119209 -5 -1.0</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929 -5 -2.0</span><br><span class="line">2013-01-04 -0.721555 -0.706771 -1.039575 -5 -3.0</span><br><span class="line">2013-01-05 -0.424972 -0.567020 -0.276232 -5 -4.0</span><br><span class="line">2013-01-06 -0.673690 -0.113648 -1.478427 -5 -5.0</span><br></pre></td></tr></table></figure><h2 id="Missing-data"><a href="#Missing-data" class="headerlink" title="Missing data"></a>Missing data</h2><p>pandas primarily uses the value <code>np.nan</code> to represent missing data. It is by default not included in computations. See the <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html#missing-data">Missing Data section</a>.</p><p>Reindexing allows you to change/add/delete the index on a specified axis. This returns a copy of the data.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [55]: df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + [&#x27;E&#x27;])</span><br><span class="line"></span><br><span class="line">In [56]: df1.loc[dates[0]:dates[1], &#x27;E&#x27;] = 1</span><br><span class="line"></span><br><span class="line">In [57]: df1</span><br><span class="line">Out[57]: </span><br><span class="line">                   A         B         C  D    F    E</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059  5  NaN  1.0</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0  NaN</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  5  3.0  NaN</span><br></pre></td></tr></table></figure><p>To drop any rows that have missing data.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [58]: df1.dropna(how=&#x27;any&#x27;)</span><br><span class="line">Out[58]: </span><br><span class="line">                   A         B         C  D    F    E</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0</span><br></pre></td></tr></table></figure><p>Filling missing data.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [59]: df1.fillna(value=5)</span><br><span class="line">Out[59]: </span><br><span class="line">                   A         B         C  D    F    E</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059  5  5.0  1.0</span><br><span class="line">2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0</span><br><span class="line">2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0  5.0</span><br><span class="line">2013-01-04  0.721555 -0.706771 -1.039575  5  3.0  5.0</span><br></pre></td></tr></table></figure><p>To get the boolean mask where values are <code>nan</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [60]: pd.isna(df1)</span><br><span class="line">Out[60]: </span><br><span class="line">                A      B      C      D      F      E</span><br><span class="line">2013-01-01  False  False  False  False   True  False</span><br><span class="line">2013-01-02  False  False  False  False  False  False</span><br><span class="line">2013-01-03  False  False  False  False  False   True</span><br><span class="line">2013-01-04  False  False  False  False  False   True</span><br></pre></td></tr></table></figure><h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2><p>See the <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#basics-binop">Basic section on Binary Ops</a>.</p><h3 id="Stats"><a href="#Stats" class="headerlink" title="Stats"></a>Stats</h3><p>Operations in general <em>exclude</em> missing data.</p><p>Performing a descriptive statistic:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [61]: df.mean()</span><br><span class="line">Out[61]: </span><br><span class="line">A   -0.004474</span><br><span class="line">B   -0.383981</span><br><span class="line">C   -0.687758</span><br><span class="line">D    5.000000</span><br><span class="line">F    3.000000</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>Same operation on the other axis:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [62]: df.mean(1)</span><br><span class="line">Out[62]: </span><br><span class="line">2013-01-01    0.872735</span><br><span class="line">2013-01-02    1.431621</span><br><span class="line">2013-01-03    0.707731</span><br><span class="line">2013-01-04    1.395042</span><br><span class="line">2013-01-05    1.883656</span><br><span class="line">2013-01-06    1.592306</span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure><p>Operating with objects that have different dimensionality and need alignment. In addition, pandas automatically broadcasts along the specified dimension.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [63]: s = pd.Series([1, 3, 5, np.nan, 6, 8], index=dates).shift(2)</span><br><span class="line"></span><br><span class="line">In [64]: s</span><br><span class="line">Out[64]: </span><br><span class="line">2013-01-01    NaN</span><br><span class="line">2013-01-02    NaN</span><br><span class="line">2013-01-03    1.0</span><br><span class="line">2013-01-04    3.0</span><br><span class="line">2013-01-05    5.0</span><br><span class="line">2013-01-06    NaN</span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [65]: df.sub(s, axis=&#x27;index&#x27;)</span><br><span class="line">Out[65]: </span><br><span class="line">                   A         B         C    D    F</span><br><span class="line">2013-01-01       NaN       NaN       NaN  NaN  NaN</span><br><span class="line">2013-01-02       NaN       NaN       NaN  NaN  NaN</span><br><span class="line">2013-01-03 -1.861849 -3.104569 -1.494929  4.0  1.0</span><br><span class="line">2013-01-04 -2.278445 -3.706771 -4.039575  2.0  0.0</span><br><span class="line">2013-01-05 -5.424972 -4.432980 -4.723768  0.0 -1.0</span><br><span class="line">2013-01-06       NaN       NaN       NaN  NaN  NaN</span><br></pre></td></tr></table></figure><h3 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h3><p>Applying functions to the data:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [66]: df.apply(np.cumsum)</span><br><span class="line">Out[66]: </span><br><span class="line">                   A         B         C   D     F</span><br><span class="line">2013-01-01  0.000000  0.000000 -1.509059   5   NaN</span><br><span class="line">2013-01-02  1.212112 -0.173215 -1.389850  10   1.0</span><br><span class="line">2013-01-03  0.350263 -2.277784 -1.884779  15   3.0</span><br><span class="line">2013-01-04  1.071818 -2.984555 -2.924354  20   6.0</span><br><span class="line">2013-01-05  0.646846 -2.417535 -2.648122  25  10.0</span><br><span class="line">2013-01-06 -0.026844 -2.303886 -4.126549  30  15.0</span><br><span class="line"></span><br><span class="line">In [67]: df.apply(lambda x: x.max() - x.min())</span><br><span class="line">Out[67]: </span><br><span class="line">A    2.073961</span><br><span class="line">B    2.671590</span><br><span class="line">C    1.785291</span><br><span class="line">D    0.000000</span><br><span class="line">F    4.000000</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><h3 id="Histogramming"><a href="#Histogramming" class="headerlink" title="Histogramming"></a>Histogramming</h3><p>See more at <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#basics-discretization">Histogramming and Discretization</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [68]: s = pd.Series(np.random.randint(0, 7, size=10))</span><br><span class="line"></span><br><span class="line">In [69]: s</span><br><span class="line">Out[69]: </span><br><span class="line">0    4</span><br><span class="line">1    2</span><br><span class="line">2    1</span><br><span class="line">3    2</span><br><span class="line">4    6</span><br><span class="line">5    4</span><br><span class="line">6    4</span><br><span class="line">7    6</span><br><span class="line">8    4</span><br><span class="line">9    4</span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [70]: s.value_counts()</span><br><span class="line">Out[70]: </span><br><span class="line">4    5</span><br><span class="line">6    2</span><br><span class="line">2    2</span><br><span class="line">1    1</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h3 id="String-Methods"><a href="#String-Methods" class="headerlink" title="String Methods"></a>String Methods</h3><p>Series is equipped with a set of string processing methods in the str attribute that make it easy to operate on each element of the array, as in the code snippet below. Note that pattern-matching in str generally uses <a href="https://docs.python.org/3/library/re.html">regular expressions</a> by default (and in some cases always uses them). See more at <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html#text-string-methods">Vectorized String Methods</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [71]: s = pd.Series([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;Aaba&#x27;, &#x27;Baca&#x27;, np.nan, &#x27;CABA&#x27;, &#x27;dog&#x27;, &#x27;cat&#x27;])</span><br><span class="line"></span><br><span class="line">In [72]: s.str.lower()</span><br><span class="line">Out[72]: </span><br><span class="line">0       a</span><br><span class="line">1       b</span><br><span class="line">2       c</span><br><span class="line">3    aaba</span><br><span class="line">4    baca</span><br><span class="line">5     NaN</span><br><span class="line">6    caba</span><br><span class="line">7     dog</span><br><span class="line">8     cat</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h2><h3 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h3><p>pandas provides various facilities for easily combining together Series and DataFrame objects with various kinds of set logic for the indexes and relational algebra functionality in the case of join / merge-type operations.</p><p>See the <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html#merging">Merging section</a>.</p><p>Concatenating pandas objects together with <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html#pandas.concat"><code>concat()</code></a>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">In [73]: df = pd.DataFrame(np.random.randn(10, 4))</span><br><span class="line"></span><br><span class="line">In [74]: df</span><br><span class="line">Out[74]: </span><br><span class="line">          0         1         2         3</span><br><span class="line">0 -0.548702  1.467327 -1.015962 -0.483075</span><br><span class="line">1  1.637550 -1.217659 -0.291519 -1.745505</span><br><span class="line">2 -0.263952  0.991460 -0.919069  0.266046</span><br><span class="line">3 -0.709661  1.669052  1.037882 -1.705775</span><br><span class="line">4 -0.919854 -0.042379  1.247642 -0.009920</span><br><span class="line">5  0.290213  0.495767  0.362949  1.548106</span><br><span class="line">6 -1.131345 -0.089329  0.337863 -0.945867</span><br><span class="line">7 -0.932132  1.956030  0.017587 -0.016692</span><br><span class="line">8 -0.575247  0.254161 -1.143704  0.215897</span><br><span class="line">9  1.193555 -0.077118 -0.408530 -0.862495</span><br><span class="line"></span><br><span class="line"># break it into pieces</span><br><span class="line">In [75]: pieces = [df[:3], df[3:7], df[7:]]</span><br><span class="line"></span><br><span class="line">In [76]: pd.concat(pieces)</span><br><span class="line">Out[76]: </span><br><span class="line">          0         1         2         3</span><br><span class="line">0 -0.548702  1.467327 -1.015962 -0.483075</span><br><span class="line">1  1.637550 -1.217659 -0.291519 -1.745505</span><br><span class="line">2 -0.263952  0.991460 -0.919069  0.266046</span><br><span class="line">3 -0.709661  1.669052  1.037882 -1.705775</span><br><span class="line">4 -0.919854 -0.042379  1.247642 -0.009920</span><br><span class="line">5  0.290213  0.495767  0.362949  1.548106</span><br><span class="line">6 -1.131345 -0.089329  0.337863 -0.945867</span><br><span class="line">7 -0.932132  1.956030  0.017587 -0.016692</span><br><span class="line">8 -0.575247  0.254161 -1.143704  0.215897</span><br><span class="line">9  1.193555 -0.077118 -0.408530 -0.862495</span><br></pre></td></tr></table></figure><p>Note</p><p>Adding a column to a <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>DataFrame</code></a> is relatively fast. However, adding a row requires a copy, and may be expensive. We recommend passing a pre-built list of records to the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>DataFrame</code></a> constructor instead of building a <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>DataFrame</code></a> by iteratively appending records to it. See <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html#merging-concatenation">Appending to dataframe</a> for more.</p><h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><p>SQL style merges. See the <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html#merging-join">Database style joining</a> section.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [77]: left = pd.DataFrame(&#123;&#x27;key&#x27;: [&#x27;foo&#x27;, &#x27;foo&#x27;], &#x27;lval&#x27;: [1, 2]&#125;)</span><br><span class="line"></span><br><span class="line">In [78]: right = pd.DataFrame(&#123;&#x27;key&#x27;: [&#x27;foo&#x27;, &#x27;foo&#x27;], &#x27;rval&#x27;: [4, 5]&#125;)</span><br><span class="line"></span><br><span class="line">In [79]: left</span><br><span class="line">Out[79]: </span><br><span class="line">   key  lval</span><br><span class="line">0  foo     1</span><br><span class="line">1  foo     2</span><br><span class="line"></span><br><span class="line">In [80]: right</span><br><span class="line">Out[80]: </span><br><span class="line">   key  rval</span><br><span class="line">0  foo     4</span><br><span class="line">1  foo     5</span><br><span class="line"></span><br><span class="line">In [81]: pd.merge(left, right, on=&#x27;key&#x27;)</span><br><span class="line">Out[81]: </span><br><span class="line">   key  lval  rval</span><br><span class="line">0  foo     1     4</span><br><span class="line">1  foo     1     5</span><br><span class="line">2  foo     2     4</span><br><span class="line">3  foo     2     5</span><br></pre></td></tr></table></figure><p>Another example that can be given is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [82]: left = pd.DataFrame(&#123;&#x27;key&#x27;: [&#x27;foo&#x27;, &#x27;bar&#x27;], &#x27;lval&#x27;: [1, 2]&#125;)</span><br><span class="line"></span><br><span class="line">In [83]: right = pd.DataFrame(&#123;&#x27;key&#x27;: [&#x27;foo&#x27;, &#x27;bar&#x27;], &#x27;rval&#x27;: [4, 5]&#125;)</span><br><span class="line"></span><br><span class="line">In [84]: left</span><br><span class="line">Out[84]: </span><br><span class="line">   key  lval</span><br><span class="line">0  foo     1</span><br><span class="line">1  bar     2</span><br><span class="line"></span><br><span class="line">In [85]: right</span><br><span class="line">Out[85]: </span><br><span class="line">   key  rval</span><br><span class="line">0  foo     4</span><br><span class="line">1  bar     5</span><br><span class="line"></span><br><span class="line">In [86]: pd.merge(left, right, on=&#x27;key&#x27;)</span><br><span class="line">Out[86]: </span><br><span class="line">   key  lval  rval</span><br><span class="line">0  foo     1     4</span><br><span class="line">1  bar     2     5</span><br></pre></td></tr></table></figure><h2 id="Grouping"><a href="#Grouping" class="headerlink" title="Grouping"></a>Grouping</h2><p>By “group by” we are referring to a process involving one or more of the following steps:</p><blockquote><ul><li><strong>Splitting</strong> the data into groups based on some criteria</li><li><strong>Applying</strong> a function to each group independently</li><li><strong>Combining</strong> the results into a data structure</li></ul></blockquote><p>See the <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html#groupby">Grouping section</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [87]: df = pd.DataFrame(&#123;&#x27;A&#x27;: [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;,</span><br><span class="line">   ....:                          &#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;foo&#x27;, &#x27;foo&#x27;],</span><br><span class="line">   ....:                    &#x27;B&#x27;: [&#x27;one&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;,</span><br><span class="line">   ....:                          &#x27;two&#x27;, &#x27;two&#x27;, &#x27;one&#x27;, &#x27;three&#x27;],</span><br><span class="line">   ....:                    &#x27;C&#x27;: np.random.randn(8),</span><br><span class="line">   ....:                    &#x27;D&#x27;: np.random.randn(8)&#125;)</span><br><span class="line">   ....: </span><br><span class="line"></span><br><span class="line">In [88]: df</span><br><span class="line">Out[88]: </span><br><span class="line">     A      B         C         D</span><br><span class="line">0  foo    one  1.346061 -1.577585</span><br><span class="line">1  bar    one  1.511763  0.396823</span><br><span class="line">2  foo    two  1.627081 -0.105381</span><br><span class="line">3  bar  three -0.990582 -0.532532</span><br><span class="line">4  foo    two -0.441652  1.453749</span><br><span class="line">5  bar    two  1.211526  1.208843</span><br><span class="line">6  foo    one  0.268520 -0.080952</span><br><span class="line">7  foo  three  0.024580 -0.264610</span><br></pre></td></tr></table></figure><p>Grouping and then applying the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.groupby.GroupBy.sum.html#pandas.core.groupby.GroupBy.sum"><code>sum()</code></a> function to the resulting groups.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [89]: df.groupby(&#x27;A&#x27;).sum()</span><br><span class="line">Out[89]: </span><br><span class="line">            C         D</span><br><span class="line">A                      </span><br><span class="line">bar  1.732707  1.073134</span><br><span class="line">foo  2.824590 -0.574779</span><br></pre></td></tr></table></figure><p>Grouping by multiple columns forms a hierarchical index, and again we can apply the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.core.groupby.GroupBy.sum.html#pandas.core.groupby.GroupBy.sum"><code>sum()</code></a> function.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [90]: df.groupby([&#x27;A&#x27;, &#x27;B&#x27;]).sum()</span><br><span class="line">Out[90]: </span><br><span class="line">                  C         D</span><br><span class="line">A   B                        </span><br><span class="line">bar one    1.511763  0.396823</span><br><span class="line">    three -0.990582 -0.532532</span><br><span class="line">    two    1.211526  1.208843</span><br><span class="line">foo one    1.614581 -1.658537</span><br><span class="line">    three  0.024580 -0.264610</span><br><span class="line">    two    1.185429  1.348368</span><br></pre></td></tr></table></figure><h2 id="Reshaping"><a href="#Reshaping" class="headerlink" title="Reshaping"></a>Reshaping</h2><p>See the sections on <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html#advanced-hierarchical">Hierarchical Indexing</a> and <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html#reshaping-stacking">Reshaping</a>.</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [91]: tuples = list(zip(*[[&#x27;bar&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;, &#x27;baz&#x27;,</span><br><span class="line">   ....:                      &#x27;foo&#x27;, &#x27;foo&#x27;, &#x27;qux&#x27;, &#x27;qux&#x27;],</span><br><span class="line">   ....:                     [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;one&#x27;, &#x27;two&#x27;,</span><br><span class="line">   ....:                      &#x27;one&#x27;, &#x27;two&#x27;, &#x27;one&#x27;, &#x27;two&#x27;]]))</span><br><span class="line">   ....: </span><br><span class="line"></span><br><span class="line">In [92]: index = pd.MultiIndex.from_tuples(tuples, names=[&#x27;first&#x27;, &#x27;second&#x27;])</span><br><span class="line"></span><br><span class="line">In [93]: df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=[&#x27;A&#x27;, &#x27;B&#x27;])</span><br><span class="line"></span><br><span class="line">In [94]: df2 = df[:4]</span><br><span class="line"></span><br><span class="line">In [95]: df2</span><br><span class="line">Out[95]: </span><br><span class="line">                     A         B</span><br><span class="line">first second                    </span><br><span class="line">bar   one    -0.727965 -0.589346</span><br><span class="line">      two     0.339969 -0.693205</span><br><span class="line">baz   one    -0.339355  0.593616</span><br><span class="line">      two     0.884345  1.591431</span><br></pre></td></tr></table></figure><p>The <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.stack.html#pandas.DataFrame.stack"><code>stack()</code></a> method “compresses” a level in the DataFrame’s columns.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [96]: stacked = df2.stack()</span><br><span class="line"></span><br><span class="line">In [97]: stacked</span><br><span class="line">Out[97]: </span><br><span class="line">first  second   </span><br><span class="line">bar    one     A   -0.727965</span><br><span class="line">               B   -0.589346</span><br><span class="line">       two     A    0.339969</span><br><span class="line">               B   -0.693205</span><br><span class="line">baz    one     A   -0.339355</span><br><span class="line">               B    0.593616</span><br><span class="line">       two     A    0.884345</span><br><span class="line">               B    1.591431</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>With a “stacked” DataFrame or Series (having a <code>MultiIndex</code> as the <code>index</code>), the inverse operation of <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.stack.html#pandas.DataFrame.stack"><code>stack()</code></a> is <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.unstack.html#pandas.DataFrame.unstack"><code>unstack()</code></a>, which by default unstacks the <strong>last level</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In [98]: stacked.unstack()</span><br><span class="line">Out[98]: </span><br><span class="line">                     A         B</span><br><span class="line">first second                    </span><br><span class="line">bar   one    -0.727965 -0.589346</span><br><span class="line">      two     0.339969 -0.693205</span><br><span class="line">baz   one    -0.339355  0.593616</span><br><span class="line">      two     0.884345  1.591431</span><br><span class="line"></span><br><span class="line">In [99]: stacked.unstack(1)</span><br><span class="line">Out[99]: </span><br><span class="line">second        one       two</span><br><span class="line">first                      </span><br><span class="line">bar   A -0.727965  0.339969</span><br><span class="line">      B -0.589346 -0.693205</span><br><span class="line">baz   A -0.339355  0.884345</span><br><span class="line">      B  0.593616  1.591431</span><br><span class="line"></span><br><span class="line">In [100]: stacked.unstack(0)</span><br><span class="line">Out[100]: </span><br><span class="line">first          bar       baz</span><br><span class="line">second                      </span><br><span class="line">one    A -0.727965 -0.339355</span><br><span class="line">       B -0.589346  0.593616</span><br><span class="line">two    A  0.339969  0.884345</span><br><span class="line">       B -0.693205  1.591431</span><br></pre></td></tr></table></figure><h3 id="Pivot-tables"><a href="#Pivot-tables" class="headerlink" title="Pivot tables"></a>Pivot tables</h3><p>See the section on <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html#reshaping-pivot">Pivot Tables</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [101]: df = pd.DataFrame(&#123;&#x27;A&#x27;: [&#x27;one&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;] * 3,</span><br><span class="line">   .....:                    &#x27;B&#x27;: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;] * 4,</span><br><span class="line">   .....:                    &#x27;C&#x27;: [&#x27;foo&#x27;, &#x27;foo&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;bar&#x27;, &#x27;bar&#x27;] * 2,</span><br><span class="line">   .....:                    &#x27;D&#x27;: np.random.randn(12),</span><br><span class="line">   .....:                    &#x27;E&#x27;: np.random.randn(12)&#125;)</span><br><span class="line">   .....: </span><br><span class="line"></span><br><span class="line">In [102]: df</span><br><span class="line">Out[102]: </span><br><span class="line">        A  B    C         D         E</span><br><span class="line">0     one  A  foo -1.202872  0.047609</span><br><span class="line">1     one  B  foo -1.814470 -0.136473</span><br><span class="line">2     two  C  foo  1.018601 -0.561757</span><br><span class="line">3   three  A  bar -0.595447 -1.623033</span><br><span class="line">4     one  B  bar  1.395433  0.029399</span><br><span class="line">5     one  C  bar -0.392670 -0.542108</span><br><span class="line">6     two  A  foo  0.007207  0.282696</span><br><span class="line">7   three  B  foo  1.928123 -0.087302</span><br><span class="line">8     one  C  foo -0.055224 -1.575170</span><br><span class="line">9     one  A  bar  2.395985  1.771208</span><br><span class="line">10    two  B  bar  1.552825  0.816482</span><br><span class="line">11  three  C  bar  0.166599  1.100230</span><br></pre></td></tr></table></figure><p>We can produce pivot tables from this data very easily:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [103]: pd.pivot_table(df, values=&#x27;D&#x27;, index=[&#x27;A&#x27;, &#x27;B&#x27;], columns=[&#x27;C&#x27;])</span><br><span class="line">Out[103]: </span><br><span class="line">C             bar       foo</span><br><span class="line">A     B                    </span><br><span class="line">one   A  2.395985 -1.202872</span><br><span class="line">      B  1.395433 -1.814470</span><br><span class="line">      C -0.392670 -0.055224</span><br><span class="line">three A -0.595447       NaN</span><br><span class="line">      B       NaN  1.928123</span><br><span class="line">      C  0.166599       NaN</span><br><span class="line">two   A       NaN  0.007207</span><br><span class="line">      B  1.552825       NaN</span><br><span class="line">      C       NaN  1.018601</span><br></pre></td></tr></table></figure><h2 id="Time-series"><a href="#Time-series" class="headerlink" title="Time series"></a>Time series</h2><p>pandas has simple, powerful, and efficient functionality for performing resampling operations during frequency conversion (e.g., converting secondly data into 5-minutely data). This is extremely common in, but not limited to, financial applications. See the <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries">Time Series section</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [104]: rng = pd.date_range(&#x27;1/1/2012&#x27;, periods=100, freq=&#x27;S&#x27;)</span><br><span class="line"></span><br><span class="line">In [105]: ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [106]: ts.resample(&#x27;5Min&#x27;).sum()</span><br><span class="line">Out[106]: </span><br><span class="line">2012-01-01    24182</span><br><span class="line">Freq: 5T, dtype: int64</span><br></pre></td></tr></table></figure><p>Time zone representation:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [107]: rng = pd.date_range(&#x27;3/6/2012 00:00&#x27;, periods=5, freq=&#x27;D&#x27;)</span><br><span class="line"></span><br><span class="line">In [108]: ts = pd.Series(np.random.randn(len(rng)), rng)</span><br><span class="line"></span><br><span class="line">In [109]: ts</span><br><span class="line">Out[109]: </span><br><span class="line">2012-03-06    1.857704</span><br><span class="line">2012-03-07   -1.193545</span><br><span class="line">2012-03-08    0.677510</span><br><span class="line">2012-03-09   -0.153931</span><br><span class="line">2012-03-10    0.520091</span><br><span class="line">Freq: D, dtype: float64</span><br><span class="line"></span><br><span class="line">In [110]: ts_utc = ts.tz_localize(&#x27;UTC&#x27;)</span><br><span class="line"></span><br><span class="line">In [111]: ts_utc</span><br><span class="line">Out[111]: </span><br><span class="line">2012-03-06 00:00:00+00:00    1.857704</span><br><span class="line">2012-03-07 00:00:00+00:00   -1.193545</span><br><span class="line">2012-03-08 00:00:00+00:00    0.677510</span><br><span class="line">2012-03-09 00:00:00+00:00   -0.153931</span><br><span class="line">2012-03-10 00:00:00+00:00    0.520091</span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure><p>Converting to another time zone:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [112]: ts_utc.tz_convert(&#x27;US/Eastern&#x27;)</span><br><span class="line">Out[112]: </span><br><span class="line">2012-03-05 19:00:00-05:00    1.857704</span><br><span class="line">2012-03-06 19:00:00-05:00   -1.193545</span><br><span class="line">2012-03-07 19:00:00-05:00    0.677510</span><br><span class="line">2012-03-08 19:00:00-05:00   -0.153931</span><br><span class="line">2012-03-09 19:00:00-05:00    0.520091</span><br><span class="line">Freq: D, dtype: float64</span><br></pre></td></tr></table></figure><p>Converting between time span representations:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">In [113]: rng = pd.date_range(&#x27;1/1/2012&#x27;, periods=5, freq=&#x27;M&#x27;)</span><br><span class="line"></span><br><span class="line">In [114]: ts = pd.Series(np.random.randn(len(rng)), index=rng)</span><br><span class="line"></span><br><span class="line">In [115]: ts</span><br><span class="line">Out[115]: </span><br><span class="line">2012-01-31   -1.475051</span><br><span class="line">2012-02-29    0.722570</span><br><span class="line">2012-03-31   -0.322646</span><br><span class="line">2012-04-30   -1.601631</span><br><span class="line">2012-05-31    0.778033</span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [116]: ps = ts.to_period()</span><br><span class="line"></span><br><span class="line">In [117]: ps</span><br><span class="line">Out[117]: </span><br><span class="line">2012-01   -1.475051</span><br><span class="line">2012-02    0.722570</span><br><span class="line">2012-03   -0.322646</span><br><span class="line">2012-04   -1.601631</span><br><span class="line">2012-05    0.778033</span><br><span class="line">Freq: M, dtype: float64</span><br><span class="line"></span><br><span class="line">In [118]: ps.to_timestamp()</span><br><span class="line">Out[118]: </span><br><span class="line">2012-01-01   -1.475051</span><br><span class="line">2012-02-01    0.722570</span><br><span class="line">2012-03-01   -0.322646</span><br><span class="line">2012-04-01   -1.601631</span><br><span class="line">2012-05-01    0.778033</span><br><span class="line">Freq: MS, dtype: float64</span><br></pre></td></tr></table></figure><p>Converting between period and timestamp enables some convenient arithmetic functions to be used. In the following example, we convert a quarterly frequency with year ending in November to 9am of the end of the month following the quarter end:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [119]: prng = pd.period_range(&#x27;1990Q1&#x27;, &#x27;2000Q4&#x27;, freq=&#x27;Q-NOV&#x27;)</span><br><span class="line"></span><br><span class="line">In [120]: ts = pd.Series(np.random.randn(len(prng)), prng)</span><br><span class="line"></span><br><span class="line">In [121]: ts.index = (prng.asfreq(&#x27;M&#x27;, &#x27;e&#x27;) + 1).asfreq(&#x27;H&#x27;, &#x27;s&#x27;) + 9</span><br><span class="line"></span><br><span class="line">In [122]: ts.head()</span><br><span class="line">Out[122]: </span><br><span class="line">1990-03-01 09:00   -0.289342</span><br><span class="line">1990-06-01 09:00    0.233141</span><br><span class="line">1990-09-01 09:00   -0.223540</span><br><span class="line">1990-12-01 09:00    0.542054</span><br><span class="line">1991-03-01 09:00   -0.688585</span><br><span class="line">Freq: H, dtype: float64</span><br></pre></td></tr></table></figure><h2 id="Categoricals"><a href="#Categoricals" class="headerlink" title="Categoricals"></a>Categoricals</h2><p>pandas can include categorical data in a <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame"><code>DataFrame</code></a>. For full docs, see the <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html#categorical">categorical introduction</a> and the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/arrays.html#api-arrays-categorical">API documentation</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [123]: df = pd.DataFrame(&#123;&quot;id&quot;: [1, 2, 3, 4, 5, 6],</span><br><span class="line">   .....:                    &quot;raw_grade&quot;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;e&#x27;]&#125;)</span><br><span class="line">   .....: </span><br></pre></td></tr></table></figure><p>Convert the raw grades to a categorical data type.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [124]: df[&quot;grade&quot;] = df[&quot;raw_grade&quot;].astype(&quot;category&quot;)</span><br><span class="line"></span><br><span class="line">In [125]: df[&quot;grade&quot;]</span><br><span class="line">Out[125]: </span><br><span class="line">0    a</span><br><span class="line">1    b</span><br><span class="line">2    b</span><br><span class="line">3    a</span><br><span class="line">4    a</span><br><span class="line">5    e</span><br><span class="line">Name: grade, dtype: category</span><br><span class="line">Categories (3, object): [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;]</span><br></pre></td></tr></table></figure><p>Rename the categories to more meaningful names (assigning to <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.cat.categories.html#pandas.Series.cat.categories"><code>Series.cat.categories()</code></a> is in place!).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [126]: df[&quot;grade&quot;].cat.categories = [&quot;very good&quot;, &quot;good&quot;, &quot;very bad&quot;]</span><br></pre></td></tr></table></figure><p>Reorder the categories and simultaneously add the missing categories (methods under <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.cat.html#pandas.Series.cat"><code>Series.cat()</code></a> return a new <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas.Series"><code>Series</code></a> by default).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [127]: df[&quot;grade&quot;] = df[&quot;grade&quot;].cat.set_categories([&quot;very bad&quot;, &quot;bad&quot;, &quot;medium&quot;,</span><br><span class="line">   .....:                                               &quot;good&quot;, &quot;very good&quot;])</span><br><span class="line">   .....: </span><br><span class="line"></span><br><span class="line">In [128]: df[&quot;grade&quot;]</span><br><span class="line">Out[128]: </span><br><span class="line">0    very good</span><br><span class="line">1         good</span><br><span class="line">2         good</span><br><span class="line">3    very good</span><br><span class="line">4    very good</span><br><span class="line">5     very bad</span><br><span class="line">Name: grade, dtype: category</span><br><span class="line">Categories (5, object): [&#x27;very bad&#x27;, &#x27;bad&#x27;, &#x27;medium&#x27;, &#x27;good&#x27;, &#x27;very good&#x27;]</span><br></pre></td></tr></table></figure><p>Sorting is per order in the categories, not lexical order.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [129]: df.sort_values(by=&quot;grade&quot;)</span><br><span class="line">Out[129]: </span><br><span class="line">   id raw_grade      grade</span><br><span class="line">5   6         e   very bad</span><br><span class="line">1   2         b       good</span><br><span class="line">2   3         b       good</span><br><span class="line">0   1         a  very good</span><br><span class="line">3   4         a  very good</span><br><span class="line">4   5         a  very good</span><br></pre></td></tr></table></figure><p>Grouping by a categorical column also shows empty categories.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [130]: df.groupby(&quot;grade&quot;).size()</span><br><span class="line">Out[130]: </span><br><span class="line">grade</span><br><span class="line">very bad     1</span><br><span class="line">bad          0</span><br><span class="line">medium       0</span><br><span class="line">good         2</span><br><span class="line">very good    3</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure><h2 id="Plotting"><a href="#Plotting" class="headerlink" title="Plotting"></a>Plotting</h2><p>See the <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html#visualization">Plotting</a> docs.</p><p>We use the standard convention for referencing the matplotlib API:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [131]: import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">In [132]: plt.close(&#x27;all&#x27;)</span><br><span class="line">In [133]: ts = pd.Series(np.random.randn(1000),</span><br><span class="line">   .....:                index=pd.date_range(&#x27;1/1/2000&#x27;, periods=1000))</span><br><span class="line">   .....: </span><br><span class="line"></span><br><span class="line">In [134]: ts = ts.cumsum()</span><br><span class="line"></span><br><span class="line">In [135]: ts.plot()</span><br><span class="line">Out[135]: &lt;AxesSubplot:&gt;</span><br></pre></td></tr></table></figure><p><img src="https://pandas.pydata.org/pandas-docs/stable/_images/series_plot_basic.png" alt="../_images/series_plot_basic.png"></p><p>On a DataFrame, the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.plot.html#pandas.DataFrame.plot"><code>plot()</code></a> method is a convenience to plot all of the columns with labels:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [136]: df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index,</span><br><span class="line">   .....:                   columns=[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;])</span><br><span class="line">   .....: </span><br><span class="line"></span><br><span class="line">In [137]: df = df.cumsum()</span><br><span class="line"></span><br><span class="line">In [138]: plt.figure()</span><br><span class="line">Out[138]: &lt;Figure size 640x480 with 0 Axes&gt;</span><br><span class="line"></span><br><span class="line">In [139]: df.plot()</span><br><span class="line">Out[139]: &lt;AxesSubplot:&gt;</span><br><span class="line"></span><br><span class="line">In [140]: plt.legend(loc=&#x27;best&#x27;)</span><br><span class="line">Out[140]: &lt;matplotlib.legend.Legend at 0x7fbfb29f0670&gt;</span><br></pre></td></tr></table></figure><p><img src="https://pandas.pydata.org/pandas-docs/stable/_images/frame_plot_basic.png" alt="../_images/frame_plot_basic.png"></p><h2 id="Getting-data-in-out"><a href="#Getting-data-in-out" class="headerlink" title="Getting data in/out"></a>Getting data in/out</h2><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-store-in-csv">Writing to a csv file.</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [141]: df.to_csv(&#x27;foo.csv&#x27;)</span><br></pre></td></tr></table></figure><p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-read-csv-table">Reading from a csv file.</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [142]: pd.read_csv(&#x27;foo.csv&#x27;)</span><br><span class="line">Out[142]: </span><br><span class="line">     Unnamed: 0          A          B          C          D</span><br><span class="line">0    2000-01-01   0.350262   0.843315   1.798556   0.782234</span><br><span class="line">1    2000-01-02  -0.586873   0.034907   1.923792  -0.562651</span><br><span class="line">2    2000-01-03  -1.245477  -0.963406   2.269575  -1.612566</span><br><span class="line">3    2000-01-04  -0.252830  -0.498066   3.176886  -1.275581</span><br><span class="line">4    2000-01-05  -1.044057   0.118042   2.768571   0.386039</span><br><span class="line">..          ...        ...        ...        ...        ...</span><br><span class="line">995  2002-09-22 -48.017654  31.474551  69.146374 -47.541670</span><br><span class="line">996  2002-09-23 -47.207912  32.627390  68.505254 -48.828331</span><br><span class="line">997  2002-09-24 -48.907133  31.990402  67.310924 -49.391051</span><br><span class="line">998  2002-09-25 -50.146062  33.716770  67.717434 -49.037577</span><br><span class="line">999  2002-09-26 -49.724318  33.479952  68.108014 -48.822030</span><br><span class="line"></span><br><span class="line">[1000 rows x 5 columns]</span><br></pre></td></tr></table></figure><h3 id="HDF5"><a href="#HDF5" class="headerlink" title="HDF5"></a>HDF5</h3><p>Reading and writing to <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-hdf5">HDFStores</a>.</p><p>Writing to a HDF5 Store.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [143]: df.to_hdf(&#x27;foo.h5&#x27;, &#x27;df&#x27;)</span><br></pre></td></tr></table></figure><p>Reading from a HDF5 Store.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [144]: pd.read_hdf(&#x27;foo.h5&#x27;, &#x27;df&#x27;)</span><br><span class="line">Out[144]: </span><br><span class="line">                    A          B          C          D</span><br><span class="line">2000-01-01   0.350262   0.843315   1.798556   0.782234</span><br><span class="line">2000-01-02  -0.586873   0.034907   1.923792  -0.562651</span><br><span class="line">2000-01-03  -1.245477  -0.963406   2.269575  -1.612566</span><br><span class="line">2000-01-04  -0.252830  -0.498066   3.176886  -1.275581</span><br><span class="line">2000-01-05  -1.044057   0.118042   2.768571   0.386039</span><br><span class="line">...               ...        ...        ...        ...</span><br><span class="line">2002-09-22 -48.017654  31.474551  69.146374 -47.541670</span><br><span class="line">2002-09-23 -47.207912  32.627390  68.505254 -48.828331</span><br><span class="line">2002-09-24 -48.907133  31.990402  67.310924 -49.391051</span><br><span class="line">2002-09-25 -50.146062  33.716770  67.717434 -49.037577</span><br><span class="line">2002-09-26 -49.724318  33.479952  68.108014 -48.822030</span><br><span class="line"></span><br><span class="line">[1000 rows x 4 columns]</span><br></pre></td></tr></table></figure><h3 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h3><p>Reading and writing to <a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-excel">MS Excel</a>.</p><p>Writing to an excel file.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [145]: df.to_excel(&#x27;foo.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;)</span><br></pre></td></tr></table></figure><p>Reading from an excel file.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [146]: pd.read_excel(&#x27;foo.xlsx&#x27;, &#x27;Sheet1&#x27;, index_col=None, na_values=[&#x27;NA&#x27;])</span><br><span class="line">Out[146]: </span><br><span class="line">    Unnamed: 0          A          B          C          D</span><br><span class="line">0   2000-01-01   0.350262   0.843315   1.798556   0.782234</span><br><span class="line">1   2000-01-02  -0.586873   0.034907   1.923792  -0.562651</span><br><span class="line">2   2000-01-03  -1.245477  -0.963406   2.269575  -1.612566</span><br><span class="line">3   2000-01-04  -0.252830  -0.498066   3.176886  -1.275581</span><br><span class="line">4   2000-01-05  -1.044057   0.118042   2.768571   0.386039</span><br><span class="line">..         ...        ...        ...        ...        ...</span><br><span class="line">995 2002-09-22 -48.017654  31.474551  69.146374 -47.541670</span><br><span class="line">996 2002-09-23 -47.207912  32.627390  68.505254 -48.828331</span><br><span class="line">997 2002-09-24 -48.907133  31.990402  67.310924 -49.391051</span><br><span class="line">998 2002-09-25 -50.146062  33.716770  67.717434 -49.037577</span><br><span class="line">999 2002-09-26 -49.724318  33.479952  68.108014 -48.822030</span><br><span class="line"></span><br><span class="line">[1000 rows x 5 columns]</span><br></pre></td></tr></table></figure><h2 id="Gotchas"><a href="#Gotchas" class="headerlink" title="Gotchas"></a>Gotchas</h2><p>If you are attempting to perform an operation you might see an exception like:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; if pd.Series([False, True, False]):</span><br><span class="line">...     print(&quot;I was true&quot;)</span><br><span class="line">Traceback</span><br><span class="line">    ...</span><br><span class="line">ValueError: The truth value of an array is ambiguous. Use a.empty, a.any() or a.all().</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;10-minutes-to-pandas&quot;&gt;&lt;a href=&quot;#10-minutes-to-pandas&quot; class=&quot;headerlink&quot; title=&quot;10 minutes to pandas&quot;&gt;&lt;/a&gt;10 minutes to
      
    
    </summary>
    
    
  </entry>
  
</feed>
