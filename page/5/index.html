<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangdongdong122.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="从爪印判断，这是头雄狮">
<meta property="og:type" content="website">
<meta property="og:title" content="凛冬将至">
<meta property="og:url" content="http://wangdongdong122.github.io/page/5/index.html">
<meta property="og:site_name" content="凛冬将至">
<meta property="og:description" content="从爪印判断，这是头雄狮">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Dongdong Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://wangdongdong122.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>凛冬将至</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">凛冬将至</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">从简单的例子开始</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangdongdong122.github.io/2019/12/04/2_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dongdong Wang">
      <meta itemprop="description" content="从爪印判断，这是头雄狮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凛冬将至">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/04/2_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-04 11:32:02" itemprop="dateCreated datePublished" datetime="2019-12-04T11:32:02+08:00">2019-12-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="1-ROC-KS-AUC"><a href="#1-ROC-KS-AUC" class="headerlink" title="1. ROC, KS, AUC"></a>1. ROC, KS, AUC</h2><h3 id="1-TP-FP-FN-TN"><a href="#1-TP-FP-FN-TN" class="headerlink" title="1. TP, FP, FN, TN"></a>1. TP, FP, FN, TN</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>预测1</th>
<th>预测0</th>
<th>合计</th>
</tr>
</thead>
<tbody>
<tr>
<td>真实1</td>
<td>True Positive (TP)</td>
<td>False Negative (FN)</td>
<td>Actual   Positive(TP+FN)</td>
</tr>
<tr>
<td>真实0</td>
<td>False Positive (FP)</td>
<td>True Negative(TN)</td>
<td>Actual   Negative(FP+TN)</td>
</tr>
<tr>
<td>合计</td>
<td>Predicted   Positive(TP+FP)</td>
<td>Predicted   Negative(FN+TN)</td>
<td>TP+FP+FN+TN</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>True Positive Rate（TPR），计算公式为TPR=TP/(TP+FN)；所有真实的“1”中，有多少被模型成功选出</li>
<li>False Positive Rate（FPR），计算公式为FPR=FP/(FP+TN)；所有真实的“0”中，有多少被模型误判为1了；</li>
<li>Precision=TP/(TP+FP)，或2TP/((TP+FN)+(TP+FP))。所有判为1的用户，判对的比例</li>
<li>好的模型：TPR尽量高而FPR尽量低</li>
</ul>
<h3 id="2-ROC"><a href="#2-ROC" class="headerlink" title="2. ROC"></a>2. ROC</h3><ul>
<li><p>ROC(Receiver Operating Characteristic Curve):接受者操作特征曲线。</p>
</li>
<li><p>ROC曲线：设定不同的阀值，计算不同的点(FPR,TPR)，连成曲线</p>
</li>
<li><p>ROC曲线确定阈值的方法：</p>
</li>
<li><ul>
<li>给出ROC曲线的拟合函数表达式，然后计算出最优的阀值，这个目前通过软件实现难度不大：如何给出最优拟合函数，计算数学上有很多方法；</li>
<li>计算出ΔTPR≈ΔFPR的点即为最优的阀值；</li>
<li>从业务上给出最优的阀值。</li>
</ul>
</li>
</ul>
<p><img src="D:\dev\Blog\machine-learning-note\基础算法\.images\1560344119508.png" alt="1560344119508"></p>
<h3 id="3-AUC"><a href="#3-AUC" class="headerlink" title="3. AUC"></a>3. AUC</h3><ul>
<li>AUC：ROC曲线下方的面积Area Under the ROC      Curve，简称为AUC。这是评价模型的另一个方法，AUC值越大，说明模型的分辨效果越好</li>
<li>gini系数：在SAS的评分模型输出中，常用来判断收入分配公平程度，此时gini=2*AUC-1</li>
</ul>
<p>XGB中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> sum_pospair = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> sum_npos = <span class="number">0.0</span>, sum_nneg = <span class="number">0.0</span>, buf_pos = <span class="number">0.0</span>, buf_neg = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; rec.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">float</span> wt = info.<span class="built_in">GetWeight</span>(rec[j].second);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">float</span> ctr = info.labels[rec[j].second];</span><br><span class="line">  <span class="comment">// keep bucketing predictions in same bucket</span></span><br><span class="line">  <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; rec[j].first != rec[j - <span class="number">1</span>].first) &#123; <span class="comment">// 遍历所有的预测值</span></span><br><span class="line">    sum_pospair += buf_neg * (sum_npos + buf_pos *<span class="number">0.5</span>); <span class="comment">// 逐个梯形计算</span></span><br><span class="line">    sum_npos += buf_pos;</span><br><span class="line">    sum_nneg += buf_neg;</span><br><span class="line">    buf_neg = buf_pos = <span class="number">0.0f</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  buf_pos += ctr * wt; <span class="comment">// 累计加权TP</span></span><br><span class="line">  buf_neg += (<span class="number">1.0f</span> - ctr) * wt; <span class="comment">// 累计加权FP</span></span><br><span class="line">&#125;</span><br><span class="line">sum_pospair += buf_neg * (sum_npos + buf_pos *<span class="number">0.5</span>);</span><br><span class="line">sum_npos += buf_pos;</span><br><span class="line">sum_nneg += buf_neg;</span><br><span class="line"><span class="comment">// check weird conditions</span></span><br><span class="line">utils::<span class="built_in">Check</span>(sum_npos &gt; <span class="number">0.0</span> &amp;&amp; sum_nneg &gt; <span class="number">0.0</span>,</span><br><span class="line">             <span class="string">&quot;AUC: the dataset only contains pos or neg samples&quot;</span>);</span><br><span class="line"><span class="comment">// this is the AUC</span></span><br><span class="line">sum_auc += sum_pospair / (sum_npos*sum_nneg);<span class="comment">// 计算AUC</span></span><br></pre></td></tr></table></figure>
<p>R语言中的计算方法</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (y_pred, y_true) </span><br><span class="line">&#123;</span><br><span class="line">rank &lt;- rank(y_pred) <span class="comment"># rank[i] 为 y_pred[i]从小到大的排序号，最小为1,两个数并列第5，则都为5.5</span></span><br><span class="line">n_pos &lt;- <span class="built_in">sum</span>(y_true == <span class="number">1</span>)</span><br><span class="line">n_neg &lt;- <span class="built_in">sum</span>(y_true == <span class="number">0</span>)</span><br><span class="line">AUC &lt;- (<span class="built_in">sum</span>(rank[y_true == <span class="number">1</span>]) - n_pos * (n_pos + <span class="number">1</span>)/<span class="number">2</span>)/(n_pos * </span><br><span class="line">n_neg)</span><br><span class="line"><span class="built_in">return</span>(AUC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src=".images\auc计算" alt="img"></p>
<p>原因：</p>

<h3 id="4-KS"><a href="#4-KS" class="headerlink" title="4. KS"></a>4. KS</h3><ul>
<li>K-S曲线：它和ROC曲线的画法异曲同工。以Logistic模型为例，首先把Logistic模型输出的概率从大到小排序，然后取10%的值（也就是概率值）作为阀值，同理把10%*k（k=1,2,3,…,9）处的值作为阀值，计算出不同的FPR和TPR值，以10%*k（k=1,2,3,…,9）为横坐标，分别以TPR和FPR的值为纵坐标，就可以画出两个曲线，这就是K-S曲线。</li>
<li>KS值：KS=max(TPR-FPR)，即是两条曲线之间的最大间隔距离。当(TPR-FPR)最大时，也就是ΔTPR-ΔFPR=0，这和ROC曲线上找最优阀值的条件ΔTPR=ΔFPR是一样的。从这点也可以看出，ROC曲线、K-S曲线、KS值的本质是相同的。</li>
</ul>
<p><img src=".images\1560344142780.png" alt="1560344142780"></p>
<ul>
<li><p>K-S曲线能直观地找出模型中差异最大的一个分段，比如评分模型就比较适合用KS值进行评估；</p>
</li>
<li><p>KS值只能反映出哪个分段是区分度最大的，不能反映出所有分段的效果。</p>
</li>
</ul>
<p>因此，在实际应用中，模型评价一般需要将ROC曲线、K-S曲线、KS值、AUC指标结合起来使用。</p>
<h2 id="2-PSI"><a href="#2-PSI" class="headerlink" title="2. PSI"></a>2. PSI</h2><h3 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a>1. 含义</h3><p>PopulationStability Index(PSI)群体稳定性指标</p>
<h3 id="2-公式"><a href="#2-公式" class="headerlink" title="2. 公式"></a>2. 公式</h3><p> psi = sum(（实际占比-预期占比）*ln(实际占比/预期占比))</p>
<p>数学<strong>原理</strong>：</p>
<ul>
<li><p>平衡符号</p>
</li>
<li><p>占比小的区间权重小</p>
<p><img src=".images\1560344829786.png" alt="1560344829786"></p>
</li>
</ul>
<h3 id="3-计算"><a href="#3-计算" class="headerlink" title="3. 计算"></a>3. 计算</h3><p>形式上比较像WoE和IV，下面是<strong>计算</strong>举例：</p>
<p><img src=".images\1560344565889.png" alt="1560344565889"></p>
<p>计算表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Score bands</th>
<th><strong>Actual %</strong></th>
<th>Expected %</th>
<th><strong>Ac-Ex</strong></th>
<th><strong>ln(Ac/Ex)</strong></th>
<th><strong>Index</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 251</td>
<td>5%</td>
<td>8%</td>
<td>-3%</td>
<td>-0.47</td>
<td><strong>0.014</strong></td>
</tr>
<tr>
<td>251–290</td>
<td>6%</td>
<td>9%</td>
<td>-3%</td>
<td>-0.41</td>
<td><strong>0.012</strong></td>
</tr>
<tr>
<td>291–320</td>
<td>6%</td>
<td>10%</td>
<td>-4%</td>
<td>-0.51</td>
<td><strong>0.020</strong></td>
</tr>
<tr>
<td>321–350</td>
<td>8%</td>
<td>13%</td>
<td>-5%</td>
<td>-0.49</td>
<td><strong>0.024</strong></td>
</tr>
<tr>
<td>351–380</td>
<td>10%</td>
<td>12%</td>
<td>-2%</td>
<td>-0.18</td>
<td><strong>0.004</strong></td>
</tr>
<tr>
<td>381–410</td>
<td>12%</td>
<td>11%</td>
<td>1%</td>
<td>0.09</td>
<td><strong>0.001</strong></td>
</tr>
<tr>
<td>411–440</td>
<td>14%</td>
<td>10%</td>
<td>4%</td>
<td>0.34</td>
<td><strong>0.013</strong></td>
</tr>
<tr>
<td>441–470</td>
<td>14%</td>
<td>9%</td>
<td>5%</td>
<td>0.44</td>
<td><strong>0.022</strong></td>
</tr>
<tr>
<td>471–520</td>
<td>13%</td>
<td>9%</td>
<td>4%</td>
<td>0.37</td>
<td><strong>0.015</strong></td>
</tr>
<tr>
<td>520 &lt;</td>
<td>9%</td>
<td>8%</td>
<td>1%</td>
<td>0.12</td>
<td><strong>0.001</strong></td>
</tr>
<tr>
<td><strong>(PSI)= </strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>0.1269</strong></td>
</tr>
</tbody>
</table>
</div>
<p>指标取值解释说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>PSI Value</strong></th>
<th><strong>Inference</strong></th>
<th><strong>Action</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Less than 0.1</td>
<td>无关紧要的差距</td>
<td>不需要进一步操作</td>
</tr>
<tr>
<td>0.1 – 0.25</td>
<td>有一点差距</td>
<td>检查一下其他度量</td>
</tr>
<tr>
<td>Greater than 0.25</td>
<td>差距较大</td>
<td>需要进一步研究</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h3><h2 id="3-VIF"><a href="#3-VIF" class="headerlink" title="3. VIF"></a>3. VIF</h2><h3 id="1-含义-1"><a href="#1-含义-1" class="headerlink" title="1. 含义"></a>1. 含义</h3><p>方差膨胀因子（Variance Inflation Factor，VIF）</p>
<ul>
<li>容忍度的倒数，VIF越大，显示共线性越严重。经验判断方法表明：当0&lt;VIF&lt;10，不存在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/多重共线性/10201978">多重共线性</a>；当10≤VIF&lt;100，存在较强的多重共线性；当VIF≥100，存在严重多重共线性。</li>
</ul>
<h2 id="4-LIFT"><a href="#4-LIFT" class="headerlink" title="4. LIFT"></a>4. LIFT</h2><h3 id="1-什么是LIFT"><a href="#1-什么是LIFT" class="headerlink" title="1. 什么是LIFT"></a>1. 什么是LIFT</h3><p>Lift是评估一个预测模型是否有效的一个度量；它衡量的是一个模型（或规则）对目标中“响应”的预测能力优于随机选择的倍数，以1为界线，大于1的Lift表示该模型或规则比随机选择捕捉了更多的“响应”，等于1的Lift表示该模型的表现独立于随机选择，小于1则表示该模型或规则比随机选择捕捉了更少的“响应”。维基百科中提升度被解释为“Target response divided by average response”。</p>
<h3 id="2-计算方法"><a href="#2-计算方法" class="headerlink" title="2. 计算方法"></a>2. 计算方法</h3><p>在模型评估中，我们常用到增益/提升（Gain/Lift）图来评估模型效果，其中的<strong>Lift是“运用该模型”和“未运用该模型”所得结果的比值。</strong>以信用评分卡模型的评分结果为例，我们通常会将打分后的样本按分数从低到高排序，取10或20等分（有同分数对应多条观测的情况，所以各组观测数未必完全相等），并对组内观测数与坏样本数进行统计。用评分卡模型捕捉到的坏客户的占比，可由该组坏样本数除以总的坏样本数计算得出；而不使用此评分卡，以随机选择的方法覆盖到的坏客户占比，等价于该组观测数占总观测数的比例（分子分母同时乘以样本整体的坏账率）。对两者取累计值，取其比值，则得到提升度Lift，即该评分卡抓取坏客户的能力是随机选择的多少倍。</p>
<h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p> 下表是一个提升表（Lift Table）的示例：</p>
<p><img src=".images\1560345165281.png" alt="1560345165281"></p>
<p>以分数段为横轴，以捕捉到的“坏”占比为纵轴，可绘制出提升图，示例如下：</p>
<p><img src=".images\1560345217251.png" alt="1560345217251"></p>
<p> 以分数段为横轴，以提升度为纵轴，可绘制出累计提升图，示例如下：</p>
<p><img src=".images\1560345243738.png" alt="1560345243738"></p>
<p>有了累计提升图，我们就能直观地去比较不同模型或策略给我们带来的区分能力增益程度。</p>
<h2 id="5-RMSE-R-2"><a href="#5-RMSE-R-2" class="headerlink" title="5. RMSE, R^2^"></a>5. RMSE, R^2^</h2><h3 id="1-RMSE"><a href="#1-RMSE" class="headerlink" title="1. RMSE"></a>1. RMSE</h3>
<h3 id="2-R-2"><a href="#2-R-2" class="headerlink" title="2. R^2^"></a>2. R^2^</h3><p><img src=".images\clip_image002.png" alt="img"></p>
<h2 id="6-变异系数"><a href="#6-变异系数" class="headerlink" title="6. 变异系数"></a>6. 变异系数</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>变异系数（Coefficient of Variation）：当需要比较两组数据<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/离散程度/6775049">离散程度</a>大小的时候，如果两组数据的测量尺度相差太大，或者数据<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/量纲/100412">量纲</a>的不同，直接使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/标准差/1415772">标准差</a>来进行比较不合适，此时就应当消除测量尺度和量纲的影响，而变异系数可以做到这一点，它是原始数据标准差与原始数据<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/平均数/11031224">平均数</a>的比。CV没有量纲，这样就可以进行客观比较了。事实上，可以认为变异系数和极差、标准差和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/方差/3108412">方差</a>一样，都是反映数据离散程度的绝对值。其数据大小不仅受变量值离散程度的影响，而且还受变量值平均水平大小的影响。</p>
<h3 id="2-计算公式"><a href="#2-计算公式" class="headerlink" title="2. 计算公式"></a>2. 计算公式</h3><p>标准差与平均值之比：</p>
<script type="math/tex; mode=display">
C_v=\frac{\sigma}{\mu}</script><h2 id="7-WOE"><a href="#7-WOE" class="headerlink" title="7. WOE"></a>7. WOE</h2><h3 id="1-什么是WOE"><a href="#1-什么是WOE" class="headerlink" title="1. 什么是WOE"></a>1. 什么是WOE</h3><h3 id="2-计算公式-1"><a href="#2-计算公式-1" class="headerlink" title="2. 计算公式"></a>2. 计算公式</h3><p>WOE（Weight of Evidence）</p>
<p>某个变量第i个属性对应的WOE值计算公式如下：</p>
<script type="math/tex; mode=display">
\begin{eqnarray*}
WOE_i &=& ln(\frac{好用户占比}{坏用户占比})
\\
\\
&=&  ln(\frac {\frac{g_i}{g_T}} {\frac{b_i}{b_T}})
\\
\\
&=&  ln(\frac{g_i}{b_i}）- ln(\frac{g_T}{b_T})

\end{eqnarray*}</script><p>其中：g~i~为第i个属性上好用户数，g~T~表示总好人数，b~i~为第i个属性上坏用户数，b~T~表示总坏人数</p>
<p><strong>WOE</strong>的值<strong>越高</strong>，代表着该分组中客户是坏客户的<strong>风险越低</strong></p>
<h2 id="8-IV"><a href="#8-IV" class="headerlink" title="8. IV"></a>8. IV</h2><h3 id="1-IV是什么"><a href="#1-IV是什么" class="headerlink" title="1. IV是什么"></a>1. IV是什么</h3><p><strong>IV</strong>值是用来衡量某个变量对好坏客户区分能力的一个指标</p>
<h3 id="2-计算公式-2"><a href="#2-计算公式-2" class="headerlink" title="2. 计算公式"></a>2. 计算公式</h3><p>IV值公式如下：</p>
<script type="math/tex; mode=display">
\begin{eqnarray*}
IV &=& \sum_i (\frac{g_i}{g_T}- \frac{b_i}{b_T})WOE_i
\\
\\
&=& \sum_i (\frac{g_i}{g_T}- \frac{b_i}{b_T})ln(\frac {\frac{g_i}{g_T}} {\frac{b_i}{b_T}})
\\
\\
&=& \sum_i (P_g-P_b) ln(\frac{P_g}{P_b})

\end{eqnarray*}</script><p>P~g~表示如果我是个好用户，我属于第i个属性的概率</p>
<script type="math/tex; mode=display">
P_g=P(x\epsilon i|x\epsilon g)=\frac{g_i}{g_T}</script><h3 id="3-取值经验"><a href="#3-取值经验" class="headerlink" title="3. 取值经验"></a>3. 取值经验</h3><p>KL散度与IV见 九-4</p>
<h2 id="9-KL散度"><a href="#9-KL散度" class="headerlink" title="9. KL散度"></a>9. KL散度</h2><h3 id="1-什么是KL散度"><a href="#1-什么是KL散度" class="headerlink" title="1. 什么是KL散度"></a>1. 什么是KL散度</h3><p>在概率论或信息论中，KL散度(Kullback–Leibler divergence)，又称相对熵（relative entropy)，是<strong>描述两个概率分布P和Q差异</strong>的一种方法。它是<strong>非对称</strong>的，这意味着$D(P||Q) ≠ D(Q||P)$。特别的，在信息论中，$D(P||Q)$表示当用<strong>概率分布Q来拟合真实分布P时，产生的信息损耗</strong>，其中P表示真实分布，Q表示P的拟合分布。有人将KL散度称为KL距离，但事实上，KL散度并不满足距离的概念，应为:1）KL散度不是对称的；2）KL散度不满足三角不等式。</p>
<h3 id="2-计算公式-3"><a href="#2-计算公式-3" class="headerlink" title="2. 计算公式"></a>2. 计算公式</h3>
<h3 id="3-信息论含义"><a href="#3-信息论含义" class="headerlink" title="3. 信息论含义"></a>3. 信息论含义</h3><p>KL散度在信息论中有自己明确的物理意义，它是用来度量使用基于Q分布的编码来编码来自P分布的样本平均所需的额外的Bit个数。而其在机器学习领域的物理意义则是用来度量两个函数的相似程度或者相近程度，在泛函分析中也被频繁地用到[2]。在香农信息论中，用基于P的编码去编码来自P的样本，其最优编码平均所需要的比特个数（即这个字符集的熵）为:</p>

<h3 id="4-KL散度与IV"><a href="#4-KL散度与IV" class="headerlink" title="4. KL散度与IV"></a>4. KL散度与IV</h3><script type="math/tex; mode=display">
\begin{eqnarray*}
IV &=& \sum_i (P_g-P_b) ln(\frac{P_g}{P_b})
\\
\\
&=& \sum_i P_gln(\frac{P_g}{P_b}) + \sum_i P_bln(\frac{P_b}{P_g})
\\
\\
&=& KL(P_g||P_b) +KL(P_b||P_g)

\end{eqnarray*}</script><p>即：好用户落在一个特征某个段上概率和坏用户落在这个段上的概率差别越大，IV值越大</p>
<p>即：好坏用户落在同一个属性上的概率越小（指P~g~和P~b~的分布差异越大）则IV值越大</p>
<h2 id="10-F1-score"><a href="#10-F1-score" class="headerlink" title="10. F1-score"></a>10. F1-score</h2><h3 id="1-混淆矩阵"><a href="#1-混淆矩阵" class="headerlink" title="1. 混淆矩阵"></a>1. 混淆矩阵</h3><h3 id="2-二级指标"><a href="#2-二级指标" class="headerlink" title="2. 二级指标"></a>2. 二级指标</h3><h2 id="11-AMS"><a href="#11-AMS" class="headerlink" title="11. AMS"></a>11. AMS</h2><p><a target="_blank" rel="noopener" href="https://higgsml.lal.in2p3.fr/files/2014/04/documentation_v1.8.pdf"></a></p>
<p><a target="_blank" rel="noopener" href="https://www.kaggle.com/c/higgs-boson/overview/evaluation">https://www.kaggle.com/c/higgs-boson/overview/evaluation</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangdongdong122.github.io/2019/10/11/3_%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E8%82%A1%E4%BB%B7%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dongdong Wang">
      <meta itemprop="description" content="从爪印判断，这是头雄狮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凛冬将至">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/11/3_%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E8%82%A1%E4%BB%B7%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 14:52:14" itemprop="dateCreated datePublished" datetime="2019-10-11T14:52:14+08:00">2019-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。</p>
<p>这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。</p>
<p>先随便抽出一道题，看看别人的解法：</p>
<p>int maxProfit(vector<int>&amp; prices) {<br>    if(prices.empty()) return 0;<br>    int s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;</p>
<pre><code>for(int i=1;i&lt;prices.size();++i) &#123;            
    s1 = max(s1, -prices[i]);
    s2 = max(s2, s1+prices[i]);
    s3 = max(s3, s2-prices[i]);
    s4 = max(s4, s3+prices[i]);
&#125;
return max(0,s4);
</code></pre><p>}<br>能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。</p>
<p>本文就来告诉你这个框架，然后带着你一道一道秒杀。</p>
<p>这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。</p>
<p>第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。</p>
<p>一、穷举框架<br>首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。</p>
<p>递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。</p>
<p>而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p>
<p>for 状态1 in 状态1的所有取值：<br>    for 状态2 in 状态2的所有取值：<br>        for …<br>            dp[状态1][状态2][…] = 择优(选择1，选择2…)<br>比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。</p>
<p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p>
<p>dp[i][k][0 or 1]<br>0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= K<br>n 为天数，大 K 为最多交易数<br>此问题共 n × K × 2 种状态，全部穷举就能搞定。</p>
<p>for 0 &lt;= i &lt; n:<br>    for 1 &lt;= k &lt;= K:<br>        for s in {0, 1}:<br>            dp[i][k][s] = max(buy, sell, rest)<br>而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？</p>
<p>我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p>
<p>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。</p>
<p>二、状态转移框架<br>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。</p>
<p>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p>
<p>dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>              max(   选择 rest  ,           选择 sell      )</p>
<p>解释：今天我没有持有股票，有两种可能：<br>要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；<br>要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</p>
<p>dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])<br>              max(   选择 rest  ,           选择 buy         )</p>
<p>解释：今天我持有着股票，有两种可能：<br>要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；<br>要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。<br>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。</p>
<p>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。</p>
<p>dp[-1][k][0] = 0<br>解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。<br>dp[-1][k][1] = -infinity<br>解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。<br>dp[i][0][0] = 0<br>解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。<br>dp[i][0][1] = -infinity<br>解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。<br>把上面的状态转移方程总结一下：</p>
<p>base case：<br>dp[-1][k][0] = dp[i][0][0] = 0<br>dp[-1][k][1] = dp[i][0][1] = -infinity</p>
<p>状态转移方程：<br>dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])<br>读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。</p>
<p>三、秒杀题目<br>第一题，k = 1</p>
<p>直接套状态转移方程，根据 base case，可以做一些化简：</p>
<p>dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])<br>dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i])<br>            = max(dp[i-1][1][1], -prices[i])<br>解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。</p>
<p>现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。<br>可以进行进一步化简去掉所有 k：<br>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>dp[i][1] = max(dp[i-1][1], -prices[i])<br>直接写出代码：</p>
<p>int n = prices.length;<br>int[][] dp = new int[n][2];<br>for (int i = 0; i &lt; n; i++) {<br>    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);<br>    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);<br>}<br>return dp[n - 1][0];<br>显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：</p>
<p>for (int i = 0; i &lt; n; i++) {<br>    if (i - 1 == -1) {<br>        dp[i][0] = 0;<br>        // 解释：<br>        //   dp[i][0]<br>        // = max(dp[-1][0], dp[-1][1] + prices[i])<br>        // = max(0, -infinity + prices[i]) = 0<br>        dp[i][1] = -prices[i];<br>        //解释：<br>        //   dp[i][1]<br>        // = max(dp[-1][1], dp[-1][0] - prices[i])<br>        // = max(-infinity, 0 - prices[i])<br>        // = -prices[i]<br>        continue;<br>    }<br>    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);<br>    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);<br>}<br>return dp[n - 1][0];<br>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p>
<p>// k == 1<br>int maxProfit_k_1(int[] prices) {<br>    int n = prices.length;<br>    // base case: dp[-1][0] = 0, dp[-1][1] = -infinity<br>    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;<br>    for (int i = 0; i &lt; n; i++) {<br>        // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        // dp[i][1] = max(dp[i-1][1], -prices[i])<br>        dp_i_1 = Math.max(dp_i_1, -prices[i]);<br>    }<br>    return dp_i_0;<br>}<br>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。</p>
<p>第二题，k = +infinity</p>
<p>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p>
<p>dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])<br>            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])</p>
<p>我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：<br>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])<br>直接翻译成代码：</p>
<p>int maxProfit_k_inf(int[] prices) {<br>    int n = prices.length;<br>    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;<br>    for (int i = 0; i &lt; n; i++) {<br>        int temp = dp_i_0;<br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);<br>    }<br>    return dp_i_0;<br>}<br>第三题，k = +infinity with cooldown</p>
<p>每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p>
<p>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])<br>解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。<br>翻译成代码：</p>
<p>int maxProfit_with_cool(int[] prices) {<br>    int n = prices.length;<br>    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;<br>    int dp_pre_0 = 0; // 代表 dp[i-2][0]<br>    for (int i = 0; i &lt; n; i++) {<br>        int temp = dp_i_0;<br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);<br>        dp_pre_0 = temp;<br>    }<br>    return dp_i_0;<br>}<br>第四题，k = +infinity with fee</p>
<p>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p>
<p>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])<br>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)<br>解释：相当于买入股票的价格升高了。<br>在第一个式子里减也是一样的，相当于卖出股票的价格减小了。<br>直接翻译成代码：</p>
<p>int maxProfit_with_fee(int[] prices, int fee) {<br>    int n = prices.length;<br>    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;<br>    for (int i = 0; i &lt; n; i++) {<br>        int temp = dp_i_0;<br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);<br>    }<br>    return dp_i_0;<br>}<br>第五题，k = 2</p>
<p>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。</p>
<p>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p>
<p>原始的动态转移方程，没有可化简的地方<br>dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])<br>dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])<br>按照之前的代码，我们可能想当然这样写代码（错误的）：</p>
<p>int k = 2;<br>int[][][] dp = new int[n][k + 1][2];<br>for (int i = 0; i &lt; n; i++)<br>    if (i - 1 == -1) { /<em> 处理一下 base case</em>/ }<br>    dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);<br>    dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);<br>}<br>return dp[n - 1][k][0];<br>为什么错误？我这不是照着状态转移方程写的吗？</p>
<p>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：</p>
<p>int max_k = 2;<br>int[][][] dp = new int[n][max_k + 1][2];<br>for (int i = 0; i &lt; n; i++) {<br>    for (int k = max_k; k &gt;= 1; k—) {<br>        if (i - 1 == -1) {<br>            /<em> 处理 base case </em>/<br>            dp[i][k][0] = 0;<br>            dp[i][k][1] = -prices[i];<br>            continue;<br>        }<br>        dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);<br>        dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);<br>    }<br>}<br>// 穷举了 n × max_k × 2 个状态，正确。<br>return dp[n - 1][max_k][0];<br>如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。</p>
<p>这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以：</p>
<p>dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])<br>dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])<br>dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])<br>dp[i][1][1] = max(dp[i-1][1][1], -prices[i])</p>
<p>int maxProfit_k_2(int[] prices) {<br>    int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;<br>    int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;<br>    for (int price : prices) {<br>        dp_i20 = Math.max(dp_i20, dp_i21 + price);<br>        dp_i21 = Math.max(dp_i21, dp_i10 - price);<br>        dp_i10 = Math.max(dp_i10, dp_i11 + price);<br>        dp_i11 = Math.max(dp_i11, -price);<br>    }<br>    return dp_i20;<br>}<br>有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。</p>
<p>第六题，k = any integer</p>
<p>有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？</p>
<p>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。</p>
<p>直接把之前的代码重用：</p>
<p>int maxProfit_k_any(int max_k, int[] prices) {<br>    int n = prices.length;<br>    if (max_k &gt; n / 2)<br>        return maxProfit_k_inf(prices);</p>
<pre><code>int[][][] dp = new int[n][max_k + 1][2];
for (int i = 0; i &lt; n; i++) 
    for (int k = max_k; k &gt;= 1; k--) &#123;
        if (i - 1 == -1) &#123; 
            /* 处理 base case */
            dp[i][k][0] = 0;
            dp[i][k][1] = -prices[i];
            continue;
        &#125;
        dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
        dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);     
    &#125;
return dp[n - 1][max_k][0];
</code></pre><p>}<br>至此，6 道题目通过一个状态转移方程全部解决。</p>
<p>四、最后总结<br>本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。</p>
<p>关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？</p>
<p>具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。</p>
<p>所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。</p>
<p>作者：labuladong<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangdongdong122.github.io/2019/10/11/3_%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%9F%A9%E9%98%B5%E6%98%A0%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dongdong Wang">
      <meta itemprop="description" content="从爪印判断，这是头雄狮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凛冬将至">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/11/3_%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%9F%A9%E9%98%B5%E6%98%A0%E5%B0%84/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 11:35:04" itemprop="dateCreated datePublished" datetime="2019-10-11T11:35:04+08:00">2019-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="专业词汇"><a href="#专业词汇" class="headerlink" title="专业词汇"></a>专业词汇</h1><ul>
<li><strong>边（edge）</strong>：$W_{ij}$ 特点：对称矩阵</li>
<li><strong>digree</strong>: $D=dig(d);d=rowSum(W_{i,j]})$ 特点：对角阵</li>
<li><p><strong>拉普拉斯矩阵</strong>：$L=D-W$ </p>
</li>
<li><p><strong>拉普拉斯特征映射</strong>：将处于流形上的数据，在尽量保留原数据间相似度的情况下，映射到低维下表示</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangdongdong122.github.io/2019/10/11/3_%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1--%E6%B5%99%E5%A4%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dongdong Wang">
      <meta itemprop="description" content="从爪印判断，这是头雄狮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凛冬将至">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/11/3_%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1--%E6%B5%99%E5%A4%A7/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 11:35:04" itemprop="dateCreated datePublished" datetime="2019-10-11T11:35:04+08:00">2019-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>概率论与数理统计—浙大</p>
<h1 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h1><h2 id="离散期望"><a href="#离散期望" class="headerlink" title="离散期望"></a>离散期望</h2><script type="math/tex; mode=display">
   E(X)=\sum_1^{\infty}x_kp_k</script><h2 id="连续数学期望"><a href="#连续数学期望" class="headerlink" title="连续数学期望"></a>连续数学期望</h2><script type="math/tex; mode=display">
   E(X) = \int_{-\infty}^{\infty}xf(s)</script><h2 id="函数的数学期望"><a href="#函数的数学期望" class="headerlink" title="函数的数学期望"></a>函数的数学期望</h2><script type="math/tex; mode=display">
Z=g(X<Y),二维随机变量的概率密度(X,Y)为f(x,y),则Z的期望：</script><script type="math/tex; mode=display">
   E(Z) = E(g(Z)) = \int_{-\infty}^{+\infty}g(x,y)f(x,y)dxdy</script><p>   若（X，Y）为离散型随机变量，则：</p>
<script type="math/tex; mode=display">
   E(Z) = E(g(X,Y)) = \sum_{j=1}^{\infty}\sum_{i=1}^{\infty}g(x_i,y_j)p_{ij}</script><h1 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h1><script type="math/tex; mode=display">
D(X)=E([X-E(X)]^2)</script><h2 id="均方差-标准差"><a href="#均方差-标准差" class="headerlink" title="均方差/标准差"></a>均方差/标准差</h2><script type="math/tex; mode=display">
   \sqrt{(D(X))}</script><h2 id="离散方差"><a href="#离散方差" class="headerlink" title="离散方差"></a>离散方差</h2><script type="math/tex; mode=display">
   D(X) =\sum_{k=1}^{\infty}[x-E(x)]^2p_k</script><h2 id="连续方差"><a href="#连续方差" class="headerlink" title="连续方差"></a>连续方差</h2><script type="math/tex; mode=display">
   D(X)=\int_{-\infty}^{\infty}[x-E(X)]^2f(x)dx</script><script type="math/tex; mode=display">
   D(X) = E(X^2)-(E(X))^2</script><h2 id="标准化变换"><a href="#标准化变换" class="headerlink" title="标准化变换"></a>标准化变换</h2><script type="math/tex; mode=display">
   X^* = \frac{X-\mu}{\sigma}</script><p>   $X^*$均值为1，方差为0，是X的标准化变量</p>
<h1 id="切比雪夫不等式"><a href="#切比雪夫不等式" class="headerlink" title="切比雪夫不等式"></a>切比雪夫不等式</h1><p>估计未知概率分布的变量取期望附近区间的概率，这个估计是粗糙的</p>
<p>对于任意正数$\epsilon$:</p>
<p>$P{|X-\mu|&gt;=\epsilon} &lt;=\frac{\sigma^2}{\epsilon^2}$</p>
<h1 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h1><p>   $Cov(X,Y) = E{[X-E(X)][Y-E(Y)]}$ 称为X，Y的协方差</p>
<p>   $\rho_{XY} = \frac{Cov(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}$  称为X，Y的相关系数。</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>两个随机变量X，Y相互独立的充要条件是$Cove(X,Y)\neq0$</p>
<ul>
<li>$Cov(X,X) = D(X)$</li>
<li>$Cov(X,Y) = E(XY) - E(X)E(Y)$</li>
<li>$Cov(aX,bY) = abCov(X,Y)$</li>
<li>$Cov(X_1+X_2,Y) = Cov(X_1,Y)+Cov(X_2,Y)$</li>
<li>$|\rho_{xy}|\le1​$</li>
<li>$|\rho|=1$ 的充要条件是存在常数a,b 使得</li>
<li>$P\{Y=aX+b\}=1$</li>
</ul>
<h1 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h1><p>若总体X属于离散型，其分布规律$P\{X=x\} = p(x;\theta)$形式已知，参数未知，事件$\{X_1=x_1,X_2=x_2 …\}$的联合概率：</p>
<p>$L(\theta) = L(x_1,x_2…;\theta) = \prod_{i=1}^{n}p(x_1;\theta)$</p>
<p>$L(\theta)$为样本的似然函数</p>
<ul>
<li>若总体X属于连续型</li>
</ul>
<p>$L(\theta) = \prod_{i=1}^{n}f(x_1;\theta)$</p>
<ul>
<li><p>对数似然方程</p>
<p> $\frac{d}{d\theta}lnL(\theta)=0$</p>
</li>
<li><p>无偏估计</p>
<p> 估计值的期望和实际值期望相同</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangdongdong122.github.io/2019/10/11/2_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dongdong Wang">
      <meta itemprop="description" content="从爪印判断，这是头雄狮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凛冬将至">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/11/2_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 11:35:04" itemprop="dateCreated datePublished" datetime="2019-10-11T11:35:04+08:00">2019-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="时间序列模型"><a href="#时间序列模型" class="headerlink" title="时间序列模型"></a>时间序列模型</h1><h2 id="WEEK1"><a href="#WEEK1" class="headerlink" title="WEEK1"></a>WEEK1</h2><ul>
<li><p>符号解释</p>
<p>$x^{(i)<t>}$:  第i个样本的第t维分量</p>
<p>$T_x^{(i)}$ : 第i个样本x的维度</p>
</li>
<li><p>主体抓取</p>
<ol>
<li><p>多对多模型</p>
</li>
<li><p>不能用全连接，因为输入和输出的长度不定，而且输入矩阵太大</p>
<p><img src="/Users/tessiehe/Documents/study_notes/吴恩达时间序列笔记/image/E36DF04F-C0BD-42D3-9A0D-CA2F2B1C7DE9.png" alt="E36DF04F-C0BD-42D3-9A0D-CA2F2B1C7DE9"></p>
</li>
</ol>
</li>
</ul>
<p>$a^{<0>} = \vec{0}$</p>
<p>$a^{<1>} = g(W_{aa}a^{<0>} +W_{ax}x^{<1>} +b_a)$</p>
<p>$\hat{y}^{<1>} = g(W_{ya}a^{<1>}+b_y)$</p>
<ul>
<li>Forward propagation</li>
</ul>
<p>$a^{<t>} = g(W_{aa}a^{<t-1>} +W_{ax}x^{<t-1>}+b_a)$</p>
<p>$\hat{y^{<t>}} = g(W_{ya}a^{<t>}+b_y)$</p>
<p>为了简化模型，可把$W_{ax},W_{aa}$横向排列成为$W_a$，$a^{<t-1>},x^{t}$纵向排列</p>
<p><img src="/Users/tessiehe/Documents/study_notes/吴恩达时间序列笔记/image/D71818E3-4031-4EF4-99F4-BD47FC6BD0C5.png" alt="D71818E3-4031-4EF4-99F4-BD47FC6BD0C5"></p>
<ul>
<li><p>Back propagation</p>
<p>$L^{<t>} (\hat{y}^{<t>},y^{t}) = -y^{<t>}log(\hat{y})-(1-y^{<t>})log(1-\hat{y}^{<t>})$</p>
<p>$L(\hat{y},y) = \sum_{t=1}^{T_x}L^{<t>}(\hat{y}^{<t>},y^{<t>})$</p>
</li>
<li><p>Different types of RNN</p>
<p><img src="/Users/tessiehe/Documents/study_notes/吴恩达时间序列笔记/image/FF3C6BD2-518A-480C-ADE5-3B71224C7DDB.png" alt="FF3C6BD2-518A-480C-ADE5-3B71224C7DDB"></p>
</li>
<li><p>Language model</p>
<ul>
<li><p>tokenize (one hot)</p>
</li>
<li><p><UNK>来编码非常用单词</p>
</li>
<li><p>目标：判断一个句子的概率</p>
<ul>
<li><p>训练：</p>
<p><img src="/Users/tessiehe/Documents/study_notes/吴恩达时间序列笔记/image/FC45A4AF-B524-425F-8C28-14FF8C16B802.png" alt="ßFC45A4AF-B524-425F-8C28-14FF8C16B802"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Sample a sequence model from trained RNN</p>
<ul>
<li>初始化输入（零向量）</li>
<li>按照预测softmax后的概率sample出一个词</li>
<li>以新词作为输入，softmax预测下一个词的概率，按照概率分布sample出第二个词</li>
</ul>
</li>
<li><p>RNN的梯度消失</p>
<p>梯度爆炸可使用gradient clipping</p>
</li>
<li><p>GRU（Gradient Recurrent Unit）</p>
<ul>
<li><p>c:memory cell</p>
<p>$c^{<t>} = a^{<t>}$</p>
<p>$\hat{c}^{<t>}=tanh(W_c[c^{<t-1>},x^{<t>}]+b_c)$</p>
<p>$\Gamma_u=\sigma(W_u[c^{<t-1>},x^{<t>}]+b_u)$   (u: update,$\Gamma$ 约为0或1)</p>
<p>$c^{<t>} = \Gamma_u\hat{c}^{<t>} +(1-\Gamma_u)c^{<t-1>}$  （$\Gamma$维度和c一样；elemet wise multiply）</p>
<p><img src="/Users/tessiehe/Documents/study_notes/吴恩达时间序列笔记/image/05728660-E7EF-4289-9665-45E6653B03F5.png" alt="05728660-E7EF-4289-9665-45E6653B03F5"></p>
</li>
<li><p>Full GRU</p>
<p>$\hat{c}^{<t>} = tanh(Wc[\Gamma_r*c^{<t-1>},x^{<t>}]+b_c)$</p>
<p>$\Gamma_r=\sigma(W_r[c^{<t-1>},x^{t}]+b_c)$</p>
<p>$\Gamma _u=\sigma(W_u[c^{<t-1>},x^{<t>}]+b_u)$</p>
<p>$c^{<t>} = \Gamma_u<em>\hat{c}^{<t>}+(1-\Gamma_u)</em>c^{<t-1>}$</p>
<p>$a^{<t>} = c^{<t>}$</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>LSTM (Long Short Term Memory)</p>
<p>$\hat{c}^{<t>} = tanh(W_c[a^{<t-1>},x^{<t>}]+b_c)$</p>
<p>$\Gamma_u=\sigma(W_u[a^{<t-1>},x^{<t>}]+b_u)$</p>
<p>$\Gamma_f=\sigma(W_f[a^{<t-1>},x^{<t>}]+b_f)$</p>
<p>$\Gamma_o=\sigma(W_o[a^{<t-1>},x^{<t>}]+b_o)$</p>
<p>$c^{<t>}=\Gamma_u<em>\hat{c}^{<t>}+\Gamma_f</em>c^{<t-1>}$</p>
<p>$a^{<t>}=\Gamma_o*c^{<t>}$</p>
<p><img src="/Users/tessiehe/Documents/study_notes/吴恩达时间序列笔记/image/C9ED60FC-BEA6-49F4-A735-90C7B76F782D.png" alt="C9ED60FC-BEA6-49F4-A735-90C7B76F782D"></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangdongdong122.github.io/2019/10/11/2_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dongdong Wang">
      <meta itemprop="description" content="从爪印判断，这是头雄狮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凛冬将至">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/11/2_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 11:35:04" itemprop="dateCreated datePublished" datetime="2019-10-11T11:35:04+08:00">2019-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深度学习笔记"><a href="#深度学习笔记" class="headerlink" title="深度学习笔记"></a>深度学习笔记</h1><h2 id="BatchNorm"><a href="#BatchNorm" class="headerlink" title="BatchNorm"></a>BatchNorm</h2><ul>
<li><p>基本思想：</p>
<p>深度网络对输入的分布式敏感的，若采用mini-batch方法训练模型，则每次样本分布式不同的。不仅第一层如此，由于非线性的变换，后面每一层的输入（即前一层的输出）的分布都是不一样的，不符合IID独立同分布假设，模型训练也会越来越困难，也就是所谓的internal covariate shift问题。所以考虑在每一层的线下变换后，非线性变化之前，将输出强制变换为0-1分布。</p>
<p>这样做是受图像处理中的白化（whiten）操作的启发：就是对输入数据分布变换到0均值，单位方差的正态分布</p>
<p>所以本质就是：<strong>对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。</strong> </p>
<p>但是，都通过BN，那么不就跟把非线性函数替换成线性函数效果相同了？这意味着什么？我们知道，如果是多层的线性函数变换其实这个深层是没有意义的，因为多层线性网络跟一层线性网络是等价的。这意味着网络的<strong>表达能力</strong>下降了，这也意味着深度的意义就没有了。<strong>所以BN为了保证非线性的获得，对变换后的满足均值为0方差为1的x又进行了scale加上shift操作(y=scale*x+shift)</strong>，每个神经元增加了两个参数scale和shift参数，这两个参数是通过训练学习到的，意思是通过scale和shift把这个值从标准正态分布左移或者右移一点并长胖一点或者变瘦一点，每个实例挪动的程度不一样，这样等价于非线性函数的值从正中心周围的线性区往非线性区动了动。核心思想应该是想找到一个线性和非线性的较好平衡点，既能享受非线性的较强表达能力的好处，又避免太靠非线性区两头使得网络收敛速度太慢。 </p>
</li>
<li><p>流程：</p>
<p><img src="深度学习笔记.assets\1541386887738.png" alt="1541386887738"></p>
</li>
<li><p>inference过程：</p>
<p>由于inference过程只有一个实例，无法获得期望和方差，可用全局方差代替。具体来说就是记住每一个mini-batch的方差和期望，然后统计出全局统计量</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangdongdong122.github.io/2019/10/11/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/VPN%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dongdong Wang">
      <meta itemprop="description" content="从爪印判断，这是头雄狮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凛冬将至">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/11/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/VPN%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 11:35:02" itemprop="dateCreated datePublished" datetime="2019-10-11T11:35:02+08:00">2019-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p> VPN搭建</p>
<p>[TOC]</p>
<p><a target="_blank" rel="noopener" href="https://zoomyale.com/2016/vultr_and_ss/"><strong>https://zoomyale.com/2016/vultr_and_ss/</strong></a></p>
<h1 id="配置服务器shadowsocks"><a href="#配置服务器shadowsocks" class="headerlink" title="配置服务器shadowsocks"></a>配置服务器shadowsocks</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh <span class="comment">#从github下载脚本（点击github对应文件raw，新网页的链接）</span></span><br><span class="line"></span><br><span class="line">chmod +x shadowsocks-all.sh  <span class="comment">#给执行权限</span></span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh">repositry 链接</a></p>
<ul>
<li>用python版本安装</li>
<li>不使用混淆插件</li>
<li>info在/etc/shadowsocks-python文件夹下</li>
<li>修改端口后要 检查服务器shadowsocks是否运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks-libev status</span><br></pre></td></tr></table></figure>
<p>置信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure>
<h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>如果某天你的 ss 突然无法使用了，很可能就是端口被封了。</p>
<p>这时你可以直接在这里，将端口修改为 1-65535 间任意其他数字。编辑完成后，按 Ctrl + X ，再输入 Y 并回车确认退出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure>
<p>需注意的是，如果你更新了配置文件，得重启 ss 才能生效。重启命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks-libev restart</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangdongdong122.github.io/2019/10/11/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/mathtype%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dongdong Wang">
      <meta itemprop="description" content="从爪印判断，这是头雄狮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凛冬将至">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/11/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/mathtype%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 11:35:02" itemprop="dateCreated datePublished" datetime="2019-10-11T11:35:02+08:00">2019-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><code>Windows + R</code> 然后输入<code>regedit.exe</code> 后确定，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190426093524662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdXdhbmxl,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>来到目录<code>HKEY_CURRENT_USER\Software\Install Options</code> 下，删除图片中红线标出来的文件：<br><img src="https://img-blog.csdnimg.cn/20190426094144337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdXdhbmxl,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>操作完上面的步骤后，重新打开MathType，又可以试用30天啦~</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangdongdong122.github.io/2019/10/11/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/numpy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dongdong Wang">
      <meta itemprop="description" content="从爪印判断，这是头雄狮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凛冬将至">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/11/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/numpy/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 11:35:02" itemprop="dateCreated datePublished" datetime="2019-10-11T11:35:02+08:00">2019-10-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="增加行或列"><a href="#增加行或列" class="headerlink" title="增加行或列"></a>增加行或列</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加列</span></span><br><span class="line">a=np.random.randn(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line">b=np.random.randn(<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">c=np.column_stack((a,b))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加行</span></span><br><span class="line">a=np.random.randn(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line">b=np.random.randn(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line">c=np.row_stack((a,b))</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangdongdong122.github.io/2019/10/11/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/pyplot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dongdong Wang">
      <meta itemprop="description" content="从爪印判断，这是头雄狮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="凛冬将至">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/11/0_%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3/pyplot/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 11:35:02" itemprop="dateCreated datePublished" datetime="2019-10-11T11:35:02+08:00">2019-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-27 18:53:36" itemprop="dateModified" datetime="2021-10-27T18:53:36+08:00">2021-10-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="中文显示"><a href="#中文显示" class="headerlink" title="中文显示"></a>中文显示</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">loss1=[1,2,3]</span><br><span class="line">loss2=[1,2,1]</span><br><span class="line">loss3=[2,3,1]</span><br><span class="line"></span><br><span class="line">matplotlib.rcParams[&#x27;font.family&#x27;]=&#x27;STSong&#x27;#显示中文 修改了全局变量</span><br><span class="line">matplotlib.rcParams[&#x27;font.size&#x27;]=10</span><br><span class="line">plt.title(&#x27;主成分分析&#x27;)</span><br><span class="line">plt.xlabel(&#x27;主成分数量&#x27;)</span><br><span class="line">plt.ylabel(&#x27;loss&#x27;)</span><br><span class="line">plt.plot(loss1,label=&#x27;loss1&#x27;)</span><br><span class="line">plt.plot(loss2,label=&#x27;loss2&#x27;)</span><br><span class="line">plt.plot(loss3,label=&#x27;loss3&#x27;)</span><br><span class="line">plt.legend()#图例</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果图<br></p>
<h1 id="多个子图"><a href="#多个子图" class="headerlink" title="多个子图"></a>多个子图</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">loss1=[1,2,3]</span><br><span class="line">loss2=[1,2,1]</span><br><span class="line">loss3=[2,3,1]</span><br><span class="line"></span><br><span class="line">plt.subplot(2,1,1) #两行一列图中的第一幅图</span><br><span class="line">plt.plot(loss1)</span><br><span class="line">plt.plot(loss2)</span><br><span class="line">plt.xlabel(&#x27;epoch&#x27;)</span><br><span class="line">plt.ylabel(&#x27;loss&#x27;)</span><br><span class="line">plt.legend(labels=[&#x27;train_loss&#x27;, &#x27;test_loss&#x27;])</span><br><span class="line"></span><br><span class="line">plt.subplot(2,1,2) #两行一列图中的第一幅图</span><br><span class="line">plt.plot(loss2)</span><br><span class="line">plt.plot(loss3)</span><br><span class="line">plt.xlabel(&#x27;epoch&#x27;)</span><br><span class="line">plt.ylabel(&#x27;auc&#x27;)</span><br><span class="line">plt.legend(labels=[&#x27;train_auc&#x27;, &#x27;test_auc&#x27;])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果图</p>

<h1 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h1><h2 id="2D三点图"><a href="#2D三点图" class="headerlink" title="2D三点图"></a>2D三点图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib</span><br><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">x=np.random.rand(2,20)</span><br><span class="line">label=np.random.randint(2, size=20)</span><br><span class="line"></span><br><span class="line">plt.scatter(x[0,:],x[1,:],c=label)#同一个label的点是同一个颜色</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果图</p>
<p><img src="./pics/1563430474219.png" alt="1563430474219"></p>
<h2 id="3d-三点图"><a href="#3d-三点图" class="headerlink" title="3d 三点图"></a>3d 三点图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.scatter(X_new[:,<span class="number">0</span>].reshape(-<span class="number">1</span>),X_new[:,<span class="number">1</span>].reshape(-<span class="number">1</span>), X_new[:,<span class="number">2</span>].reshape(-<span class="number">1</span>))</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;X Label&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Y Label&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;Z Label&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果：</p>

<h1 id="实时画图"><a href="#实时画图" class="headerlink" title="实时画图"></a>实时画图</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.axis([<span class="number">0</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">80</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    z = <span class="number">68</span> + <span class="number">4</span> * np.random.randn(<span class="number">50</span>)</span><br><span class="line">    zm = np.cumsum(z) / <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(z)+<span class="number">1</span>)</span><br><span class="line">    plt.plot(zm)    </span><br><span class="line"></span><br><span class="line">n = np.arange(<span class="number">1</span>,<span class="number">51</span>)</span><br><span class="line">su = <span class="number">68</span> + <span class="number">4</span> / np.sqrt(n)</span><br><span class="line">sl = <span class="number">68</span> - <span class="number">4</span> / np.sqrt(n)</span><br><span class="line"></span><br><span class="line">plt.plot(n,su,n,sl) </span><br><span class="line">plt.show()<span class="comment">#阻塞函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Dongdong Wang</p>
  <div class="site-description" itemprop="description">从爪印判断，这是头雄狮</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:wangdongdong122@163.com" title="E-Mail → mailto:wangdongdong122@163.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        <div class="wechat_OA">
            <span>欢迎加微信讨论</span>
            <br>
            <!-- 这里添加你的二维码图片 -->
            <img src ="/images/wechat.png" style="zoom:40%;" />
        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dongdong Wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
