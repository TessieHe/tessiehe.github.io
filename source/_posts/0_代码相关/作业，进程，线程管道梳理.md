---
title: 作业，进程，线程管道梳理
date: 2022-03-01 11:32:38
tags:
    - 代码相关
    - default
categories: 
    - 代码相关
---

进程-线程科普

<!-- more -->


作业，进程，线程，管程，管道梳理

[TOC]

# 基础概念 

进程（process）：程序在一个数据集上的一次运行过程。是操作系统资源分配的基本单位。

 线程（thread）：是进程中的一个实体，是被操作系统独立调度和执行的基本单位。一个进程包含一个或多个线程。

>多线程间是共用内存空间的，但有的内存只能同时被一个线程访问，有的内存只能同时被有限个线程访问。所以每个内存会有一个锁，当超额的线程访问此内存时就需要排队。当一个线程长时间占用内存时就会导致“锁死”

![image-20200331114405031](.\pics\作业，进程，线程管道梳理.assets\image-20200331114405031.png)

# shell中多进程管理

# python中多进程管理

- 单进程：

```python
import time
import os

def long_time_task():
    print('当前进程: {}'.format(os.getpid()))
    time.sleep(2)
    print("结果: {}".format(8 ** 20))

if __name__ == "__main__":
    print('当前母进程: {}'.format(os.getpid()))
    start = time.time()
    for i in range(2):
        long_time_task()

    end = time.time()
    print("用时{}秒".format((end-start)))
```

输出：

```
当前母进程: 14236
当前进程: 14236
结果: 1152921504606846976
当前进程: 14236
结果: 1152921504606846976
用时4.01080060005188秒
```

- 多进程后：

Process方法接收两个参数, 第一个是target，一般指向函数名，第二个时args，需要向函数传递的参数。对于创建的新进程，调用start()方法即可让其开始。我们可以使用os.getpid()打印出当前进程的名字。之所以我们使用join()方法就是为了让母进程阻塞，等待子进程都完成后才打印出总共耗时，否则输出时间只是母进程执行的时间。

```python
from multiprocessing import Process
import os
import time


def long_time_task(i):
    print('子进程: {} - 任务{}'.format(os.getpid(), i))
    time.sleep(2)
    print("结果: {}".format(8 ** 20))


if __name__=='__main__':
    print('当前母进程: {}'.format(os.getpid()))
    start = time.time()
    p1 = Process(target=long_time_task, args=(1,))
    p2 = Process(target=long_time_task, args=(2,))
    print('等待所有子进程完成。')
    p1.start()
    p2.start()
    p1.join()
    p2.join()
    end = time.time()
    print("总共用时{}秒".format((end - start)))

```

输出：

```
当前母进程: 6920
等待所有子进程完成。
子进程: 17020 - 任务1
子进程: 5904 - 任务2
结果: 1152921504606846976
结果: 1152921504606846976
总共用时2.131091356277466秒
```

# python调用shell的方法

## os.system（cmd）

返回值：shell运行指令后的状态码，int，0表示运行成功，256表示未找到。**适用于shell不需要输出内容的场景**

```python
import os
val = os.system('ls -al')
print('val')
```



## os.popen()

返回值：文件的形式返回shell指令运行后的结果，需要获取内容时可使用read()或readlines（）方法





## commands

## subprocess

